<html>
<head>
<title>The Internals and Data Structures of the SML# Compiler Version 0.20.</title>
</head>
<body>

<hr>
<hr>

<h2>
Internals and data structures of the SML# Compiler 0.20.
</h2>

<dl>
<dt>authors</dt>
<dd>Atsushi Ohori and YAMATODANI Kiyoshi</dd>
<dt>version</dt>
<dd>$Id: Overview.html,v 1.12.6.1 2007/03/29 19:11:13 ohori Exp $</dd>
</dl>
<hr>

We intentd to report internal technical details and data structures of
the SML# compiler in some technical forum in near future. 
<P>
This section is for those technical minds who would like to read the
SML# Compiler Source code.
<P>
We believe that the following two tables are sufficient for you
to get started with the source code.
If you would like to know any particular aspect of the compiler, 
please  contact Atsushi Ohori (ohori at riec dot tohoku dot ac dot jp).


<center>
<h3>
the set of SML#  intermediate languages ver. 0.20
</h3>
<table border="1">
  <tr>
    <th>Language</th>
    <th>Structure Name</th>
    <th>Directory</th>
  </tr>
  <tr>
    <td>Abstract Syntax Trees</td>
    <td>Absyn</td>
    <td>compiler/absyn</td>
  </tr>
  <tr>
    <td>Untyped Pattern Expressions (1)</td>
    <td>PatternCalc</td>
    <td>compile/patterncalc</td>
  </tr>
  <tr>
    <td>Untyped Pattern Expressions (2)</td>
    <td>PatternCalcWithTvars</td>
    <td>compile/patterncalcWithTvars|</td>
  </tr>
  <tr>
    <td>Typed Pattern Expressions(1)</td>
    <td>TypedCalc</td>
    <td>compile/typedcalc</td>
  </tr>
  <tr>
    <td>Typed Pattern Expressions(2)</td>
    <td>TypedFlatCalc</td>
    <td>compile/typedflatcalc</td>
  </tr>
  <tr>
    <td>Polymorphic Record Calculus</td>
    <td>RecordCalc</td>
    <td>compile/recordcalc</td>
  </tr>
  <tr>
    <td>Typed Lambda Calculs</td>
    <td>TypedLambda</td>
    <td>compile/typedlambda</td>
  </tr>
  <tr>
    <td>Typed Bitmap-Passing Calculus</td>
    <td>BUCCalc</td>
    <td>compile/buccalc</td>
  </tr>
  <tr>
    <td>Typed A-Normal Form</td>
    <td>ANormal</td>
    <td>compile/anormal</td>
  </tr>
  <tr>
    <td>SML# Symbolict Instruction Set</td>
    <td>SymbolicInstructions</td>
    <td>compile/symbolicInstructions</td>
  </tr>
  <tr>
    <td>SML# Instruction</td>
    <td>Instructions</td>
    <td>instructions/compile/instructions</td>
  </tr>
  <tr>
    <td>SML# Bytecode Language</td>
    <td>Instructions.cc(definitions in C)</td>
    <td>instructions/runtime/instructions</td>
  </tr>
</table>
</center>

<center>
<h3>
the SML#  compilation steps ver. 0.20
</h3>
<table border="1">
  <tr>
    <th> Step </th>
    <th>description</th>
    <th>compile module</th>
    <th>directory</th>
    <th>input</th>
    <th>output</th>
  </tr>
  <tr>
    <td></td>
    <td>the compiler top level </td>
    <td>Top</td>
    <td>compile/toplevel</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>1.</td>
    <td>Parsing </td>
    <td>Parser</td>
    <td>compile/parse</td>
    <td>the source program </td>
    <td> Absyn</td>
  </tr>
  <tr>
    <td>2.</td>
    <td>Elaboration</td>
    <td>Elaborator</td>
    <td>compile/elaborate</td>
    <td>Absyn</td>
    <td>PattarnCalc</td>
  </tr>
  <tr>
    <td>3.</td>
    <td>function definition optimization</td>
    <td>VALREC_Optimizer</td>
    <td>compile/valrecoptimization</td>
    <td>PatternCalc</td>
    <td>PatternCalc</td>
  </tr>
  <tr>
    <td>4.</td>
    <td>user type variable evaluation</td>
    <td>SetTVars</td>
    <td>compile/settvars</td>
    <td>PatternCalc</td>
    <td>PatternCalcWithTvars</td>
  </tr>
  <tr>
    <td>5.</td>
    <td>type inference</td>
    <td>TypeInferencer</td>
    <td>compile/typeinference</td>
    <td>PatternCalcWithTvars</td>
    <td>TypedCalc</td>
  </tr>
  <tr>
    <td>6.</td>
    <td>uncurrying optimization</td>
    <td>UncurryFundecl</td>
    <td>compile/typeinference</td>
    <td>TypedCalc</td>
    <td>TypedCalc</td>
  </tr>
  <tr>
    <td>7.</td>
    <td>printer code generation</td>
    <td>PrinterGenerator</td>
    <td>compile/printergeneration</td>
    <td>TypedCalc</td>
    <td>TypedCalc</td>
  </tr>
  <tr>
    <td>8.</td>
    <td>module conpilation</td>
    <td>ModuleCompiler</td>
    <td>compile/modulecompilation</td>
    <td>TypedCalc</td>
    <td>TypedFlatCalc</td>
  </tr>
  <tr>
    <td>9.</td>
    <td>match compilation</td>
    <td>MatchCompiler</td>
    <td>compile/matchcompilation</td>
    <td>TypedFlatCalc</td>
    <td>RecordCalc</td>
  </tr>
  <tr>
    <td>10.</td>
    <td>record compilation</td>
    <td>RecordCompiler</td>
    <td>compile/recordcompilation</td>
    <td>RecordCalc</td>
    <td>TypedLambda</td>
  </tr>
  <tr>
    <td>11.</td>
    <td>bitmap-passing/unbox/closure conversion</td>
    <td>BUCTransformer</td>
    <td>compile/buctransformation</td>
    <td>TypedLambda</td>
    <td>BUCCalc</td>
  </tr>
  <tr>
    <td>12.</td>
    <td>A-normalization</td>
    <td>ANormalTranslator</td>
    <td>compile/anormaltransform</td>
    <td>BUCCCalc</td>
    <td>ANormal</td>
  </tr>
  <tr>
    <td>13.</td>
    <td>Anormal form optimization</td>
    <td>ANormalOptimizer</td>
    <td>compile/anormaloptimization</td>
    <td>ANormal</td>
    <td>ANormal</td>
  </tr>
  <tr>
    <td>14.</td>
    <td>symbolic code generation</td>
    <td>Linearizer</td>
    <td>compile/linearize</td>
    <td>ANormal</td>
    <td>SymbolicInstructions</td>
  </tr>
  <tr>
    <td>15.</td>
    <td>symbolic code optimization</td>
    <td>SymbolicInstructionsOptimizer</td>
    <td>compile/sioptimization</td>
    <td>SymbolicInstructions</td>
    <td>SymbolicInstructions</td>
  </tr>
  <tr>
    <td>16.</td>
    <td>assemble</td>
    <td>Assembler</td>
    <td>compile/assemble</td>
    <td>SymbolicInstructions</td>
    <td>Instructions</td>
  </tr>
  <tr>
    <td>17.</td>
    <td>code emmition</td>
    <td>ExecutableSerializer</td>
    <td>instructions/compiler</td>
    <td>Instructions</td>
    <td>(bytecode in binary form)</td>
  </tr>
</table>
</center>

<hr>

</body>
</html>
