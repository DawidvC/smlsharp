(**
 * A calculus with explicitly scoped user type variables.
 *
 * @copyright (c) 2006, Tohoku University.
 * @author Atsushi Ohori 
 * @author Liu Bochao
 * @version $Id: PatternCalcWithTvars.ppg,v 1.5 2006/03/02 12:48:46 bochao Exp $
 *)
structure PatternCalcWithTvars : PATTERNCALCWITHTVARS = struct

 type loc = Loc.loc

 (*%
  * @formatter(tyFormat) Absyn.format_ty
  *)
 type ty = 
     (*%
      * @format(value:tyFormat) value
      *)
     Absyn.ty

  (*%
   * @formatter(set) Types.format_tvarNameSet
   *)
  type tvarNameSet = 
      (*% 
       *   @format(set:set) set 
       *) 
      Types.tvarNameSet

(*%
 * @formatter(caseKindFormat) Types.format_caseKind
 *)
type caseKind = 
     (*%
      * @format(value:caseKindFormat) value
      *)
    Types.caseKind

   datatype constant = datatype Absyn.constant

  (*%
   * @formatter(longidFormat) Absyn.format_longid
   *)
  type longid = 
       (*%
	* @format(longid:longidFormat) longid
	*)
       Absyn.longid


 (*%
  * @formatter(tvarFormat) Absyn.format_tvar
  *)
  type tvar = 
    (*%
    * @format(tvar:tvarFormat) tvar
    *)
    Absyn.tvar


 (*%
 * @formatter(constant) Absyn.format_constant
 * @formatter(enclosedList) SmlppgUtil.formatListWithEnclosure
 * @formatter(binaryChoice) SmlppgUtil.formatBinaryChoice
 * @formatter(prependedOpt) SmlppgUtil.formatPrependedOpt
 * @formatter(enclosedOpt) SmlppgUtil.formatEnclosedOpt
 * @formatter(enclosedListIfMoreThanOne) SmlppgUtil.formatListWithEnclosureIfMoreThanOne
 *)
 datatype ptexp = 
     (*%
      * @format(const:constant * loc) const
      *)
     PTCONSTANT of constant * loc
   | (*%
      * @format(longid * loc) {longid}
      *)
     PTVAR of longid * loc
   | (*%
      * @format(exp * ty * loc) exp + 2[+1 ":" + ty]
      *)
     PTTYPED of ptexp * ty * loc
   | (*%
      * @format(exp1 * arg args:enclosedListIfMoreThanOne * loc)
      * L10{
      *      exp1 + args(arg)(","+1, "{", "}")
      *    }
      *)
     PTAPPM of ptexp * ptexp list * loc
   | (*%
      * @format(dec decs * exp exps * loc)
      *          !N0{ {"let" 2[ +1 decs(dec)( +1) ]}  +1
      *               {"in" 2[ +2 exps(exp)( +3 ) ] +2
      *                 "end"} }
      *)
     PTLET of ptdecl list * ptexp list * loc
   | (*%
      * @format(field fields:enclosedList * loc) fields(field)(",","{","}")
      * @format:field(lab * exp)  lab + "=" + exp
      *)
     PTRECORD of (string * ptexp) list * loc
   | (*%
      * @format(exp * field fields:enclosedList * loc)
      *   N0{ {exp} + "#" + fields(field)(",","{","}") }
      * @format:field(lab * exp)  lab + "=" + exp
      *)
     PTRECORD_UPDATE of ptexp * (string * ptexp) list * loc
   | (*%
      * @format(value values:enclosedList * loc) values(value)("," +, + "(", ")")
      *)
     PTTUPLE of ptexp list * loc
   | (*%
      * @format(exp * loc) N0{ "raise" +d {exp} }
      *)
     PTRAISE of ptexp * loc
   | (*%
      * @format(exp * rule rules * loc)
      *          N0{exp 
                    +1 "handle" 
                          +d rules(rule)( ~2[ +1 "|"] +)}
      * @format:rule(pat * exp) {pat} + "=>" +1 {exp}
      *)
     PTHANDLE of ptexp * (ptpat * ptexp) list * loc
   | (*%
      * @format(tvars * rule rules * loc) !N0{ "fn" + tvars + {rules(rule)(~2[ +1 "|"] +)} }
      * @format:rule(pat pats:enclosedListIfMoreThanOne * exp)
      * {pats(pat)(","+1, "{", "}")} + "=>" +1 {exp}
      *)
     PTFNM of tvarNameSet * (ptpat list * ptexp) list * loc 
   | (*%
      * @format(tvars * varTyOpt ids:enclosedListIfMoreThanOne * exp * loc) 
          !N0{ "fn" + tvars ids(varTyOpt)(",","{","}") 2[ +d "=>" {exp}] }
      * @format:varTyOpt(id * ty list opt) id
      *)
     PTFNM1 of tvarNameSet * (string * ty list option) list * ptexp * loc 
   | (*%
      * @format(exp exps * rule rules * caseKind * loc)
      * N0{ caseKind 2[ +d "{" {exps(exp)(",")} "}" ] 2[ +1 "of" ]+ {rules(rule)(~2[ +1 "|" ]+)}}
      * @format:rule(pat pats * exp) {"{" {pats(pat)(",") "}"} + "=>" +1 {exp}}
      *)
     PTCASEM of ptexp list *  (ptpat list * ptexp) list * caseKind * loc  (* primitive; caseKind added *)
   | (*%
      * @format(selector * loc)  {"#"{selector}}
      *)
     PTRECORD_SELECTOR of string * loc  
   | (*%
      * @format(selector * exp * loc) L10{"#"{selector} + {exp}}
      *)
     PTSELECT of string * ptexp * loc  
  | (*%
     * @format(exp exps * loc)
     *                    !N0{ "(" 2[ 1 exps(exp)(";" +1) ] 1 ")" }
     *)
     PTSEQ of ptexp list * loc
  | (*%
     * @format(exp * loc) "_cast" "(" exp ")"
     *)
     PTCAST of ptexp * loc

 and ptdecl = 
     (*%
      * @format(tvars1 * tvars2 * bind binds * loc)
      *       "val" + tvars1 + tvars2 + {binds(bind)(~4[ +1 "and"] +)}
      * @format:bind(pat * exp) {pat} +d "=" +2 {exp}
      *)
      (*
       * tvarNameSet1 : explicitly scoped
       * tvarNameSet2 : ungarded
       *)
     PTVAL of tvarNameSet * tvarNameSet * (ptpat * ptexp ) list * loc 
   | (*%
         * @format(tvars1 * tvars2 * dec binds * loc)
         *  "fun" tvars1 d {binds(dec)(~4[ +1 "and"] +)}
         * @format:dec(pat * rules) {pat + rules}
         * @format:rules(rule rules) {rules(rule)(~2[ +1"|"] +)}
         * @format:rule(pat pats *  exp)
         *    {pats(pat)(+d)} +d "=" +1 {exp}
         *)
      PTDECFUN of tvarNameSet * tvarNameSet * (ptpat * (ptpat list * ptexp) list) list * loc 
   | (*%
         * @format(tvars1 * tvars2 * dec * loc)
         *  "nonrecfun" + tvars1 +d {dec}
         * @format:dec(fpat * rules) {fpat + rules}
         * @format:rules(rule rules) {rules(rule)(~2[ +1"|"] +)}
         * @format:rule(pat pats *  exp)
         *    {pats(pat)(+d)} +d "=" +1 {exp}
         *)
      PTNONRECFUN of tvarNameSet * tvarNameSet * (ptpat * (ptpat list * ptexp) list) * loc 
   | (*%
      * @format(tvars1 * tvars2 * bind binds * loc)
      *  "val" + tvars1 d
      *          "rec" +d {binds(bind)(~4[ +1 "and"] +)}
      * @format:bind(pat * exp) {pat} +d "=" +2 {exp}
      *)
      (*
       * tvarNameSet1 : explicitly scoped
       * tvarNameSet2 : ungarded
       *)
     PTVALREC of tvarNameSet * tvarNameSet * (ptpat * ptexp ) list * loc
   | (*%
      * @format(id ids * dec decs * loc) decs(dec)(+ 1)
      *)
     PTVALRECGROUP of string list * ptdecl list * loc
   | (*%
      * @format(bind binds * loc) "type" + {binds(bind)(~4[ +1 "and"] +)}
      * @format:bind(tyvar tyvars:enclosedList * name * ty)
      *            {tyvars(tyvar)("," +, "(", ")" +)} {name} +d "=" +2 ty
      *)
     PTTYPE of (tvar list * string * ty) list * loc
   | (*%
      * @format(bind binds * loc)
      *                 "datatype" + {binds(bind)(~4[ +1 "and" ] +)}
      * @format:bind(tyvar tyvars:enclosedList * tyCon * valcon valcons)
      * {tyvars(tyvar)("," +, "(", ")" +) {tyCon} + "=" +1
      *                                {valcons(valcon)(~2[ +1 "|" ] +)}}
      * @format:valcon(b:binaryChoice * name * ty option:prependedOpt)
      *          {b()("op" +, "")} {name} {option(ty)(~2[ +d "of" ] +)}
      *)
     PTDATATYPE of (tvar list * string * (bool * string * ty option) list) list * loc
   | (*%
      * @format(left * right * loc) {left} +d "=" +1 {right}
      *)
     PTREPLICATEDAT of string * longid * loc
   | (*%
      * @format(bind binds * decl decls * loc) "abstype"
      *)
     PTABSTYPE of
       (tvar list * string * (bool * string * ty option) list) list 
       * ptdecl list
       * loc
   | (*%
      * @format(exc excs * loc) "exception" + {excs(exc)(~4[ +1 "and" ]+)}
      *)
     PTEXD of ptexbind list * loc
   | (*%
      * @format(localdec localdecs * dec decs * loc)
      *            "local" 2[ +2 localdecs(localdec)(+d) ] +1
      *            "in" 2[ +2 decs(dec)(+3) ] +2
      *            "end"
      *)
     PTLOCALDEC of ptdecl list * ptdecl list * loc
   | (*%
      * @format(longid longids * loc)
      *                "open" +  longids(longid)(5[+1])
      *)
     PTOPEN of longid list * loc
   | (*%
      * @format(int * name names * loc)
      *                   "infix" +d {int} +d names(name)(+d)
      *)
     PTINFIXDEC of int * string list * loc
   | (*%
      * @format(int * name names * loc)
      *                   "infixr" +d {int} +d names(name)(+d)
      *)
     PTINFIXRDEC of int * string list * loc
   | (*%
      * @format(name names * loc) "nonfix" +d names(name)(+d)
      *)
     PTNONFIXDEC of string list * loc
   | (*%
      * @format({name:name,funExp:funExp, libExp:libExp, argTyList:argty argtys, resultTy:resultty,loc:loc})
      *       "val" + "import" + name + "=" +1
      *       funExp +d "of" +d
      *       libExp +2
      *       ":" + "{" {argtys(argty)("," +)} "}" "->" {resultty}
      *)
     PTFFIVAL of 
     {
       name:string, 
       funExp:ptexp, 
       libExp:ptexp,
       argTyList:ty list, 
       resultTy:ty, 
       loc:loc
      }
   | (*%
      * @format ""
      *)
     PTEMPTY 

 and ptpat 
  = (*%
     * @format(loc) "_"
     *)
     PTPATWILD of loc
   | (*%
      * @format(longid * loc) longid
      *)
     PTPATID of longid * loc
   | (*%
      * @format(const * loc) const
      *)
     PTPATCONSTANT of constant * loc
   | (*%
      * @format(pat1 * pat2 * loc) R1{d {pat1} + "(" + N0{pat2} ")"}
      *)
     PTPATCONSTRUCT of ptpat * ptpat * loc
   | (*%
      * @format(ifflex:binaryChoice * patfield patfields:enclosedList * loc) 
             patfields(patfield)(",","{","") + ifflex()("...","}")
      * @format:patfield(lab * pat) lab + "=" + pat
      *)
     PTPATRECORD of bool * (string * ptpat) list * loc
   | (*%
      * @format(id * ty opt * pat2 * loc) {id} +d "as" +d {pat2}
      *)
     PTPATLAYERED of string * ty option * ptpat * loc
   | (*%
      * @format(pat * ty * loc) {pat} + ":" +d {ty}
      *)
     PTPATTYPED of ptpat * ty * loc

 and ptexbind =
          (*%
           * @format(b * name * ty option:prependedOpt * loc)
           *          {name} {option(ty)(+d "of" +)}
           *)               
          PTEXBINDDEF of bool * string * ty option * loc
        | (*%
           * @format(b1 * left * b2 * right * loc)
           *          "exception" + {left} +d "=" +2 {right}
           *)
          PTEXBINDREP of bool * string * bool * longid * loc

 and ptstrdec =
     (*%
      * @format(dec * loc) dec
      *)
     PTCOREDEC of ptdecl * loc
   | (*%
     * @format(strbind strbinds * loc)  "structure" +d 4[strbinds(strbind)(~2[ +1 "and"] +)] 
     * @format:strbind(strid * strexp) strid + "=" +1 strexp
     *)
     PTSTRUCTBIND of (string * ptstrexp) list * loc
   |(*%
     * @format(localstrdec localstrdecs  * strdec  strdecs * loc)
     *            "local" 2[ +2 localstrdecs(localstrdec)(+d) ] +1
     *            "in" 2[ +2 strdecs(strdec)(+3) ] +2
     *            "end"
     *)
      PTSTRUCTLOCAL of ptstrdec list * ptstrdec list * loc

 and ptstrexp =
     (*%
      * @format(strdec strdecs * loc) "struct"  2[ +1 strdecs(strdec)(+1)] +1  "end"
      *)
     PTSTREXPBASIC of ptstrdec list * loc (*basic*)
   |(*%
     * @format(longid * loc) longid
     *)
     PTSTRID of longid * loc (*structure identifier*)
   |(*%
     * @format(strexp * sigexp * loc) strexp + ":" +  sigexp
     *)
     PTSTRTRANCONSTRAINT of ptstrexp * ptsigexp * loc (*transparent constraint*)
   |(*%
     * @format(strexp * sigexp * loc) strexp + ":>" + sigexp
     *)
     PTSTROPAQCONSTRAINT of ptstrexp * ptsigexp * loc (*opaque constraint*)
   |(*%
     * @format(functorid * strexp * loc) {functorid} {+d "(" strexp ")"}
     *)
     PTFUNCTORAPP of string * ptstrexp * loc (* functor application*)
   |(*%
     * @format(strdec strdecs * strexp * loc) 
     *	   !N0{ {"let" 2[ +1 strdecs(strdec)( +1) ]}  +1
     *              {"in" 2[ +2 strexp ] +2
     *              "end"} }
     *)
    PTSTRUCTLET  of ptstrdec list * ptstrexp * loc (*local declaration*)


 and ptsigexp = 
     (*%
      * @format(spec * loc) "sig" 2[+1 spec ] +1 "end"  
      *)
     PTSIGEXPBASIC of ptspec * loc (*basic*)
   |(*%
     * @format(sigid * loc) {sigid} 
     *)
     PTSIGID of string * loc (*signature identifier*)
   |(*%
     *@format(sigexp * rlstn rlstns * loc) sigexp +1 "where" + "type" + rlstns(rlstn)(+1 "where" + "type")
     *@format:rlstn(tyvarseq * patlongid * ty) tyvarseq + patlongid +  "=" + ty
     *@format:tyvarseq(tyvar tyvars:enclosedList) tyvars(tyvar) ("," +, "(", ")" +)
     *)
     PTSIGWHERE of ptsigexp * (tvar list * longid * ty) list * loc (* type realisation *) 


 and ptspec =
     (*%
      * @format(specval specvals * loc) "val" + {specvals(specval)(~4[ +1 "and"] +)} 
      * @format:specval(vid * ty) {{vid} + ":" +1 {ty}}
      *)
     PTSPECVAL of (string * ty) list * loc (* value *)
   |
   (*%
    * @format(typdesc typdescs * loc)  "type" + {typdescs(typdesc)(~4[ +1 "and"] +)}
    * @format:typdesc(tyvar tyvars:enclosedList * tyCon) 
    * {tyvars(tyvar) ("," +, "(", ")" +) {tyCon} }
    *)
     PTSPECTYPE of (tvar list * string) list  * loc (* type *)
   |
    (*%
    * @format(derivedtyp  * loc)  derivedtyp
    * @format:derivedtyp(tyvar tyvars:enclosedList * tyCon * ty)  "type" + {tyvars(tyvar) ("," +, "(", ")" +) {tyCon} } + "=" + ty
    *)
   PTSPECTYPEEQUATION of (tvar list * string * ty)   * loc
   |
   (*%
    * @format(typdesc typdescs * loc)  "eqtype" + {typdescs(typdesc)(~4[ +1 "and"] +)}
    * @format:typdesc(tyvar tyvars:enclosedList * tyCon) 
    * {tyvars(tyvar) ("," +, "(", ")" +) {tyCon} }
    *)
   PTSPECEQTYPE of (tvar list * string) list * loc (* eqtype *)
   |
   (*%
    * @format(datdesc datdescs * loc)  "datatype" + {datdescs(datdesc)(~4[ +1 "and"] +)}
    * @format:datdesc(tyvar tyvars:enclosedList * tyCon * condesc condescs) 
    * {tyvars(tyvar) ("," +, "(", ")" +) {tyCon} + "=" +1
    *                                 {condescs(condesc)(~2[ +1 "|" ] +)}}
    * @format:condesc(vid * ty option:prependedOpt) {vid} {option(ty)(~2[ +d "of" ] +)}
    *)
   PTSPECDATATYPE of (tvar list * string * (string * ty option) list ) list * loc (* datatype*)
   |
   (*%
    * @format(tyCon * patlongid * loc) "datatype" + tyCon + "=" + "datatype" + patlongid
    *)
     PTSPECREPLIC of string * longid * loc (* replication *)
   |
   (*%
    * @format(exdesc exdescs * loc) "exception" + {exdescs(exdesc)(~4[ +1 "and" ]+)}
    * @format:exdesc(vid * ty option:prependedOpt)
    *          {vid} {option(ty)(+d "of" +)}
    *)     
     PTSPECEXCEPTION of (string * ty option) list * loc (* exception *)
   |
   (*%
    * @format(strdesc strdescs * loc) !N0{ "structure" + {strdescs(strdesc)(~2[ +1 "and" ] +)}}
    * @format:strdesc(strid * sigexp) !N0{ strid ":" +d sigexp}
    *)
     PTSPECSTRUCT of (string * ptsigexp) list * loc (* structure *)
   |
   (*%
    * @format(sigexp * loc) !N0{"include" + {sigexp}}
    *)
     PTSPECINCLUDE of ptsigexp * loc (* include *)
   | 
   (*%
    * @format(spec1 * spec2 * loc) spec1 +  ";" +1 spec2
    *)
     PTSPECSEQ of ptspec * ptspec * loc 
   |
   (*%
    * @format(spec * patlongid patlongids * loc) spec +1 !N0{ "sharing type" + {patlongids(patlongid)(~2[ +1 "="] +)} }
    *)
     PTSPECSHARE of ptspec * longid list * loc 
   |
   (*%
    * @format(spec * longid longids * loc) spec +1 !N0{ "sharing" + {longids(longid)(~2[ +1 "="] +)} }
    *)
     PTSPECSHARESTR of ptspec * longid list * loc 
   |
   (*%
    * @format
    *)
     PTSPECEMPTY


and pttopdec = 
    (*%
     * @format (strdec * loc) strdec
     *)
    PTTOPDECSTR of ptstrdec * loc (* structure-level declaration *)
  | (*%
     * @format(sigdec sigdecs * loc) "signature" + {sigdecs(sigdec)(~4[ +1 "and"] +)}
     * @format:sigdec(sigid * sigexp) sigid +d "=" +1 sigexp
     *)
    PTTOPDECSIG of( string * ptsigexp ) list * loc 
  | (*%
     * @format(funbind funbinds * loc) !N0{ "functor" + {funbinds(funbind)(~4[ +1 "and"] +)} }
     * @format:funbind(funid * strid * sigexp * strexp * loc) 
		      funid + "(" strid + sigexp +")" + "=" +1 strexp
     *)
    PTTOPDECFUN of (string * string * ptsigexp  * ptstrexp * loc) list * loc
  | (*%
     * @format (spec * loc)
     * !N0{ "import" + spec }
     *) 
    PTTOPDECIMPORT of ptspec * loc 


 fun getLocExp ptexp =
     case ptexp of
     PTCONSTANT(_, loc) => loc
   | PTVAR(_, loc) => loc
   | PTTYPED(_, _, loc) => loc
   | PTAPPM(_, _, loc) => loc
   | PTLET(_, _, loc) => loc
   | PTRECORD(_, loc) => loc
   | PTRECORD_UPDATE(_, _, loc) => loc
   | PTTUPLE(_, loc) => loc
   | PTRAISE(_, loc) => loc
   | PTHANDLE(_, _, loc) => loc
   | PTFNM(_, _, loc) => loc
   | PTFNM1(_, _, _, loc) => loc
   | PTCASEM(_, _, _, loc) => loc
   | PTRECORD_SELECTOR(_, loc) => loc
   | PTSELECT(_, _, loc) => loc
   | PTSEQ(_, loc) => loc
   | PTCAST(_, loc) => loc

 fun getLocDec ptdecl =
     case ptdecl of
     PTVAL(_, _, _, loc) => loc
   | PTDECFUN (_,_, _,loc) => loc
   | PTNONRECFUN (_,_, _,loc) => loc
   | PTVALREC(_, _, _, loc) => loc
   | PTVALRECGROUP (_, _, loc) => loc
   | PTTYPE(_, loc) => loc
   | PTDATATYPE(_, loc) => loc
   | PTREPLICATEDAT(_, _, loc) => loc
   | PTABSTYPE(_, _, loc) => loc
   | PTEXD(_, loc) => loc
   | PTOPEN(_, loc) => loc
   | PTLOCALDEC(_, _, loc) => loc
   | PTINFIXDEC (_, _, loc) => loc
   | PTINFIXRDEC (_, _, loc) => loc
   | PTNONFIXDEC (_, loc) => loc
   | PTFFIVAL {loc,...} => loc
   | PTEMPTY => Loc.noloc

 fun getLocPat ptpat =
     case ptpat of
       PTPATWILD loc => loc
     | PTPATID (_, loc) => loc
     | PTPATCONSTANT (_, loc) => loc
     | PTPATCONSTRUCT (_, _, loc) => loc
     | PTPATRECORD (_, _, loc) => loc
     | PTPATLAYERED (_, _, _, loc) => loc
     | PTPATTYPED (_, _, loc) => loc

  val emptyTvarNameSet = SEnv.empty : tvarNameSet

end
