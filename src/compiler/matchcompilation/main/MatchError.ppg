(**
 * errors generated by match compiler.
 * @author OSAKA Satoshi
 * @version $Id: MatchError.ppg,v 1.6 2007/02/11 16:39:51 kiyoshiy Exp $
 *)
structure MatchError = 
struct
  open TypedFlatCalc RecordCalc
  structure BF = SMLFormat.BasicFormatters
  structure C = Control
  structure CT = ConstantTerm
  structure IT = InitialTypeContext
  structure MD = MatchData
  structure PT = PredefinedTypes
  structure T = Types
  structure UE = UserError

  fun format_flag x = 
      if !x = 0
      then [SMLFormat.FormatExpression.Term(9,"   -->   ")]
      else [SMLFormat.FormatExpression.Term(9,"         ")]

  (*%
   * @formatter(pat) untypedformat_tfppat
   * @formatter(flag) format_flag
   *)
  type rule
  = (*%
     * @format((pat pats* exp) * flag)
     *          flag:flag 9[{pats(pat:pat)(","+1)} + "=>" + "..."]
     *)
    (tfppat list * tfpexp) * int ref

  local
    val format_rule' = format_rule
  in
  (*%
   * @formatter(rule) format_rule'
   *)
  exception
  (*%
   * @format(message * rule rules) message +1 rules(rule)(+1)
   *)
  MatchError of string * rule list
  end

  val bindRedundantMessage = "binding redundant"
  val bindNotExhaustiveMessage = "binding not exhaustive"
  val bindBothMessage = "binding redundant and not exhaustive"
  val matchRedundantMessage = "match redundant"
  val matchNotExhaustiveMessage = "match nonexhaustive"
  val matchBothMessage = "match redundant and nonexhaustive"

  fun raiseBindFailExp resultTy loc = 
      RCRAISE(RCCONSTRUCT{con=T.conPathInfoToConInfo PT.BindCon, instTyList=nil, argExpOpt=NONE, loc=loc}, resultTy, loc)
  fun raiseMatchFailExp resultTy loc = 
      RCRAISE(RCCONSTRUCT{con=T.conPathInfoToConInfo PT.MatchCon, instTyList=nil, argExpOpt=NONE, loc=loc}, resultTy, loc)
  fun handleFail v resultTy loc = RCRAISE (RCVAR (v, loc), resultTy, loc)

  fun raiseMatchCompBugExp resultTy loc = 
      RCRAISE
      (
        RCCONSTRUCT
        {
          con=T.conPathInfoToConInfo PT.MatchCompBugCon,
	  instTyList=nil, 
	  argExpOpt=SOME (RCCONSTANT (CT.STRING "MATCHCOMPILERBUG", loc)),
          loc=loc
        },
        resultTy,
        loc
      )
(*
      RCRAISE (RCCONSTANT (T.STRING "MATCHCOMPILERBUG"))
*)
  datatype flagKind = Redundant | NotExhaustive
  local
    val errorMessages = ref [] : UE.errorInfo list ref
    val redundantFlag = ref false
    val notExhaustiveFlag = ref false
  in
    fun clearErrorMessages () = errorMessages := []
    fun putErrorMessage (loc, kind, message, rules) =
        errorMessages :=
        (loc, kind, MatchError (message, rules)) :: (! errorMessages)
    fun getErrorMessages () = ! errorMessages
    fun clearFlag Redundant = redundantFlag := false
      | clearFlag NotExhaustive = notExhaustiveFlag := false
    fun setFlag Redundant = redundantFlag := true
      | setFlag NotExhaustive = notExhaustiveFlag := true
    fun isRedundant () = ! redundantFlag
    fun isNotExhaustive () = ! notExhaustiveFlag
  end

  fun haveRedundantRules [] = false
    | haveRedundantRules ((_, flag) :: rules) =
      if !flag then true
      else haveRedundantRules rules

  val print = C.prettyPrint

  fun insertNewline messages =
      let
	fun insert [] = []
	  | insert [message] = [message]
	  | insert (message :: messages) = message :: "\n" :: insert messages
      in
	concat (insert messages)
      end

  fun checkError (MD.Handle v, true, _, rules, loc ) = 
      putErrorMessage (loc, UE.Error, matchRedundantMessage, rules)
    | checkError (MD.Bind, true, true, rules, loc) = 
      putErrorMessage (loc, UE.Error, bindBothMessage, rules)
    | checkError (MD.Bind, true, false, rules, loc) = 
      putErrorMessage (loc, UE.Error, bindRedundantMessage, rules)
    | checkError (MD.Bind, false, true, rules, loc) = 
      putErrorMessage (loc, UE.Warning, bindNotExhaustiveMessage, rules)
    | checkError (MD.Match, true, true, rules, loc) = 
      putErrorMessage (loc, UE.Error, matchBothMessage, rules)
    | checkError (MD.Match, true, false, rules, loc) = 
      putErrorMessage (loc, UE.Error, matchRedundantMessage, rules)
    | checkError (MD.Match, false, true, rules, loc) = 
      putErrorMessage (loc, UE.Warning, matchNotExhaustiveMessage, rules)
    | checkError _ = ()
end
