(**
 This module generates printer code.

<h3>Printer code generation</h3>
<p>
 Interactive SML system responds to user input by printing its evaluated value.
<pre>
  - 1 + 1;
  val it = 2 : int;
</pre>
 The IML system should implement this feature.
 The strategy described in this document is that the compiler generates an
additional code which will be executed after the user code when user inputs a
code:
<ol>
   <li> For a type or datatype declaratioin, the compiler add a binding of a 
     function which translates a value of a type which is constructed from the
     declared type constructor into its string representation.</li>
   <li> For a global variable declaration, the compiler generates a code that
     may invoke printers which the compiler generated for type constructors 
     occurred in the type of the variable.</li>
</ol>
</p>
<h4>Example</h4>
<p>
Assume user inputs an expression of the int type:
<pre>
  - 1 + 1;
</pre>
The compiler appends additional codes as follows.
(These are internal representations in the compiler, not proper SML code.)
<pre>
  setGlobal it = 1 + 1;
  print ("val it = ");
  printFormat format_int it;
  print (" : int;");
</pre>
When user inputs a datatype declaration,
<pre>
  - datatype 'a tree = Leaf of 'a | Node of ('a tree * 'a tree)
</pre>
the compiler generates a formatter function which translates a tree value into
 a text (or an intermediate representation for formatting).
<pre>
  setGlobal fun format_tree print_'a x = 
                case x of 
                  Leaf x => (["Leaf "] @ format_'a x)
                | Node x => 
                    (["Node"] @
                     (format_tuple
                      (print_tree print_'a)
                      (print_tree print_'a)
                      x))
</pre>
This formatter takes as its parameter another formatter, which is used to 
format values of types which is bound to the type variable 'a.
</p>
<p>
 And this formatter function is used in codes generated by the compiler for 
global declarations of the tree type (and the types which contain the tree
 type as its sub type expression).
<pre>
  - val t = Leaf 1

  setGlobal t = Leaf 1
  print "val t = ";
  printFormat format_tree format_int t;
  print " : int tree";
</pre>
</p>

<h4>
visibility of type constructors
</h4>
<p>
 Assume user inputs the following code:
<pre>
    local datatype t = D in val x = D end
</pre>
The type constructor 't' is not visible outside the local declaration. It is
 hidden.
Hidden type constructors are:
<ul>
  <li>type constructor declared in let expression</li>
  <li>type constructor declared in local expression</li>
  <li>type constructor declared in abstype declaration</li>
  <li>type constructor declared in a structure opaque constrainted by a
    signature</li>
  <li>type constructor hidden by another constructor defined with the same 
    name</li>
</ul>
What should formatter print as textual representation of the value of 'x' ?
</p>
<p>
 The SML/NJ compiler prints the internal structure of the value of 'x'.
<pre>
  - local datatype t = D in val x = D end;
  val x = D : ?.t
</pre>
But, does this behavior conform to user's intention ?
The compiler should hide entities which user intends to hide. 
In fact, the SML/NJ does not expose the internal structure of values of other
types hidden by 'abstype' and signature constraint.
<pre>
  - abstype t = D with val x = D end;
  type t
  val x = - : t

  - signature S = sig type t val x : t end;
  signature S =
    sig
      type t
      val x : t
    end
  - structure S :> S = struct datatype t = D val x = D end;
  structure S : S
  - S.x;
  val it = - : S.t
</pre>
 The IML compiler treats all these hidden types uniformly in formatting 
(constructors hidden by opaque constraint are treated in slightly different 
way.)
Values of hidden types are not printed.
For example,
<pre>
  datatype t = D1
  datatype t = D2
  val x = D1
</pre>
The IML compiler prints in response to the last declaration as follows.
<pre>
  val x = - : -
</pre>
For hidden type constructors, the predefined formatter 'format_hidden' is 
selected.
<pre>
  fun format_hidden x = "-"
</pre>
Formatter functions are generated at each datatype declaration.
<pre>
  datatype t = D1
  fun format_t x = case x of D1 => "D1"
  datatype t = D2
  fun format_t x = case x of D2 => "D2"
</pre>
At generating formatting expression for a global binding, if a hidden type 
constructor is used, 'format_hidden' is used, instead of the formatter 
generated for the type constructor.
<pre>
  val x = D1 : t
  print "val x = "
  printFormat format_hidden x
  print ": -"
</pre>
(IMPLEMENTATION NOTE:if a type constructor 't' is not included in tyConEnv, 
it is hidden.)
</p>
<p>
And, types declared in a structure which is opaque constrainted by a signature.
The generator inserts a specification of formatters into signature which user 
inputs.
</p>
<p>
 The generator modifies a signature input by user
<pre>
  signature S = sig type t val x : t end;
</pre>
into the following.
<pre>
  signature S =
    sig
      type t
      val format_t : t -> string
      val x : t
    end
</pre>
And, the generator inserts formatter function into structures.
From:
<pre>
  structure S = struct datatype t = D val x = D end;
</pre>
to:
<pre>
  structure S = 
  struct datatype t = D fun format_t x = case x of D => "D" val x = D end;
</pre>
When structure is constrainted by signature opaquely, 'format_opaque' is used.
Otherwise, the generated formatter is used.
For example,
<pre>
  structure S1 : S = S
  val x = S1.x

  structure S2 :> S = S
  val x = S2.x
</pre>
is translated into:
<pre>
  structure S1 : S = S
  val x = S1.x
  print "val x = "
  printFormat S1.format_t x
  print " : S1.t"

  structure S2 :> S = S
  val x = S2.x
  print "val x = "
  printFormat format_opaque x
  print " : S2.t"
</pre>
</p>

<h4>
Formatter for polymorphic type
</h4>
<p>
 In SML, global variables of polymorphic type can be declared.
For example, assume the following datatype is declared,
<pre>
  - datatype 'a list = Nil | Cons of 'a * 'a list
</pre>
and its formatter is generated.
<pre>
  setGlobal fun format_list format_'a = ..
</pre>
Then, user can declare a global variable of polymorphic type as follows:
<pre>
  - val null = Nil
</pre>
This "null" has a type "'X list" for a type variable 'X.
For this declaration, the compiler generates the following code:
<pre>
  setGlobal null = Nil
  printFormat (format_list format_unknown null)
</pre>
The format_unknown function raises an exception always when called.
Normally, this format_unknown is never called in the format_list.
</p>
<p>
There is an rare case 
<pre>
  fun loop x = loop x
  val y = loop 1
</pre>
The following code is generated to print the value of 'y'.
<pre>
  print "val y = "
  printFormat format_unknown y
  print " : 'b"
</pre>
The 'loop' has the type 'a -> 'b, and 'loop 1' has a type 'b. 
The format_unknown will be called when the value of 'y' is printed. In this 
case, 'format_unknown' should not raise exception because the source code 
does not contain any error, but what to be printed ?
The answer is that the formatter is not invoked because evaluation of 'loop 1'
 will not stop.
</p>

<hr>
<h3>
formatter generation for exceptions
</h3>
<p>
 When an raised exception is not caught by any handler, the SML/NJ prints the
 constructor name of it, but does not print the whole inner structure. This is
 inconvenient in order to determine the reason of the error.
<pre>
  - exception Error of string;
  exception Error of string
  - val x = raise Error "foo";
  uncaught exception Error
  raised at: stdIn:20.15-20.26
</pre>
The argument "foo" of Error is not printed.
And the implementation of 'exnMessage' in SML/NJ does not print helpful 
message.
(Does the SML/NJ provide any way to customize this behavior ?)
</p>
<p>
 It would be useful to apply the formatter generation to this exception 
printing.
But there are two issues.
</p>

<h4>
Incremental extension of formatter function
</h4>
<p>
 Because 'exn' is extensible, it is impossible to define a single formatter
function which processes every exception.
So, the formatter should be extended, accompanying extension of exception 
constructor.
</p>
<p>
 First, define the initial formatter. This aborts anytime if called. It will 
not be invoked unless compiler has a bug.
In order to handle exception constructor declared in structure, declare a 
reference to a formatter as a global variable.
<pre>
  val format_exnRef = ref (fn x : exn => "compiler bug!")
</pre>
and updates it at each exception declaration to handle the new exception 
constructor.
<pre>
  (* user code *)
  exception Error of string;

  (* generated code *)
  let
    val prev_formatter = !format_exnRef
    fun format_exn x =
        case x of
          Error message => "Error " ^ message
        | other => prev_formatter other
  in
    format_exnRef := format_exn
  end
</pre>
</p>
<p>
 The strategy can handle exceptions declared in structures, such as:
<pre>
  structure S =
  struct
    exception Error of string
  end
</pre>
And this makes it to be able to handle hidden exception constructors, such as:
<pre>
  local exception Error of string
  in val x = raise Error "error" end
</pre>
NOTE: The format_exn must be defined recursively to handle exceptions such as 
the following,
<pre>
  exception of CapsuledException of exn
</pre>
and also must be able to call previously defined format_exn.
</p>

<h4>
Handler for declaration
</h4>
<p>
 The compiler regards the program as a sequence of declarations.
Assume a declaration:
<pre>
 val x = raise Error "error"
</pre>
 When the runtime executes this declaration, the valid behavior is not only 
that the evaluation of bound expression aborts, but also that any global 
binding 'x' should not be created.
</p>
<p>
 The exception printing should not distort this behavior.
So, the above declaration is translated into:
<pre>
  val x = (raise Error "error")
          handle
            e =>
              (
                print "uncaught exception ";
                printFormat format_exn e;
                raise e
              )
</pre>
The raised exception is re-raised, which aborts global binding of 'x'.
</p>

<hr>
<h3>
Implementation
</h3>
<p>
 The frontend passes source program from phase to phase in the following order:
<pre>
       user program
  1,parse
       Absyn (parser/absyn.ppg)
  2,elaborate
       PatternExpr (patterncalc/patterncalc.ppg)
  3,type inference
       TypedPL (typedcalc/typedcalc.ppg)
  4,pattern match compile
         :
</pre>
 The FormatterGenerator generates formatter code in TypedPL form and passes 
it to the pattern match compiler.
It would be easier to generate the Absyn code, not the TypedPL code, and pass 
it to the elaborator. 
</p>

<p>
The generator generates the two types of SML codes:
<ul>
  <li>definition of a formatter function for a type constructor</li>
  <li>expressions to print values bound to global variables</li>
</ul>
</p>
<p>
 For a type constructor defined by datatype declaration, it is necessary to 
define a formatter function which can traverse recursive data structure of the 
type,because the type constructor can be declared recursively like list.
</p>

<h4>
generating formatter function declaration
</h4>

<p>
 <code>E</code> is a formatter environment which maps a type constructor ID to 
a formatter ID.
</p>
<p>
The algorithm '<code>F</code>' generates formatter function code.
<pre>
F E (TYVARty(ref SUBSTITUTED ty)) = F ty
F E (TYVARty(ref TVAR tvKind)) = [fn x => raise Fail]
F E (BOUNDVARty(index)) = [fn x => raise Fail]
F E (FUNty(ty1, ty2)) = [fn x => "fn"]
F E (IABSty(_, ty)) = error
F E (RECORDty {l1:ty1, ..., ln:tyn}) =
    let val f1 = F E t1 ... val fn = F E tn
    in
      if isTupleTy {l1, ..., ln}
      then [fn x => "(" ^ (f1 (#1 x)) ^ "," ^ ... ^ "," ^ (fn (#n x)) ^ ")"]
      else
        [fn x =>
         "{" ^
            l1 ^ " = " ^ (f1 (#l1 x)) ^ "," ^ 
            ... ^ "," ^
            ln ^ " = " ^ (fn (#ln x)) ^
         "}"]
    end
F E (CONty{tyCon, {ty1, ..., tyn}}) =
    let val f = E tyCon val {f1, ..., fn} = {F E ty1, ..., F E tyn} 
    in [f f1 ... fn] end
F E (POLYty{{btv1, ..., btvn}, body}) = F E body
F E (DUMMYty) = error
F E (BOXEDty) = error
F E (ATOMty) = error
F E (INDEXty _) = error
F E (BMABSty (_, ty)) = error
F E (BITMAPty _) = error
</pre>
Beacuse IABSty and from BOXEDty to BITMAPty is generated by the record compile 
which follows the typeinference, 'F' does not expect IASBty.
The body of POLYty must be FUNty.
</p>
<p>
Algorithm '<code>G</code>' generates printing code for global binding.
<pre>
G E [x] ty = let val f = F E ty in [print f x] end
</pre>
</p>

 * @author YAMATODANI Kiyoshi
 * @author UENO Katsuhiro
 * @version $Id: PrinterGenerator.sml,v 1.164 2006/02/09 10:24:28 ohori Exp $
 *)
structure PrinterGenerator : PRINTER_GENERATOR =
struct

  (***************************************************************************)

  structure A = Absyn
  structure BF = SMLFormat.BasicFormatters
  structure FE = SMLFormat.FormatExpression
  structure IT = InitialTypeContext
  structure P = Path
  structure PE = PatternCalc
  structure SE = StaticEnv
  structure TC = TypeContext
  structure TP = TypedCalc
  structure TPU = TypedCalcUtils
  structure TU = TypesUtils
  structure TCU = TypeContextUtils
  structure TY = Types

  structure U = Utility
  structure FG = FormatterGenerator
  structure PG = PrintCodeGenerator
  structure OC = ObjectCode

  (**
   * This context stores information to judge whether generation of cathc-all
   * handler and generation of printer code of binding information are
   * required or not.
   * <p>
   * A val binding cab be declared at global top level, at top level in
   * a structure, or other.
   * As shown in the following table, whether the printer generator should
   * generate additional code for a val binding or not is decided according
   * to position of the val binding.
   * <pre>
   *                     |local|catch all handler| print bind |
   * --------------------+-----+-----------------+------------+
   *      top level      |  n  |     yes         | printBinds |
   *                     |  y  |     yes         |    no      |
   * --------------------+-----+-----------------+------------+
   * structure top level |  n  |     yes         |    no      |
   *                     |  y  |     yes         |    no      |
   * --------------------+-----+-----------------+------------+
   *    non top level    |     |     no          |    no      |
   * --------------------+-----+-----------------+------------+
   * </pre>
   * Here, <code>printBinds</code> is a boolean parameter passed to the
   * generate function of the PrinterGenerator.
   * </p>
   * <p>
   * Example.
   * <pre>
   *   local
   *     val glt = exp
   *     structure LS = struct val st = exp end
   *   in
   *   val gt = let
   *               val nt = exp
   *            in exp end
   *   end;
   *   structure S =
   *   struct
   *     val st = exp
   *   end
   * </pre>
   * In this code, <code>gt</code> is at global top level, <code>st</code> is
   * structure top level, and <code>nt</code> is at non top level.
   * Into this code, the printer generator inserts additional code as follows.
   * <pre>
   *   local
   *     val glt = exp handle exn => (printExn exn; ...)
   *     structure LS =
   *     struct val st = exp handle exn => (printExn exn; ...) end
   *   in
   *   val gt = let
   *               val nt = exp
   *            in exp end
   *            handle exn => (printExn exn; ...)
   *   val _ = print "val g = " ^ format_t gt ^ " : t"
   *   end;
   *   structure S =
   *   struct
   *     val st = exp
   *              handle exn => (printExn exn; ...);
   *   end
   * </pre>
   *)
  structure PositionContext =
  struct
  
    datatype position = Top | StructureTop | NonTop

    type context = {printBind : bool, position : position, isLocal : bool}

    fun create printBind =
        {printBind = printBind, position = Top, isLocal = false}

    fun enterStructure {printBind, position = NonTop, isLocal} =
        raise Control.Bug "PositionContext.enterStructure"
      | enterStructure {printBind, position, isLocal} =
        {printBind = printBind, position = StructureTop, isLocal = isLocal}

    fun enterLocal {printBind, position, isLocal} =
        {printBind = printBind, position = position, isLocal = true}

    fun enterNonTop {printBind, position, isLocal} =
        {printBind = printBind, position = NonTop, isLocal = isLocal}

    fun isPrintBinds {printBind, position = Top, isLocal = false} = printBind
      | isPrintBinds {printBind, position, isLocal} = false

    fun isCatchAllHandlerGenerate {printBind, position = NonTop, isLocal} =
        false
      | isCatchAllHandlerGenerate {printBind, position, isLocal} = true

    fun getPosition ({position, ...} : context) = position

  end
  structure PC = PositionContext

  (***************************************************************************)

  type context = TC.context

  (***************************************************************************)

  local
    fun formatterVarInfoOfTyBindInfo tyBindName tyBindInfo =
        let
          val monoFormatterTy =
              case tyBindInfo of
                TY.TYCON tyCon => OC.formatterOfTyConTy tyCon
              | TY.TYFUN tyFun => OC.formatterOfTyFunTy tyFun
              | TY.TYSPEC {spec = tySpec,...} => OC.formatterOfTySpecTy tySpec
          val formatterName = U.formatterNameOfTyName tyBindName
          val formatterTy = U.generalize monoFormatterTy
          val formatterVarInfo = {name = formatterName, ty = formatterTy}
        in
          formatterVarInfo
        end
  in
  fun insertFormatterIntoEnv ((tyConEnv, varEnv, strEnv) : TY.Env) =
      let
        fun bindFormatterOfBindInfo (name, tyBindInfo, newVarEnv) =
            let
              val varInfo = formatterVarInfoOfTyBindInfo name tyBindInfo
              val varPathInfo = U.varInfoToVarPathInfo varInfo
            in
              SEnv.insert (newVarEnv, #name varInfo, TY.VARID(varPathInfo))
            end
        val newVarEnv = SEnv.foldli bindFormatterOfBindInfo varEnv tyConEnv

        fun insertToStructure (TY.STRUCTURE{name, id, strpath, env, ...}) =
            let val newEnv = insertFormatterIntoEnv env
            in
              TY.STRUCTURE
                  {name = name, id = id, strpath = strpath, env = newEnv}
            end
        val newStrEnv = SEnv.map insertToStructure strEnv
      in
        (tyConEnv, newVarEnv, newStrEnv)
      end
  end

  fun replaceTySpecToTyConInEnv ((tyConEnv, varEnv, strEnv) : TY.Env) =
      let
        fun replaceTyBindInfo (TY.TYSPEC {spec = tySpec,...}) =
            TY.TYCON(U.tySpecToTyCon tySpec)
          | replaceTyBindInfo tyBindInfo = tyBindInfo
        val newTyConEnv = SEnv.map replaceTyBindInfo tyConEnv
        fun replaceInStructure (TY.STRUCTURE{name, id, strpath, env}) =
            let val newEnv = replaceTySpecToTyConInEnv env
            in
              TY.STRUCTURE
                  {name = name, id = id, strpath = strpath, env = newEnv}
            end
        val newStrEnv = SEnv.map replaceInStructure strEnv
      in (newTyConEnv, varEnv, newStrEnv)
      end

  (**
   * indicates whether evaluation of an expression can raise any exception.
   * If an expression "e" is safe, it is unnecessary to wrap it in catch all
   * handler.
   *)
  fun isSafeExpression exp =
      case exp of
        TP.TPCONSTANT _ => true
      | TP.TPVAR _ => true
      | TP.TPCONSTRUCT {argExpOpt=NONE, ...} => true
      | TP.TPCONSTRUCT {argExpOpt=SOME exp, ...} => isSafeExpression exp
      | TP.TPMONOLET {binds=binds, bodyExp=body, loc=loc} =>
        (List.all (fn (_, exp) => isSafeExpression exp) binds)
        andalso (isSafeExpression body)
      | TP.TPLET (decs, exps, _, _) =>
        (List.all isSafeDeclaration decs)
        andalso (List.all isSafeExpression exps)
      | TP.TPRECORD {fields, ...} =>
        List.all isSafeExpression (SEnv.listItems fields)
      | TP.TPSELECT {exp=recordExp, ...} => isSafeExpression recordExp
      | TP.TPMODIFY {recordExp = exp1, elementExp = exp2, ...} =>
        isSafeExpression exp1 andalso isSafeExpression exp2
      | TP.TPHANDLE {exp=bodyExp, handler=handlerExp, ...} =>
        (isSafeExpression bodyExp) andalso (isSafeExpression handlerExp)
      | TP.TPFNM _ => true
      | TP.TPPOLYFNM _ => true
      | TP.TPPOLY {exp, ...} => isSafeExpression exp
      | TP.TPTAPP {exp, ...} => isSafeExpression exp
      | TP.TPSEQ {expList=exps, ...} => List.all isSafeExpression exps
      | _ => false

  and isSafeDeclaration dec =
      case dec of
        TP.TPVAL (binds, _) =>
        List.all (fn (_, exp) => isSafeExpression exp) binds
      | TP.TPVALREC (binds, _) =>
        List.all (fn {exp,...} => isSafeExpression exp) binds
      | TP.TPVALPOLYREC (_, binds, _) =>
        List.all (fn {exp,...} => isSafeExpression exp) binds
      | TP.TPVALRECGROUP (_, decls, _) => List.all isSafeDeclaration decls
      | TP.TPLOCALDEC (locals, globals, _) =>
        (List.all isSafeDeclaration locals)
        andalso (List.all isSafeDeclaration globals)
      | _ => true

  fun generateCatchAllHandler context path (exp, ty) =
      if isSafeExpression exp
      then exp
      else
        (* exp
         * handle e => (print (format_exn e); print "\n"; raise e)
         *)
        let
          val loc = TPU.getLocOfExp exp
          val exnVarName = U.makeVarName ()
          val exnVarInfo = {name = exnVarName, ty = OC.exnTy}
          val exnVarPathInfo = U.varInfoToVarPathInfo exnVarInfo
          val exnFormatterExp =
              FG.generateFormatterOfTy context path [] [] loc OC.exnTy
          val exnFormatterTy = OC.formatterOfTyTy OC.exnTy
          val handlerBodyExp =
              TP.TPSEQ
              {
                expList =
                [
                  OC.printFormat
                      (TP.TPAPPM
                           {
                             funExp = exnFormatterExp,
                             funTy = exnFormatterTy,
                             argExpList = [TP.TPVAR (exnVarPathInfo, loc)],
                             loc = loc
                           }),
                  OC.printString(TP.TPCONSTANT(TY.STRING("\n"), loc)),
                  TP.TPRAISE(TP.TPVAR (exnVarPathInfo, loc), ty, loc)
                ],
                expTyList = [OC.unitTy, OC.unitTy, ty],
                loc = loc
              }
        in
          TP.TPHANDLE
              {
                exp = exp,
                exnVar = exnVarPathInfo,
                handler = handlerBodyExp,
                loc = loc
              }
        end

  (***************************************************************************)

  fun visitSequential visitElement baseContext path positionCTX declarations =
      let
        (* modifiedDeclarations is in reverse order. *)
        val (newContext, modifiedDeclarationsLists) = 
            foldl
                (fn (declaration, (context, extendedDeclarationsLists)) =>
                    let
                      val newBaseContext =
                          U.unionContexts [baseContext, context]
                      val (newContext, newDeclarations) =
                          visitElement
                              newBaseContext path positionCTX declaration
                    in
                      (
                        U.unionContexts [context, newContext],
                        newDeclarations :: extendedDeclarationsLists
                      )
                    end)
                (TC.emptyContext, [])
                declarations
      in
        (newContext, List.concat(List.rev modifiedDeclarationsLists))
      end

  fun visitExp context path positionCTX exp =
      let fun visit exp = visitExp context path positionCTX exp
      in
        case exp of
          TP.TPPRIMAPPLY {primOp, instTyList, argExpOpt = SOME argExp, loc} =>
          TP.TPPRIMAPPLY
              {
                primOp = primOp,
                instTyList = instTyList,
                argExpOpt = SOME(visit argExp),
                loc = loc
              }
        | TP.TPCONSTRUCT {con, instTyList, argExpOpt = SOME argExp, loc} =>
          TP.TPCONSTRUCT
              {
                con = con,
                instTyList = instTyList,
                argExpOpt = SOME(visit argExp),
                loc = loc
              }
        | TP.TPAPPM {funExp, funTy, argExpList, loc} =>
          TP.TPAPPM
              {
                funExp = visit funExp,
                funTy = funTy, 
                argExpList = map visit argExpList, 
                loc = loc
              }
        | TP.TPMONOLET {binds, bodyExp, loc} =>
          let
            fun visitBind (varInfo, exp) = (varInfo, visit exp)
            val newBinds = map visitBind binds
            val newBodyExp = visit bodyExp
          in
            TP.TPMONOLET {binds = newBinds, bodyExp = newBodyExp, loc = loc}
          end
        | TP.TPLET(decs, exps, tys, loc) =>
          let val newDecs = #2(visitDecs context path positionCTX decs)
          in TP.TPLET(newDecs, map visit exps, tys, loc)
          end
        | TP.TPRECORD {fields, recordTy, loc} =>
          TP.TPRECORD
              {fields = SEnv.map visit fields, recordTy = recordTy, loc=loc}
        | TP.TPSELECT {label, exp, expTy, loc} =>
          TP.TPSELECT
              {label = label, exp = visit exp, expTy =  expTy, loc = loc}
        | TP.TPMODIFY
              {label, recordExp, recordTy, elementExp, elementTy, loc} =>
          TP.TPMODIFY
              {
                label = label, 
                recordExp = visit recordExp, 
                recordTy = recordTy, 
                elementExp = visit elementExp,
                elementTy = elementTy,
                loc = loc
              }
        | TP.TPRAISE (exp, ty, loc) => TP.TPRAISE(visit exp, ty, loc)
        | TP.TPHANDLE {exp, exnVar, handler, loc} =>
          let
            val newExp = visit exp
            val newHandler = visit handler
          in
            TP.TPHANDLE
               {exp = newExp, exnVar = exnVar, handler = newHandler, loc = loc}
          end
        | TP.TPCASEM
              {expList, expTyList, ruleList, ruleBodyTy, caseKind, loc} =>
          TP.TPCASEM
          {
            expList = map visit expList,
            expTyList = expTyList,
            ruleList =
            map (fn (patList, exp) => (patList, visit exp)) ruleList,
            ruleBodyTy = ruleBodyTy,
            caseKind = caseKind,
            loc = loc
          }
        | TP.TPFNM {argVarList, bodyTy, bodyExp, loc} =>
          TP.TPFNM
              {
                argVarList = argVarList,
                bodyTy = bodyTy,
                bodyExp = visit bodyExp,
                loc = loc
              }
        | TP.TPPOLYFNM {btvEnv, argVarList, bodyTy, bodyExp, loc} =>
          TP.TPPOLYFNM
              {
                btvEnv = btvEnv, 
                argVarList = argVarList,
                bodyTy = bodyTy,
                bodyExp = visit bodyExp, 
                loc = loc
              }
        | TP.TPPOLY {btvEnv, expTyWithoutTAbs, exp, loc} =>
          TP.TPPOLY
              {
                btvEnv = btvEnv,
                expTyWithoutTAbs = expTyWithoutTAbs,
                exp = visit exp,
                loc = loc
              } 
        | TP.TPTAPP {exp, expTy, instTyList, loc} => 
          TP.TPTAPP
              {
                exp = visit exp,
                expTy = expTy,
                instTyList = instTyList,
                loc = loc
              }
        | TP.TPSEQ {expList, expTyList, loc} => 
          TP.TPSEQ
              {expList = map visit expList, expTyList = expTyList, loc = loc}
        | exp => exp
      end
      
  and visitDecs context path positionCTX declarations =
      visitSequential visitDec context path positionCTX declarations

  and visitValBinds context path positionCTX loc binds =
      let
        fun isNamedBind (TY.VALIDVAR _, _) = true
          | isNamedBind (TY.VALIDWILD _, _) = false
        val namedBinds = List.filter isNamedBind binds

        val newBinds = 
            map
                (fn (valID, exp) =>
                    (
                      valID,
                      visitExp context path (PC.enterNonTop positionCTX) exp
                    ))
                binds
        fun getTyOfValID (TY.VALIDVAR varInfo) = #ty varInfo
          | getTyOfValID (TY.VALIDWILD ty) = ty
        fun makeHandledBind(valID, exp) =
            (
              valID,
              generateCatchAllHandler context path (exp, getTyOfValID valID)
            )
        val handledBinds =
            if PC.isCatchAllHandlerGenerate positionCTX
            then map makeHandledBind newBinds
            else newBinds

        fun bindVarBind ((TY.VALIDVAR varInfo, _), newContext) =
            let
              val varName = #name varInfo
              val idState = TY.VARID(U.varInfoToVarPathInfo varInfo)
            in TC.bindVarInContext (newContext, varName, idState)
            end
        val bindContext = foldl bindVarBind TC.emptyContext namedBinds

        fun getVarInfoOfValID (TY.VALIDVAR varInfo, _) = varInfo
        val printCodesMap =
            if PC.isPrintBinds positionCTX
            then
              let val varInfos = map getVarInfoOfValID namedBinds
              in PG.generatePrintCodeForVals context path loc varInfos
              end
            else SEnv.empty
      in
        (bindContext, handledBinds, printCodesMap)
      end

  (** This function is defined in order to share code for val declarations.
   * The only thing this function does is to translate varinfo/valid.
   *)
  and visitValDec context path positionCTX valDeclaration =
      case valDeclaration of
        TP.TPVAL (binds, loc) =>
        let
          val (context, handledBinds, printCodesMap) =
              visitValBinds context path positionCTX loc binds
        in
          (context, [TP.TPVAL(handledBinds, loc)], printCodesMap)
        end
      | TP.TPVALREC (binds, loc) =>
        let
          val valIDBinds =
              map (fn {var=varInfo, expTy=ty, exp} => (TY.VALIDVAR varInfo, exp)) binds
          val (context, handledValIDBinds, printCodesMap) =
              visitValBinds context path positionCTX loc valIDBinds
          val handledBinds =
              map
              (fn (TY.VALIDVAR varInfo, exp) => {var=varInfo, expTy = #ty varInfo, exp=exp})
              handledValIDBinds
        in
          (context, [TP.TPVALREC(handledBinds, loc)], printCodesMap)
        end
      | TP.TPVALPOLYREC(btvMap, binds, loc) =>
        let
          (* each ty in varInfo in binds should be wraped in POLY when
           * generating printer codes. *)
          fun toPoly {name, ty} =
              {name = name, ty = TY.POLYty{boundtvars = btvMap, body = ty}}
          fun toMono {name, ty = TY.POLYty{body = ty, ...}} =
              {name = name, ty = ty}

          val valIDBinds =
              map
                  (fn {var=varInfo, expTy=ty, exp} => (TY.VALIDVAR(toPoly varInfo), exp))
                  binds
          val (context, handledValIDBinds, printCodesMap) =
              visitValBinds context path positionCTX loc valIDBinds
          val handledBinds =
              map
                  (fn (TY.VALIDVAR varInfo, exp) =>
                      let val newVarInfo = toMono varInfo
                      in {var=newVarInfo, expTy = #ty newVarInfo, exp=exp} end)
                  handledValIDBinds
        in
          (
            context,
            [TP.TPVALPOLYREC(btvMap, handledBinds, loc)],
            printCodesMap
          )
        end
      | TP.TPLOCALDEC(localDecs, globalDecs, loc) =>
        (* For optimization, the type inferencer generates 'local' declaration
         * in VALRECGROUP.
         *)
        let
          val (localContext, newLocalDecs) = 
              visitDecs context path (PC.enterLocal positionCTX) localDecs
          val newLocalContext = U.unionContexts [context, localContext]
          fun visit context path position dec =
              let
                val (newContext, newDec, printCodesMap) =
                    visitValDec context path position dec
              in (newContext, ([(newDec, printCodesMap)]))
              end
          val (newContext, newGlobalDecAndMaps) =
              visitSequential visit newLocalContext path positionCTX globalDecs
          val (newGlobalDecs, printCodesMap) =
              List.foldl
                  (fn ((decs, map), (globalDecs, printCodesMap)) =>
                      (
                        globalDecs @ decs,
                        SEnv.unionWith #1 (map, printCodesMap)
                      ))
                  ([], SEnv.empty)
                  newGlobalDecAndMaps
          val newDec = TP.TPLOCALDEC(newLocalDecs, newGlobalDecs, loc)
        in
          (newContext, [newDec], printCodesMap)
        end
      | _ => raise Control.Bug "unknown declaration is passed to visitValDec"

  (**
   *)
  and visitDec context path positionCTX declaration =
      case declaration of
        (* NOTE: The following cases for val declrarations are some tricky.
         * This is in order to share codes with the case for VALRECGROUP.
         *)
        TP.TPVAL (binds, loc) =>
        let
          val (newContext, handledDecs, printCodesMap) =
              visitValDec context path positionCTX declaration
        in (newContext, handledDecs @ SEnv.listItems printCodesMap)
        end
      | TP.TPVALREC (binds, loc) =>
        let
          val (newContext, handledDecs, printCodesMap) =
              visitValDec context path positionCTX declaration
        in (newContext, handledDecs @ SEnv.listItems printCodesMap)
        end
      | TP.TPVALPOLYREC(btvMap, binds, loc) =>
        let
          val (newContext, handledDecs, printCodesMap) =
              visitValDec context path positionCTX declaration
        in (newContext, handledDecs @ SEnv.listItems printCodesMap)
        end
      | TP.TPVALRECGROUP (ids, decs, loc) =>
        if PC.Top = PC.getPosition positionCTX
          then
            let
              fun visit (dec, (bindContext, handledDecs, printCodeMap)) =
                let
                  val newBindContext = U.unionContexts [context, bindContext]
                  val (newContext, newHandledDecs, newPrintCodeMap) =
                      visitValDec newBindContext path positionCTX dec
                  val resultHandledDecs = newHandledDecs :: handledDecs
                  val resultPrintCodeMap =
                      SEnv.unionWith #1 (newPrintCodeMap, printCodeMap)
                  val extendedBindContext =
                      U.unionContexts [bindContext, newContext]
                in (extendedBindContext, resultHandledDecs, resultPrintCodeMap)
                end
              (* NOTE: handledDecs is in reverse order. *)
              val (newContext, handledDecs, printCodesMap) =
                  foldl visit (TC.emptyContext, [], SEnv.empty) decs
              fun findPrintCode id =
                case SEnv.find (printCodesMap, id) of
                  SOME code => code
                | NONE =>
                  raise Control.Bug("printCode for " ^ id ^ " not found")
              val printCodes =
                  if PC.isPrintBinds positionCTX
                  then map findPrintCode ids
                  else []
            in
              (newContext, List.concat(List.rev handledDecs) @ printCodes)
            end
        else (* not (PC.Top = PC.getPosition postionCTX) *)
          (* VALRECGROUP has no effect except at the top level. *)
          visitDecs context path positionCTX decs
      | TP.TPLOCALDEC(localDeclarations, globalDeclarations, loc) =>
        let
          val (localContext, newLocalDeclarations) = 
              visitDecs
                  context path (PC.enterLocal positionCTX) localDeclarations
          val newLocalContext = U.unionContexts [context, localContext]
          val (newContext, newGlobalDeclarations) =
              visitDecs newLocalContext path positionCTX globalDeclarations
        in
          (
            newContext,
            [TP.TPLOCALDEC(newLocalDeclarations, newGlobalDeclarations, loc)]
          )
        end
      | TP.TPOPEN (strPathInfos, loc) =>
        let
          fun extendContext ({env, ...} : TY.strPathInfo, newContext) =
              TC.extendContextWithEnv(newContext, env)
          val newContext = foldl extendContext TC.emptyContext strPathInfos
          val printCodes =
              if PC.isPrintBinds positionCTX
              then [PG.generatePrintCodeForOpen context path loc strPathInfos]
              else []
        in
          (newContext, [declaration] @ printCodes)
        end
      | TP.TPDATADEC (tyCons, loc) =>
        let
          val tyConBindContext = foldl U.bindTyCon TC.emptyContext tyCons
          val newTyConBindContext = U.unionContexts [context, tyConBindContext]
          val (formatterBindContext, formatterDeclarations) =
              FG.generateFormatterForDatatypes
                  newTyConBindContext path positionCTX loc tyCons
          val printCodes =
              if PC.isPrintBinds positionCTX
              then [PG.generatePrintCodeForDatatypes context path loc tyCons]
              else []
          val resultContext =
              U.unionContexts [tyConBindContext, formatterBindContext]
        in
          (resultContext, [declaration] @ printCodes @ formatterDeclarations)
        end
      | TP.TPABSDEC ({absTyCons, rawTyCons, decls}, loc) => 
        let
          (* rawTyCons are representation of tyCons visible in decls.
           * absTyCons are representation visible global.
           * For example,
           *   abstype dt = D in val x = D end
           * for this declaration, absTyCons and rawTyCons are as follows.
           *   absTyCons = [{name = "dt", id = i, datacon = []}]
           *   rawTyCons = [{name = "dt", id = i, datacon = ["D"]}]
           *)
          val (formatterBindContext, formatterDeclarations) =
              FG.generateFormatterForAbstypes
                  context path positionCTX loc absTyCons
          val tyConPrintCodes =
              if PC.isPrintBinds positionCTX
              then [PG.generatePrintCodeForAbstypes context path loc absTyCons]
              else []

          val absTyConBindContext = foldl U.bindTyCon TC.emptyContext absTyCons
          val rawTyConBindContext = foldl U.bindTyCon TC.emptyContext rawTyCons
          val innerContext =
              U.unionContexts
                  [context, rawTyConBindContext, formatterBindContext]
          val (newContext, newDeclarations) =
              visitDecs innerContext path positionCTX decls
          val codes = tyConPrintCodes @ formatterDeclarations @ newDeclarations
          val absInfo =
              {absTyCons = absTyCons, rawTyCons = rawTyCons, decls = codes}
          val newDeclaration = TP.TPABSDEC (absInfo, loc)

          val unionedContext = 
              U.unionContexts
                  [absTyConBindContext, formatterBindContext, newContext]
          (* substitute original tycon with abstracted tycon *)
          fun extendTyConSubst
                  ({id = rawTyConID, ...} : TY.tyCon, absTyCon, substMap) =
              ID.Map.insert (substMap, rawTyConID, TY.TYCON absTyCon)
          val tyConSubst =
              ListPair.foldl
                  extendTyConSubst ID.Map.empty (rawTyCons, absTyCons)
          val substitutedContext =
              TCU.substTyConInContext tyConSubst unionedContext
        in
          (substitutedContext, [newDeclaration])
        end
      | TP.TPDATAREPDEC
            (
              {left = leftTyCon, right = {relativePath, tyCon = rightTyCon}},
              loc
            ) =>
        let
          val tyConBindContext = 
              TC.extendContextWithVarEnv
                  (
                    TC.bindTyConInContext
                        (TC.emptyContext, #name leftTyCon, TY.TYCON leftTyCon),
                    !(#datacon leftTyCon)
                  )
          val (formatterBindContext, formatterDeclarations) =
              FG.generateFormatterForDatatypeReplication
                  (U.unionContexts [context, tyConBindContext])
                  path
                  positionCTX
                  loc
                  (leftTyCon, relativePath, rightTyCon)
          val printCodes =
              if PC.isPrintBinds positionCTX
              then
                [
                  PG.generatePrintCodeForDatatypeReplication
                      context path loc (leftTyCon, relativePath, rightTyCon)
                ]
              else []
          val newContext =
              U.unionContexts [tyConBindContext, formatterBindContext]
        in
          (newContext, [declaration] @ printCodes @ formatterDeclarations)
        end
      | TP.TPEXNDEC (exnBinds, loc) =>
        let
          fun bindExn (exnBind, localContext) =
              case exnBind of
                TP.TPEXNBINDDEF (conInfo as {name = conName, ...}) =>
                TC.bindVarInContext (localContext, conName, TY.CONID(conInfo))
              | TP.TPEXNBINDREP(name, (strPath, string)) =>
                (* search global CTX *)
                case TC.lookupLongVar(context, strPath, string) of
                  (_, SOME idState) => (* bind in local CTX *)
                  TC.bindVarInContext(localContext, name, idState)
                | (_, NONE) =>
                  raise
                    Control.Bug
                        ("not found constructor "
                         ^ (U.pathNameToString (strPath, string)))
          val exnBindContext =
              foldl bindExn TC.emptyContext exnBinds
          val newExnBindContext = U.unionContexts [context, exnBindContext]
          val (formatterBindContext, formatterDeclarations) =
              FG.generateFormatterForExnBinds
                  newExnBindContext path positionCTX loc exnBinds
          val newContext =
              U.unionContexts [exnBindContext, formatterBindContext]
          val printCodes =
              if PC.isPrintBinds positionCTX
              then [PG.generatePrintCodeForExnBinds context path loc exnBinds]
              else []
        in
          (newContext, [declaration] @ printCodes @ formatterDeclarations)
        end
      | TP.TPTYPE (binds, loc) =>
        let
          fun bindTyFun (TY.TYFUN tyFun, newContext) =
              TC.bindTyConInContext (newContext, #name tyFun, TY.TYFUN tyFun)
          val tyBindContext = foldr bindTyFun TC.emptyContext binds
          val newTyBindContext = U.unionContexts [context, tyBindContext]

          val formatterBindContext = TC.emptyContext
          val formatterDeclarations =
              map
                  (FG.generateFormatterForTyFun newTyBindContext path loc)
                  binds

          val newContext =
              U.unionContexts [formatterBindContext, tyBindContext]
          val printCodes =
              if PC.isPrintBinds positionCTX
              then [PG.generatePrintCodeForTypes context path loc binds]
              else []
        in
          (newContext, [declaration] @ printCodes @ formatterDeclarations)
        end
      | TP.TPINFIXDEC(n, names, loc) =>
        if PC.isPrintBinds positionCTX
        then
          let
            val printCode =
                PG.generatePrintCodeForInfix
                    context path loc (SE.INFIX n, names)
          in (TC.emptyContext, [printCode]) end
        else (TC.emptyContext, [])
      | TP.TPINFIXRDEC(n, names, loc) =>
        if PC.isPrintBinds positionCTX
        then
          let
            val printCode =
                PG.generatePrintCodeForInfix
                    context path loc (SE.INFIXR n, names)
          in (TC.emptyContext, [printCode]) end
        else (TC.emptyContext, [])
      | TP.TPNONFIXDEC(names, loc) =>
        if PC.isPrintBinds positionCTX
        then
          let
            val printCode =
                PG.generatePrintCodeForInfix
                    context path loc (SE.NONFIX, names)
          in (TC.emptyContext, [printCode]) end
        else (TC.emptyContext, [])

  fun visitStrExp context path positionCTX strExp =
      case strExp of
        TP.TPMSTRUCT (strDecls,loc) =>
        let
          val newPositionCTX = PC.enterStructure positionCTX
          val (newContext, newStrDecls) =
              visitStrDecls context path newPositionCTX strDecls
        in (newContext, [TP.TPMSTRUCT (newStrDecls,loc)]) end
      | TP.TPMLONGSTRID (strPathInfo as {id, name, strpath, env, ...},loc) =>
        let
          (* convert strpath into absolute path *)
          val relativePath = P.appendPath(strpath, id, name)
          val absolutePath = (* assume TypeContext returns absolute path. *)
              case TC.lookupLongStructure(context, relativePath) of
                (_, SOME (strPathInfo as {strpath, ...})) => 
                P.appendPath(strpath, id, name)
          val pathUpdatedStrEnv = 
              TCU.updateStrpathInTopEnv
                  {newStrpath = path, currentStrpath = absolutePath}
                  env
          val newContext = TC.injectEnvToContext pathUpdatedStrEnv
        in
(*
          print ("currentpath = " ^ (pathToString path) ^ "\n");
          print ("strpath = " ^ (pathToString absolutePath) ^ "\n");
*)
          (newContext, [TP.TPMLONGSTRID (strPathInfo,loc)])
        end
      | TP.TPMOPAQCONS (innerStrExp, constraintSigExp, sigEnv, loc) =>
        let
          val (newContext, [newInnerStrExp]) =
              visitStrExp context path positionCTX innerStrExp
          val newSigEnv = insertFormatterIntoEnv sigEnv
        in
          (
            newContext,
            [TP.TPMOPAQCONS (newInnerStrExp, constraintSigExp, newSigEnv, loc)]
          )
        end
      | TP.TPMTRANCONS (innerStrExp, constraintSigExp, sigEnv, loc) =>
        let
          val (newContext, [newInnerStrExp]) =
              visitStrExp context path positionCTX innerStrExp
          val newSigEnv = insertFormatterIntoEnv sigEnv
        in
          (
            newContext,
            [TP.TPMTRANCONS (newInnerStrExp, constraintSigExp, newSigEnv, loc)]
          )
        end
      | TP.TPMFUNCTORAPP
            (
              funBindInfo,
              {strArg, env},
	      exnTagSubst,
              instTyConSubst,
              anonyStrPath,
	      loc
            ) =>
        let
          (* visit argument structure. *)
          val strArgPath = anonyStrPath
          val (_, [newStrArgExp]) =
              visitStrExp context strArgPath positionCTX strArg
          val argInfo = {strArg = newStrArgExp, env = env}

          (* ToDo : replace *)
          val absolutePath =
              P.appendPath
                  (
                    P.NilPath,
                    #id (#func funBindInfo),
                    #name (#func funBindInfo)
                  )
          val newEnv = 
              TCU.updateStrpathInTopEnv
                  {newStrpath = path, currentStrpath = absolutePath}
                  (#2(#constrained(#body(#func(#functorSig funBindInfo)))))
(*
          val _ = print "newEnv: \n"
          val _ = print (TypeFormatter.envToString newEnv)
          val _ = print "\n"
*)
          val newContext = TC.injectEnvToContext newEnv
(*
          val newContext = TC.emptyContext
*)
        in
          (
            newContext,
            [
              TP.TPMFUNCTORAPP
                  (
                    funBindInfo,
                    argInfo,
                    exnTagSubst,
                    instTyConSubst,
                    anonyStrPath,
                    loc
                  )
            ]
          )
        end 
      | TP.TPMLET (localStrDecls, globalStrExp, loc) =>
        let
          val (localContext, newLocalStrDecls) =
              visitStrDecls
                  context path (PC.enterLocal positionCTX) localStrDecls
          val newLocalContext = U.unionContexts [context, localContext]
          val (newContext, [newGlobalStrExp]) =
              visitStrExp newLocalContext path positionCTX globalStrExp
        in
          (newContext, [TP.TPMLET(newLocalStrDecls, newGlobalStrExp, loc)])
        end

  and visitStrBind context path positionCTX ({id, name, ...}, strExp) =
      let
        val innerPath = Path.appendPath(path, id, name)
        val (newContext, [newStrExp]) =
            visitStrExp context innerPath positionCTX strExp
        val strEnv = TC.getStructureEnvFromContext newContext
        val strInfo = {id = id, name = name, env = strEnv}
        val strPathInfo = {id = id, name = name, strpath = path, env = strEnv}
      in
        (
          TC.bindStrInContext(TC.emptyContext, name, TY.STRUCTURE strPathInfo),
          [(strInfo, newStrExp)]
        )
      end

  and visitStrDecls context path positionCTX declarations =
      visitSequential visitStrDecl context path positionCTX declarations

  and visitStrDecl context path positionCTX declaration =
      case declaration of
        TP.TPMCOREDEC (tpDecls, loc) =>
        let
          val (newContext, newTpDecls) =
              visitDecs context path positionCTX tpDecls
        in (newContext, [TP.TPMCOREDEC (newTpDecls, loc)]) end
      | TP.TPMSTRBIND (strBinds, loc) =>
        let
          fun visitStrBindForPrint context path _ (strBind as (strInfo, _)) =
              let
                val printExp =
                    PG.generatePrintCodeForStrBind context path loc strBind
                val printDec =
                    TP.TPVAL([(TY.VALIDWILD OC.unitTy, printExp)], loc)
              in
                (context, [TP.TPMCOREDEC([printDec], loc)])
              end
          val (strBindContext, newStrBinds) = 
              visitSequential visitStrBind context path positionCTX strBinds
          val newStrBindContext = U.unionContexts [context, strBindContext]
          val (_, printDecs) =
              if PC.isPrintBinds positionCTX
              then
                visitSequential
                    visitStrBindForPrint
                    newStrBindContext
                    path
                    positionCTX
                    strBinds
              else (context, [])
        in (strBindContext, (TP.TPMSTRBIND(newStrBinds, loc)) :: printDecs) end
      | TP.TPMLOCALDEC (localDeclarations, globalDeclarations, loc) =>
        let
          val (localContext, newLocalDeclarations) = 
              visitStrDecls
                  context path (PC.enterLocal positionCTX) localDeclarations
          val newLocalContext = U.unionContexts [context, localContext]
          val (newContext, newGlobalDeclarations) =
              visitStrDecls newLocalContext path positionCTX globalDeclarations
          val newDeclaration =
              [TP.TPMLOCALDEC
                   (newLocalDeclarations, newGlobalDeclarations, loc)]
        in
          (newContext, newDeclaration)
        end

  fun visitSigBind
      context
      path
      positionCTX
      (sigBindInfo as TY.SIGNATURE(_, {name, ...}), sigExp) =
      let val newContext = TC.bindSigInEmptyContext(name, sigBindInfo)
      in (newContext, [(sigBindInfo, sigExp)]) end

  fun visitFunBind
      context
      path
      positionCTX
      (funBindInfo : TP.funBindInfo, argName, sigExp, strExp) =
      let
        val functorName = #name (#func funBindInfo)
        val functorSig = #functorSig funBindInfo
        val innerPath =
            Path.appendPath(path, #id (#func funBindInfo), functorName)

        (* add tycons specified in arg into the context. *)
        val {id = argId, name = argName} = #argument(funBindInfo)
        val argEnv = #arg(#func(functorSig))
        val innerArgEnv = replaceTySpecToTyConInEnv argEnv
        val argStrPathInfo =
            {
              id = argId,
              name = argName,
              strpath = innerPath,
              env = innerArgEnv
            }
        val innerContext = 
            TC.bindStrInContext(context, argName, TY.STRUCTURE argStrPathInfo)
        (* insert formatters for tyCons declared in the body *)
        val (_, [newStrExp]) =
            visitStrExp innerContext innerPath positionCTX strExp
(*
        val _ = print ("\nvisitFunBind: " ^ functorName ^ "\n")
        val _ = print (TypedCalcFormatter.tpmstrexpToString [] newStrExp)
        val _ = print ("\n")
*)

        val newArgEnv = insertFormatterIntoEnv argEnv
        val newFunctorSig = 
            {
	      exnTagSet = #exnTagSet functorSig,
              tyConIdSet = #tyConIdSet functorSig,
              func = {arg = newArgEnv, body = #body (#func functorSig)}
            }
        val newFunBindInfo =
            {
              func = #func funBindInfo,
              argument = #argument funBindInfo,
              functorSig = newFunctorSig
            } : TY.funBindInfo

        val newContext = TC.bindFunInEmptyContext(functorName, funBindInfo)
      in
        (newContext, [(newFunBindInfo, argName, sigExp, newStrExp)])
      end

  fun visitTopDec context path positionCTX (TP.TPMDECSTR (strDecl, loc)) =
      let
        val (newContext, newStrDecls) =
            visitStrDecl context path positionCTX strDecl
      in (newContext, map (fn dec => TP.TPMDECSTR(dec, loc)) newStrDecls) end
    | visitTopDec context path positionCTX (TP.TPMDECSIG (sigDecls, loc)) =
      let
        val printCode =
            if PC.isPrintBinds positionCTX
            then
              let
                val printExp =
                    PG.generatePrintCodeForSigDecls context path loc sigDecls
                val printDec =
                    TP.TPVAL([(TY.VALIDWILD OC.unitTy, printExp)], loc)
              in
                [TP.TPMDECSTR(TP.TPMCOREDEC([printDec], loc), loc)]
              end
            else []
        val (newContext, _) = 
            visitSequential visitSigBind context path positionCTX sigDecls
      in
        (newContext, [TP.TPMDECSIG (sigDecls, loc)] @ printCode)
      end
    | visitTopDec context path positionCTX (TP.TPMDECFUN (funDecls, loc)) =
      let
        val printCode =
            if PC.isPrintBinds positionCTX
            then
              let
                val printExp =
                    PG.generatePrintCodeForFunDecls context path loc funDecls
                val printDec =
                    TP.TPVAL([(TY.VALIDWILD OC.unitTy, printExp)], loc)
              in
                [TP.TPMDECSTR(TP.TPMCOREDEC([printDec], loc), loc)]
              end
            else []
        val (newContext, newFunDecls) = 
            visitSequential visitFunBind context path positionCTX funDecls
      in
        (newContext, [TP.TPMDECFUN (newFunDecls, loc)] @ printCode)
      end

  fun visitTopDecs context path positionCTX declarations =
      visitSequential visitTopDec context path positionCTX declarations

  fun generate
          {
            context = {sigEnv, strEnv, funEnv, ...} : IT.topTypeContext,
            newContext,
            printBinds,
            declarations
          } =
      let
        (*
         * The PrinterGenerator builds a context from declarations, as the
         * TypeInferencer does.
         * This is necessary to judge the visibility of type constructors.
         * But this new context is not used as the return value.
         *)

        val context =
            TC.extendContextWithSigEnv(TC.injectStrEnvToContext strEnv, sigEnv)
        val positionCTX = PC.create printBinds
        val (_, newDeclarations) =
            visitTopDecs context P.NilPath positionCTX declarations
      in
        (* return newContext which is passed as the argument without change. *)
        (newContext, newDeclarations)
      end

  (***************************************************************************)

end
