
\documentclass{article}

\usepackage{doublespace}
\usepackage{a4wide}
\usepackage{latexsym}
\usepackage{proof}


\newcommand{\code}[1]{\mbox{{\sf #1}}}
\newcommand{\run}{\longrightarrow}
\newcommand{\runstar}{\stackrel{*}{\longrightarrow}}
\newcommand{\conv}{\Downarrow}

\newcommand{\singleton}[1]{[#1]}
\newcommand{\cons}[2]{#1\cdot#2}
\newcommand{\db}[1]{[\![#1]\!]}                                %% double brackets
\newcommand{\bigdb}[1]{\biggl[\!\!\biggl[{#1}\biggr]\!\!\biggr]} %% big double brackets

\newcommand{\ktyping}[5]{#1\,|\,#2\,|\,#3\rhd #4 : #5}
\newcommand{\comp}[4]{#1\,|\,#2\rhd #3\leadsto_k #4}
\newcommand{\zcomp}[4]{#1\,|\,#2\rhd #3\leadsto_z #4}      %% zinc compilation
\newcommand{\typing}[4]{#1\,|\,#2\rhd #3 : #4}
\newcommand{\styping}[3]{#1\rhd #2 : #3}                   %% simple typing
\newcommand{\eenv}{\Gamma} % environment
\newcommand{\senv}{\Delta} % a spine stack
\newcommand{\lenv}{\Pi} % a local stack
\newcommand{\vbar}{\,|\,}
\newcommand{\func}{\rightarrow}
\newcommand{\contfunc}{\Rightarrow}
\newcommand{\sfunc}{\Rightarrow}
\newcommand{\starcnv}[1]{#1^\star}

\newcommand{\sep}{\hspace*{2ex}}
% \newcommand{\mklab}[1]{\sep}
\newcommand{\rulelab}{1.2cm}
\newcommand{\mklab}[1]{\sep\makebox[\rulelab][r]{{(#1)}\ }}
\newcommand{\mkcenterlab}[1]{\sep\makebox[\rulelab][c]{{(#1)}\ }}
% \newcommand{\labsep}{\sep\makebox[\rulelab][r]{}}
\newcommand{\axiom}[2]{\mklab{#1} \begin{tabular}{c}#2
                                  \end{tabular}}
\newcommand{\axiomc}[3]{\mklab{#1}
        #2\ \ \ \ #3}

\newcommand{\ruleone}[3]{\mklab{#1}
                        \begin{tabular}{c}#2\\ \cline{1-1} #3
                        \end{tabular}}
\newcommand{\ruletwo}[4]{\mklab{#1}
                        \begin{tabular}{c}#2 \\ #3\\ \cline{1-1} #4
                        \end{tabular}}
\newcommand{\rulethree}[5]{\mklab{#1}
                        \begin{tabular}{c}#2 \\ #3 \\ #4 \\ \cline{1-1} #5
                        \end{tabular}}
\newcommand{\rulefour}[6]{\mklab{#1}
                        \begin{tabular}{c}#2 \\ #3 \\ #4 \\ #5 \\ 
                                       \cline{1-1} #6
                        \end{tabular}}
\newcommand{\ruleonec}[4]{\mklab{#1}
                        \begin{tabular}{c}#2\\ \cline{1-1} #3
                        \end{tabular}\ \ \ #4}
\newcommand{\rvsep}{\\[0.5ex]}

%%
%%  Definitions
%%

%% TODO

\newcommand{\todo}[1]{{\it TODO} : \begin{minipage}[t]{10cm}
                                     #1
                                   \end{minipage} }

%% Titles

\newcommand{\IML}{IML\ }
\newcommand{\rulename}[1]{\noindent\fbox{#1}}

%% Nothing

\newcommand{\dontcare}{\_}

%% Typing contexts

\newcommand{\tyckenv}{tyckenv}

\newcommand{\env}    {env}

\newcommand{\tcenv}  {tcenv}
\newcommand{\genv}   {genv}
\newcommand{\btvenv} {btvenv}
\newcommand{\varenv} {varenv}
\newcommand{\fieldenv} {fieldenv}

\newcommand{\select}[2] {\# #2(#1)}
\newcommand{\extendop} {+}
\newcommand{\extend}[2] {#1 \extendop  #2}

\newcommand{\envTcenv}[1]  {\select{\env}{\tcenv} \ (#1) }
\newcommand{\envGenv}[1]   {\select{\env}{\genv} \ (#1)  }
\newcommand{\envBtvenv}[1] {\select{\env}{btvenv} \ (#1) }
\newcommand{\envVarenv}[1] {\select{\env}{\varenv}\ (#1) }

%% Types

\newcommand{\ty}       {ty}
\newcommand{\tys}      {tylist}
\newcommand{\fieldtys} {fieldtys}

\newcommand{\intty}    {intty}
\newcommand{\stringty} {stringty}
\newcommand{\realty}   {realty}
\newcommand{\charty}   {charty}
\newcommand{\wordty}   {wordty}

\newcommand{\polyty}   {polyty}

%% Expressions

\newcommand{\constant} {constant}
\newcommand{\expr}     {exp}
\newcommand{\exprs}    {explist}
\newcommand{\expropt}  {expopt}
\newcommand{\fields}   {fieldlist}
\newcommand{\pat}      {pat}
\newcommand{\patopt}   {patopt}
\newcommand{\pats}     {patlist}
\newcommand{\patexpr}  {patexp}
\newcommand{\patexprs} {patexplist}
\newcommand{\patfields}{patfields}
\newcommand{\casekind} {casekind}

%% Declarations

\newcommand{\valbind}  {valbind}
\newcommand{\valbinds} {valbindlist}

\newcommand{\decl}  {decl}
\newcommand{\decls} {decllist}

%% Judgments

\newcommand{\kindingType}[3]  {#1 \rhd #2 : #3}
\newcommand{\typeEquality}[3]  {#1 \rhd #2 \ = \ #3}

\newcommand{\wellformedType}[2]  {#1 \rhd #2}
\newcommand{\instantiate}[4]  {#1 \rhd instantiate \ (#2, \ #3) \ \Rightarrow \ #4}
\newcommand{\overload}[4]  {#1 \rhd overload \ (#2, \ #3) \ \Rightarrow \ #4}

\newcommand{\typingConst}[3] {#1 \rhd #2 : #3}

\newcommand{\typingExp}[3]   {#1 \rhd #2 : #3}
\newcommand{\typingExpOpt}[4]   {#1 \rhd #2 : #3 \Rightarrow #4}

\newcommand{\typingPat}[4]   {#1 \rhd #2 : #3, \ #4}
\newcommand{\typingPatFields}[4]   {#1 \rhd #2 : #3, \ #4}
\newcommand{\typingPatOpt}[5]   {#1 \rhd #2 : #3 \Rightarrow #4, \ #5}

\newcommand{\typingPatExp}[5]   {#1 \rhd (#2, #3) : #4 \Rightarrow #5}
\newcommand{\typingPatExps}[4]   {#1 \rhd #2 : #3 \Rightarrow #4}

\newcommand{\typingFields}[3]   {#1 \rhd #2 : #3}

\newcommand{\typingValBind}[3]   {#1 \rhd #2 : #3}

\newcommand{\typingDecl}[4]   {#1 \rhd #2 : (#3, \ #4)}

\title{Typed Intermediate Languages in the \IML Compiler}
\author{The \IML compiler team}

\begin{document}

\maketitle
\tableofcontents

\section{Introduction}

\subsection{Notation}

First of all, the following are some of the notations used frequently.
\begin{itemize}
\item $i$, $j$, $k$, $n$, and $m$ are integers.
\item $con$, $label$, and $id$ are strings to denote the name of a
(type) constructor, a label, an identifier. 
\item $\{ \ label_1=object_1, \ ... \ , label_n=object_n \ \}$ denotes
a record.
\item $[ \ object_1, \ ... \ , object_n \ ]$ denotes a list of objects. 
\item $\{ \ label_1 \mapsto object_1, \ ... \ , label_n \mapsto
object_n\ \}$ denotes a mapping of labels into objects.
\end{itemize}

Second, symbols for syntactic and semantic objects are chosen to have
the same name as (or, the abbreviated name of) the actual name of
types and constructors for the objects' representation in the
implementation (i.e., the \IML compiler). For example,

\begin{itemize}
\item $\ty$ is chosen to denote a type, and $FUNty \ (\ty_1, \ty_2)$
is chosen to denote a function type. The names are derived from the
following ML datatype declaration for the types' representation in the
actual implementation.
\begin{itemize}
\item 
$ \mbox{datatype} \ \mbox{\ty} \ = \ \cdots \ \ | \ \ \mbox{FUNty} \ \ \mbox{of} \ \ \mbox{\ty} \ \mbox{*} \ \mbox{\ty} \ \ | \ \ \cdots$
\end{itemize}

\item $\expropt$ denotes an optional expression, which is represented
by the ML type `` $\mbox{\expr} \ \mbox{option}$ '' where
$\mbox{\expr}$ is the ML type for term representation.

\item $\tys$ denotes a list of types (`` $\mbox{\ty} \ \mbox{list}$
''), and $\fieldtys$ denotes a mapping of field labels to types (``
$\mbox{\ty} \ \mbox{SEnv.map}$ '')\footnote{Although some extra
definitions of functors and structures in the ML library are needed to
explain what ``$\mbox{\ty} \ \mbox{SEnv.map}$'' is, this can be
easily read as an ML type for mappings of strings to types.}.  Recall that
labels are represented by strings.  $\patexprs$ denotes a list of
pairs of a pattern and an expression (`` $\mbox{(\pat} \ \mbox{*}
\mbox{\expr)} \ \ \mbox{list}$ '').

\end{itemize}

Third, the various kinds of rules we use have the form as 

\ruleone{rule}
   { $Judgment_1 \ \ \ \cdots \ \ \ Judgment_n$ }
   { $Judgment$ }
\\
followed by some extra conditions, whenever they are needed to be
stated, after ``where'' clause. 


\section{Typed Pattern Language}

A specification for the typed pattern language (TP), which is
an intermediate language of the \IML compiler, is defined.  

\subsection{Types and terms}

For the syntax of types and kinds, we refer to the datatypes \ty,
eqkind, reckind, and rank in ``types/main/types.ppg.''  For the syntax
of terms, we refer to the datatypes tpexp, tpdecl, and tppat in
``typedcalc/main/typedcalc.ppg.''

Each new name for types and terms will be explained whenever it
appears for the first time, or we will skip explaining it when it is
too obvious.

\subsection{Typing environments}

A typing environment $\env$ consists of four sub-environments: a type
constructor environment $\tcenv$, a global variable environment
$\genv$, a bound type variable environment $\btvenv$, and a variable
environment $\varenv$.
\begin{eqnarray*}
\env & ::= & \{tcenv=\tcenv, \ genv=\varenv, \ btvenv=\btvenv, \ varenv=\varenv\}
\\
\tcenv & ::= & \{con_1\mapsto tybindinfo_1, \ ... \ , con_n\mapsto tybindinfo_n\}
\\
\genv & ::= & \{id_1\mapsto idstate_1, \ ... \ , id_n\mapsto idstate_n\}
\\
\btvenv & ::= & \{1\mapsto btvkind_1, \ ... \ , n\mapsto btvkind_n\}
\\
\varenv & ::= & \{id_1\mapsto idstate_1, \ ... \ , id_n\mapsto idstate_n\}
\end{eqnarray*}

A type constructor environment ($\tcenv$) is a mapping of type
constructor names ($con$) into type binding information descriptions
($tybindinfo$), which are either a datatype declaration
or a type synonym declaration. A datatype declaration is described by
a name, an arity, an identification number, an equality kind, a data
constructor environment. 
\begin{eqnarray*}
tybindinfo & ::= & TYCON \ tycon \ \ | \ \ TYFUN \ \{name:string, 
tyargs:\btvenv, body:ty\}
\\
tycon & ::= & \{ name:string, arity:int, id:int, eqkind:eqkind\_ref, datacon:varenv\_ref\}
\end{eqnarray*}

A variable environment ($\genv$ or $\varenv$) is a mapping of
identifies into identifier states, which are one of a variable, a data
constructor, a primitive operator, and an overloaded primitive
operator. Basically, each identifier is described by its name and
type.  $opriminfo$ not only contains a name and a type for an
overloaded primitive operator, but it also contains another names and
types for each instance primitive operator obtained from resolving the
overloading.  $coninfo$ describes a data constructor by its name,
type, the availability of a constructor argument ($funtycon$), an
extra tag when it is an exception constructor, and a datatype
declaration ($tycon$) where it belongs.
\begin{eqnarray*}
idstate & ::= & VARID \ varinfo \ | \ 
CONID \ coninfo \ | \
PRIM \ priminfo \ | \
OPRIM \ opirminfo
\\
varinfo & = & \{ name:string, \ ty : \ty \}
\\
priminfo & = & \{ name:string, \ ty : \ty \}
\\
opriminfo & = & \{ name:string, \ ty : \ty, \ instances : priminfos \}
\\
coninfo & = & \{ name:string, \ ty : \ty, \ funtycon : bool, \ exntag
: int, \ tycon : tycon \}
\end{eqnarray*}

A bound type variable environment ($\btvenv$) is a mapping of de
Bruijn indexes (i.e., integers) into bound type kinds, Each $btvkind$
includes a record kind, an equality kind, and a rank.
\begin{eqnarray*}
btvkind & = & \{ \ reckind:reckind, \ eqkind:eqkind, \ rank:bool, \ index:int \ \}
\\
eqkind  & = & EQ \ | \ NONEQ
\\
reckind & = & UNIV \ | \ REC \ \{ label_1\mapsto\ty_1 , ... , label_n\mapsto\ty_n\} \ | \ OVERLOADED \ \tys
\end{eqnarray*}

Selection and extension operations on typing environments are defined
as follows:
\begin{itemize}
\item $\select{\env}{\varenv}$ selects the variable environment of the
typing environment.
\item $\extend{\env}{\varenv'}$ extends $\env$ by extending the
current variable environment $\select{\env}{\varenv}$ with an
additional variable environment $\varenv'$.
\item The selection and extension operations for $\tcenv$, $\genv$,
and $\btvenv$ are defined similarly.
\end{itemize}

\subsection{Typing rules}

\subsubsection{Well-formed types}

\rulename{$\wellformedType{\env}{\ty}$}

\begin{itemize}
\item A type $\ty$ is closed under a bound-type-variable environment $\select{\env}{\btvenv}$.
\end{itemize}

\rulename{$\wellformedType{\env}{\tys}$}

\begin{itemize}
\item Each type of $\tys$ is closed under a bound-type-variable environment $\select{\env}{\btvenv}$.
\end{itemize}

\subsubsection{Type equality}

\rulename{$\typeEquality{\env}{\ty}{\ty'}$}

\begin{itemize}
\item A type $\ty$ is equal to another type $\ty'$ under a bound-type-variable environment $\select{\env}{\btvenv}$.
\item This judgment is assumed to be implicitly used for each pair of
multiple occurrences of any type in kinding rules and typing rules.
\end{itemize}

\subsubsection{Kinding types}

\rulename{$\kindingType{\env}{\ty}{eqk}$}

\begin{itemize}
\item A type $\ty$ has equality-kind $eqk$ under a bound-type-variable environment $\select{\env}{\btvenv}$.
\end{itemize}

\ruleone{eq-errorty}
   { }
   { $\kindingType{\env}{ERRORty}{NONEQ}$ }

\ruleone{eq-dummyty}
   { }
   { $\kindingType{\env}{DUMMYty}{NONEQ}$ } 

\ruleone{eq-tyvarty-tvar}
   { $tvkind \ = \ \{reckind=\dontcare\ , \ eqkind=eqk, \ tyvarname=\dontcare\ , id=\dontcare\ \}$ }
   { $\kindingType{\env}{TYVARty \ (ref \ (TVAR \ tvkind))}{eqk}$ }

\ruleone{eq-tyvar-subst}
   { $\kindingType{\env}{\ty}{eqk}$ }
   { $\kindingType{\env}{TYVARty \ (ref \ (SUBSTITUTED \ \ty))}{eqk}$ }

\ruleone{eq-boundvarty}
   { $\select{\env}{\btvenv} \ (i) \ = \ \{reckind=\dontcare\ , \ eqkind=eqk, rank=\dontcare\ , index=\dontcare\ \}$ }
   { $\kindingType{\env}{BOUNDVARty \ i}{EQ}$ }

\begin{itemize}
\item Every bound type variable is assumed to have eqkind $EQ$. 
\end{itemize}

\ruleone{eq-funty}
   { 
%%     $\kindingType{\env}{\ty_1}{eqk_1}$ \ \ \ 
%%     $\kindingType{\env}{\ty_2}{eqk_2}$ 
   }
   { $\kindingType{\env}{FUNty \ (\ty_1,\ty_2)}{NONEQ}$ }

\ruleone{eq-iabsty}
   { 
%%      $\kindingType{\env}{\ty}{eqk}$ \ \ \ 
%%      $\kindingType{\env}{\ty_i}{eqk_i}$ \ \ \ 
%%      ($1 \leq i \leq $ the length of $\tys$)
   }
   { $\kindingType{\env}{IABSty \ (\tys,\ty)}{NONEQ}$ }

\ruleone{eq-recordty}
   { $\kindingType{\env}{\ty_i}{eqk_i}$ \ \ \ 
     ($1 \ \leq i \leq \ n$) }
   { $\kindingType{\env}{RECORDty \ \{label_1 \mapsto \ty_1, ... , label_n \mapsto \ty_n\}}{eqk}$ }

\begin{itemize}
\item where
\begin{itemize}
\item $eqk \ = \ EQ$ if $eqk_i=EQ$ for all $i$. Otherwise, $eqk\ = \ NONEQ$.
\end{itemize}
\end{itemize}


\ruleone{eq-conty}
   { $\kindingType{\env}{\ty_i}{eqk_i}$ \ \ \ 
     ($1 \leq i \leq $ the length of $\tys$) }
   { $\kindingType{\env}{CONty \ \{tycon=tycon, \ args=\tys\}}{eqk}$ }

\begin{itemize}
\item where
\begin{itemize}
\item $tycon \ = \ \{name=\dontcare, \ arity=\dontcare, \ id=\dontcare, \ eqkind=eqk\_ref, \ datacon=\dontcare \ \}$
\item $eqk \ = \ eqk\_ref$ \ if $eqk_i=EQ$ for all $i$. \ Otherwise, $eqk\ = \ NONEQ$.
\end{itemize}
\end{itemize}

\ruleone{eq-polyty}
   { 
%% $\kindingType{\extend{\env}{\btvenv}}{\ty}{eqk}$ 
   }
   { $\kindingType{\env}{POLYty \ \{boundtvars=\btvenv, \ body=\ty\}}{NONEQ}$ }

\ruleone{eq-boxedty}
   { }
   { $\kindingType{\env}{BOXEDty}{NONEQ}$ } 

\ruleone{eq-atomty}
   { }
   { $\kindingType{\env}{ATOMty}{NONEQ}$ } 

\ruleone{eq-indexty}
   { $\kindingType{\env}{\ty}{REC \ fieldtys}$ \ \ \ 
     $fieldtys (l) \ = \ \ty'$ \ \ \ 
     $\kindingType{\env}{\ty'}{eqk}$ }
   { $\kindingType{\env}{INDEXty \ (\ty,l)}{eqk}$ } 

\ruleone{eq-bmsabsty}
   { }
   { $\kindingType{\env}{BMSABSty \ (\tys,\ty)}{NONEQ}$ }

\ruleone{eq-bitmapty}
   { }
   { $\kindingType{\env}{BITMAPty \ [ \ bitty_1, \ ... \ , \ bitty_n \ ]}{NONEQ}$ }

\ \\

\rulename{$\kindingType{\env}{\ty}{reck}$}

\begin{itemize}
\item A type $\ty$ has record-kind $reck$ under a bound-type-variable environment $\select{\env}{\btvenv}$.
\end{itemize}

\ruleone{rec-errorty}
   { }
   { $\kindingType{\env}{ERRORty}{UNIV}$ }

\ruleone{rec-dummyty}
   { }
   { $\kindingType{\env}{DUMMYty}{UNIV}$ } 

\ruleone{rec-tyvarty-tvar}
   { $tvkind \ = \ \{reckind=reck, \ eqkind=\dontcare\ , \ tyvarname=\dontcare\ , \ id=\dontcare\ \}$ }
   { $\kindingType{\env}{TYVARty \ (ref \ (TVAR \ tvkind))}{reck}$ }

\ruleone{rec-tyvar-subst}
   { $\kindingType{\env}{\ty}{reck}$ }
   { $\kindingType{\env}{TYVARty \ (ref \ (SUBSTITUTED \ \ty))}{reck}$ }

\ruleone{rec-boundvarty}
   { $\select{\env}{\btvenv} \ (i) \ = \ \{reckind=reck, \ eqkind=\dontcare,\ rank=\dontcare, \ index=\dontcare\ \}$ }
   { $\kindingType{\env}{BOUNDVARty \ i}{reck}$ }

\ruleone{rec-funty}
   { 
%%      $\kindingType{\env}{\ty_1}{reck_1}$ \ \ \ 
%%      $\kindingType{\env}{\ty_2}{reck_2}$ 
   }
   { $\kindingType{\env}{FUNty \ (\ty,\ty')}{UNIV}$ }

\ruleone{rec-iabsty}
   { 
%%      $\kindingType{\env}{\ty}{reck}$ \ \ \ 
%%      $\kindingType{\env}{\ty_i}{reck_i}$ \ \ \ 
%%      ($1 \leq i \leq $ the length of $\tys$)
   }
   { $\kindingType{\env}{IABSty \ (\tys,\ty)}{UNIV}$ }

\ruleone{rec-recordty}
   { 
%%      $\kindingType{\env}{\ty_i}{reck_i}$ 
   }
   { $\kindingType{\env}{RECORDty \ \{label_1 \mapsto \ty_1, ... , label_n \mapsto \ty_n\}}{REC \ \{label_1 \mapsto \ty_1, ... , label_n\mapsto \ty_n\}}$ }

%% \begin{itemize}
%% \item where
%% \begin{itemize}
%% \item $rek \ = \ REC \ \{label_1 \mapsto \ty_1, ... , label_n\mapsto \ty_n\}$
%% \end{itemize}
%% \end{itemize}


\ruleone{rec-conty}
   { 
%%      $\kindingType{\env}{\ty_i}{reck_i}$ \ \ \ 
%%      ($1 \leq i \leq $ the length of $\tys$) 
   }
   { $\kindingType{\env}{CONty \ \{tycon=tycon, \ args=\tys\}}{UNIV}$ }

%% \begin{itemize}
%% \item where
%% \begin{itemize}
%% \item $tycon \ = \ \{name=..., arity=..., id=..., eqkind=eqk\_ref, \ datacon=... \}$
%% \item $eqk \ = \ eqk\_ref$ \ if $eqk_i=EQ$ for all $i$. \ Otherwise, $eqk\ = \ NONEQ$.
%% \end{itemize}
%% \end{itemize}

\ruleone{rec-polyty}
   { 
%% $\kindingType{\extend{\env}{\btvenv}}{\ty}{reck}$ 
   }
   { $\kindingType{\env}{POLYty \ \{boundtvars=\btvenv, \ body=\ty\}}{UNIV}$ }

\ruleone{rec-boxedty}
   { }
   { $\kindingType{\env}{BOXEDty}{UNIV}$ } 

\ruleone{rec-atomty}
   { }
   { $\kindingType{\env}{ATOMty}{UNIV}$ } 

\ruleone{rec-indexty}
   { $\kindingType{\env}{\ty}{REC \ fieldtys}$ \ \ \ 
     $fieldtys(l) \ = \ \ty'$ \ \ \ 
     $\kindingType{\env}{\ty'}{reck'}$ }
   { $\kindingType{\env}{INDEXty \ (\ty,l)}{reck'}$ } 

\ruleone{rec-bmsabsty}
   { }
   { $\kindingType{\env}{BMSABSty \ (\tys,\ty)}{UNIV}$ }

\ruleone{rec-bitmapty}
   { }
   { $\kindingType{\env}{BITMAPty \ [ \ bitty_1, \ ... \ , \ bitty_n \ ]}{UNIV}$ }

\subsubsection{Type instantiations}

\rulename{$eqk \ \leq \ eqk'$}

\begin{itemize}
\item $eqk \leq eqk'$ permits the substitution of a bound type
variable of eqkind $eqk$ with a type of eqkind $eqk'$.
\end{itemize}

\axiom{ee}{$EQ \ \leq \ EQ$}

\axiom{ne}{$NONEQ \ \leq \ EQ$}

\axiom{nn}{$NONEQ \ \leq \ NONEQ$}

\rulename{$reck \ \leq \ reck'$}

\begin{itemize}
\item $reck \leq reck'$ permits the substitution of a bound type variable of reckind $reck$ with a type of reckind $reck'$.
\end{itemize}

\axiom{uu}{$UNIV \ \leq \ UNIV$}

\axiom{ur}{$UNIV \ \leq \ REC \ \fieldtys$}

\axiom{rr}
%%    { 
%% %%      $\fieldtys=\{label_1\mapsto\ty_1,...,label_n\mapsto\ty_n\}$ \ \ \ 
%% %%      $\fieldtys'=\{label_1\mapsto\ty_1,...,label_n\mapsto\ty_n, \ ...\ \}$ 
%%    } 
   { $REC \ \{label_1\mapsto\ty_1,...,label_n\mapsto\ty_n\}
      \ \leq \ REC \ 
      \{label_1\mapsto\ty_1,...,label_n\mapsto\ty_n, \ ...\ \}$ }

%% \axiom{ou}{$OVERLOADED \ \tys \ \leq \ UNIV$}

%% where
%% \begin{itemize}
%% \item The rule (ou) does not guarantee that the type of kind $UNIV$ is one
%% of $\tys$.
%% \end{itemize}

\rulename{$\instantiate{\env}{\ty}{\tys}{\ty'}$}

\ruletwo{inst-poly}
   { $\wellformedType{\env}{POLYty \ (btvenv,\ty)}$ \ \ \ 
     $\wellformedType{\env}{\tys}$ }
   { $\kindingType{\env}{\ty_i}{eqk_i'}$ \ \ \ 
     $\kindingType{\env}{\ty_i}{reck_i'}$ \ \ \ 
     ($1\leq i \leq n$) }
   { $\instantiate{\env}{POLYty \ (btvenv,\ty)}{\tys}{\ty[\ty_1/btv_1,...,\ty_n/btv_n]}$ }

\begin{itemize}
\item where
\begin{itemize}
\item $\tys \ = \ [\ty_1, \ ... \ , \ty_n]$
\item $\btvenv \ = \ \{ 1\mapsto btv_1, \ ... \ , n\mapsto btv_n\}$
\item $btv_i \ = \ \{reckind=reck_i, \ eqkind=eqk_i, \ rank=\dontcare, \ index=\dontcare\  \}$
\item $eqk_i \leq eqk_i'$ \ and \ $reck_i \leq reck_i'$ \ \ \ for all $i$ 
\end{itemize}
\end{itemize}

\ruleone{inst-mono}
   { $\wellformedType{\env}{\ty}$ \ \ \ 
     $\ty$ is not $POLYty \ (\dontcare, \ \dontcare)$}
   { $\instantiate{\env}{\ty}{[]}{\ty}$ }

\rulename{$\overload{\env}{\ty}{\tys}{\ty'}$}

\ruletwo{overload-poly}
   { $\wellformedType{\env}{POLYty \ (btvenv,\ty)}$ \ \ \ 
     $\wellformedType{\env}{\tys}$ }
   { $\kindingType{\env}{\ty_i}{eqk_i'}$ \ \ \ 
     $\ty_i \ \in \ \tys_i$ \ \ \ 
     ($1\leq i \leq n$) }
   { $\overload{\env}{POLYty \ (btvenv,\ty)}{\tys}{\ty[\ty_1/btv_1,...,\ty_n/btv_n]}$ }

\begin{itemize}
\item where
\begin{itemize}
\item $\tys \ = \ [\ \ty_1, \ ... \ , \ty_n \ ]$
\item $\btvenv \ = \ \{ 1\mapsto btv_1, \ ... \ , n\mapsto btv_n\}$
\item $btv_i \ = \ \{reckind=OVERLOADED \ \tys_i, \ eqkind=eqk_i, \ rank=\dontcare,\  index=\dontcare\  \}$
\item $eqk_i \leq eqk_i'$ \ \ \ for all $i$ 
\end{itemize}
\end{itemize}

\ruleone{overload-mono}
   { $\wellformedType{\env}{\ty}$ \ \ \ 
     $\ty$ is not $POLYty \ (\dontcare, \ \dontcare)$}
   { $\instantiate{\env}{\ty}{[]}{\ty}$ }


\subsubsection{Typing constants}

\rulename{$\typingConst{\env}{\constant}{\ty}$}

\ruleone{int}
      {}
      { $\typingConst{\env}{INTCONST \ i}{\intty}$ }
\begin{itemize}
\item where
\begin{itemize}
\item $intty \ = \ CONty \ \{ \ tycon=intTycon, \ args=[] \ \}$ 
\item $intTycon \ = \ \{ \ name=\mbox{``int''}, \ arity=0, \ id=\dontcare, \ eqkind=EQ \, ref, \ datacon=\{\} \, ref \ \}$
\item $\{ \}$ is an empty mapping.
\end{itemize}
\item $stringty$, $realty$, $charty$, and $wordty$ are similarly defined.
\end{itemize}

\ruleone{string}
      {}
      { $\typingConst{\env}{STRING \ s}{\stringty}$ }

\ruleone{real}
      {}
      { $\typingConst{\env}{REAL \ f}{\realty}$ }

\ruleone{char}
      {}
      { $\typingConst{\env}{CHAR \ c}{\charty}$ }

\ruleone{word}
      {}
      { $\typingConst{\env}{WORD \ w}{\wordty}$ }

\subsubsection{Typing expressions}

\rulename{$\typingConst{\env}{\expr}{\ty}$}

\ruleone{error}
    {}
    { $\typingExp{\env}{ERROR}{ERRORty}$ }

\ruleone{constant}
      { $\typingConst{\env}{c}{\ty}$ }
      { $\typingExp{\env}{CONSTANT \ c}{\ty}$ }

\ruleone{var}
      { $\envVarenv{id} \ = \ VARID \ \{name=id, \ ty=\ty\} $ }
      { $\typingExp{\env}{VAR \ (path, \ \{name=id, \ ty=\ty\})}{\ty}$ }

\begin{itemize}
\item $path \ ::= \ Pid \ string \ \ | \ \ Pdot \ (path, \ path)$
\end{itemize}

\ruleone{global}
      { $\envGenv{id} \ = \ VARID \ \{name=id, \ ty=\ty\} $ }
      { $\typingExp{\env}{GLOBAL \ (path, \ \{name=id, \ ty=\ty\})}{\ty}$ }

\ruletwo{primapply}
      { $\wellformedType{\env}{\ty}$ \ \ \ $\wellformedType{\env}{\tys}$}
      { $\instantiate{\env}{\ty}{\tys}{\ty_1}$ \ \ \ 
        $\typingExpOpt{\env}{\expropt}{\ty_1}{\ty_2}$ } 
      { $\typingExp{\env}{
            PRIMAPPLY \ 
               (\{name=id, \ ty=\ty\}, \ \tys, \ \expropt)}{\ty_2}$ }

\ruletwo{oprimapply}
      { $\wellformedType{\env}{\ty}$ \ \ \ 
        $\wellformedType{\env}{\tys}$ }
      { $\overload{\env}{\ty}{\tys}{\ty_1}$ \ \ \ 
        $\typingExpOpt{\env}{\expropt}{\ty_1}{\ty_2}$ } 
      { $\typingExp{\env}{
            OPRIMAPPLY \ 
               (\{name=id, \ ty=\ty\}, \ \tys, \ \expropt)}{\ty_2}$ }

%% (construct)

%% env |- polyty
%% env |- tylist
%% env |- INST (polyty, tylist) = ty
%% env |- expopt : ty ==> ty'
%% env={tcenv=tcenv,...}

%% coninfo={name=id,funtycon=funtycon,ty=polyty,
%%          exntag=exntag,tycon=tycon}
%% tycon  ={name=tyname,arity=arity,id=id,
%%          eqkind=eqkind_ref,datacon=datacon_ref}
%% tcenv (tyname) = TYCON tycon
%% datacon_ref (id) = CONID coninfo

%% # of bound type vars (polyty) = arity
%% funtycon=true  if expopt=SOME exp
%%         =false if expopt=NONE
%% ------------------------------------------------
%% env |- TPCONSTRUCT (coninfo,tylist,expopt) : ty'

%% N. This rule compares tycon with tcenv(tyname) implicitly.
%% N. This rule compares tycon with datacon_ref (id) implicitly.

%% Q. #tylist is not necessarily the same as #(boundtvars polyty)?
%%    The typechecker assumes either #(boundtvars polyty)=#tylist or 
%%    #tylist=0. That is, no polymorphic type is partially applied.

\ruletwo
   {construct}
   { $\wellformedType{\env}{\ty} \ \ \ 
      \wellformedType{\env}{\tys}$ }
   { $\instantiate{\env}{\ty}{\tys}{\ty_1}$ \ \ \ 
     $\typingExpOpt{\env}{\expropt}{\ty_1}{\ty_2}$ }
   { $\typingExp{\env}{CONSTRUCT \ (path, \ coninfo, \ \tys, \ \expropt)}{\ty_2}$ }

\begin{itemize}
\item where
\begin{itemize}
\item $coninfo \ = \ 
       \{ name=id, \ funtycon=funtycon, \ ty=\ty , \ 
          exntag=exntag, \ tycon=tycon \ \}$
\item $funtycon=true$ if $expopt=SOME \ \expr$, and
         $funtycon=false$ if $expopt=NONE$.
\item $tycon \ = \ 
       \{ name=tyname, \ arity=arity, \ id=id, \ eqkind=eqkind\_ref , \ 
          datacon=datacon\_ref \ \}$
\item $datacon\_ref \ (id) \ = \ CONID \ coninfo$
\item $\envTcenv{tyname} \ = \ TYCON \ tycon$
\end{itemize}
\end{itemize}

%% (app)

%% env |- ty1->ty2
%% env |- exp1 : ty1->ty2
%% env |- exp2 : ty1
%% --------------------------------------- 
%% env |- TPAPP (exp1,ty1->ty2,exp2) : ty2

\ruleone{app}
   { $\wellformedType{\env}{FUNty \ (\ty_1, \ty_2)}$ \ \ \ 
     $\typingExp{\env}{\expr_1}{FUNty \ (\ty_1, \ty_2)}$ \ \ \ 
     $\typingExp{\env}{\expr_2}{\ty_1}$ }
   { $\typingExp{\env}
                {APP \ (\expr_1, \ FUNty \ (\ty_1, \ty_2), \ \expr_2)}
                {\ty_1}$ }

%% (monolet)

%% env |- valbindlist : varenv
%% env @ varenv |- exp : ty 
%% --------------------------------------- 
%% env |- TPMONOLET (valbindlist,exp) : ty

\ruleone{monolet}
   { $\typingValBind{\env}{\valbinds}{\varenv}$ \ \ \ 
     $\typingExp{\extend{\env}{\varenv}}{\expr}{\ty}$ }
   { $\typingExp{\env}{MONOLET \ (\valbinds,\expr)}{\ty}$ }

%% (let)

%% env |- tylist
%% env |- decl : (tcenv, varenv)
%% env @ tcenv @ varenv |- explist : tylist
%% ------------------------------------------------ 
%% env |- TPLET (decl,explist,tylist) : last tylist

%% N. explist ::= [] | exp :: explist.

\ruletwo{let}
   { $\wellformedType{\env}{\tys}$ \ \ \ 
     $\typingDecl{\env}{\decl}{\tcenv}{\varenv}$}
   { $\typingExp{\extend{\extend{\env}{\tcenv}}{\varenv}}{\exprs}{\tys}$ } 
   { $\typingExp{\env}{LET \ (\decl,\exprs,\tys)}{last \ \tys}$ } 

\begin{itemize}
\item where
\begin{itemize}
\item $last \ \tys$ is the last element of $\tys$.
\end{itemize}
\end{itemize}

%% (record)

%% env |- ty
%% env |- fields : ty
%% ty = RECORDTy (_)
%% -------------------------------- 
%% env |- TPRECORD (fields,ty) : ty

\ruleone{record}
   { $\wellformedType{\env}{\ty}$ \ \ \ 
     $\typingExp{\env}{\fields}{\fieldtys}$ }
   { $\typingExp{\env}{RECORD \ (\fields,\ \ty)}{\ty}$ }

\begin{itemize}
\item where
\begin{itemize}
\item $\ty \ = \ RECORDty \ \fieldtys$
\item $\fields \ = \ \{label_1, \ \cdots, \ label_n\}$
\item $\fieldtys \ = \ \{label_1 \mapsto \ty_1 \cdots label_n\mapsto\ty_n\}$
\end{itemize}
\end{itemize}

%% (select)

%% env |- exp : ty
%% env |- ty : REC { label |-> ty' }
%% -------------------------------------- 
%% env |- TPSELECT (label, exp, ty) : ty'

%% N. env |- ty is implied by env |- ty : REC {label|->ty'}. Right?
%% N. ty is either a record type or a type variable that has a record kind.

\ruleone{select}
   { $\kindingType{\env}{\ty}{REC \ \{label \mapsto \ty'\}}$ \ \ \ 
     $\typingExp{\env}{\expr}{\ty}$ }
   { $\typingExp{\env}{SELECT \ (label, \ \expr, \ \ty)}{\ty'}$ }


%% (raise)

%% env |- exp : exn
%% ---------------------------- 
%% env |- TPRAISE (exp,ty) : ty

%% N. The type of TPRAISE exp is arbitrary, but it must be determined
%%    in a predictable way for the implementation of typechecker. 
%%    The functions checkExp, and etc have an extra parameter TY, which
%%    we will decide to assign the raise expression.

\ruleone{raise}
   { $\wellformedType{\env}{\ty}$ \ \ \ $\typingExp{\env}{\expr}{exnty}$ }
   { $\typingExp{\env}{RAISE \ (\expr, \ty)}{\ty}$ }

%% (handle)

%% env |- exp : ty
%% varenv = {id|->VARID {name=id,ty=exnty}}
%% env @ varenv |- exp' : ty
%% -------------------------------------------------- 
%% env |- TPHANDLE (exp,{name=id,ty=exnty},exp') : ty

%% N. exnty=CONty {tycon=exnTycon args=nil}

\ruleone{handle}
   { $\typingExp{\env}{\expr}{\ty}$ \\
     $\typingExp{\extend{\env}{VARID \ \{name=id,\ ty=exnty\}}}{\expr'}{\ty}$ }
   { $\typingExp{\env}{HANDLE \ (\expr,\{name=id, \ ty=exnty\},\expr')}{\ty}$ }

%% (case)

%% env |- ty
%% env |- ty'
%% env |- exp : tye
%% env |- patexplist : ty ==> ty'
%% ----------------------------------------------------
%% env |- TPCASE (exp,ty,patexplist,ty',casekind) : ty'

%% Q. casekind = BIND | MATCH | HANDLE
%%    What do we do with casekind in this rule?

\ruleone{case}
   { $\wellformedType{\env}{ty}$ \ \ \ 
     $\wellformedType{\env}{ty'}$ \ \ \ 
     $\typingExp{\env}{\expr}{\ty}$ \ \ \ 
     $\typingExpOpt{\env}{\patexprs}{\ty}{\ty'}$ }
   { $\typingExp{\env}{CASE \ (\expr,\ \ty, \ \patexprs, \ \ty', \ \casekind)}{\ty'}$ }

\begin{itemize}
\item where
\begin{itemize}
\item $casekind \ ::= \ BIND \ | \ MATCH \ | \ HANDLE$
\end{itemize}
\end{itemize}

%% (fn)

%% env |- ty'
%% varenv = {id|->VARID{name=id,ty=ty}}
%% env @ varenv |- exp : ty'
%% -----------------------------------------------------
%% env |- TPFN ({name=id,ty=ty},ty',exp) : ty'

\ruletwo{fn}
   { $\wellformedType{\env}{\ty}$ \ \ \ $\wellformedType{\env}{\ty'}$ }
   { $\typingExp{\extend{\env}{\{id \mapsto VARID \ \{name=id, \ ty=\ty\} \}}}{\expr}{\ty'}$ }
   { $\typingExp{\env}{FN \ (\{name=id, \ ty=\ty\}, \ \ty', \ \expr)}{\ty'}$ }

%% (polyfn)

%% env @ btvenv |- ty
%% varenv = {id |-> VARID {name=id,ty=ty}}
%% env @ btvenv @ varenv |- exp : ty'
%% polyty = POLYty{boundtvars=btvenv,body=FUNty(ty,ty')}
%% --------------------------------------------------------- 
%% env |- TPPOLYFN (btvenv,{name=id,ty=ty},ty',exp) : polyty 

%% N. "btvenv" has the same type as "btvenv'" so that we can merge them.
%% Q. We should check the well-formedness of btvenv too. 

\ruletwo{polyfn}
   { $\wellformedType{\extend{\env}{\btvenv}}{FUNty\ (\ty,\ \ty')}$ }
   { $\typingExp{\extend{\extend{\env}{btvenv}}
                {\{id \mapsto VARID \ \{name=id,ty=\ty\}\}}}
                {\expr}{\ty'}$ }
   { $\typingExp{\env}{POLYFN \ (\btvenv, \ \{name=id, \ ty=\ty\}, \ \ty', \ \expr)}{\ty_{poly}}$ }

\begin{itemize}
\item where
\begin{itemize}
\item $\ty_{poly} \ = \ POLYty \ \{boundtvars=\btvenv,body=FUNty \ (\ty,\ty') \}$
\end{itemize}
\end{itemize}

%% (poly)

%% env @ btvenv |- ty
%% env @ btvenv |- exp : ty
%% polyty = POLYty {boundtvars=btvenv,body=ty'}
%% -------------------------------------------- 
%% env |- TPPOLY (btvenv,ty,exp) : polyty

\ruleone{poly}
    { $\wellformedType{\extend{\env}{\btvenv}}{\ty}$ \ \ \ 
      $\typingExp{\extend{\env}{\btvenv}}{\expr}{\ty}$ }
    { $\typingExp{\env}{POLY \ (\btvenv,\ \ty, \ \expr)}
       {POLYty \ \{boundtvars=\btvenv, \ body=\ty'\}}$ }

%% (tapp)

%% env |- ty
%% env |- tylist
%% env |- exp : ty
%% env |- INST (ty, tylist) = ty'
%% ----------------------------------- 
%% env |- TPTAPP (exp,ty,tylist) : ty'

\ruletwo{tapp}
   { $\wellformedType{\env}{\ty}$ \ \ \ 
     $\wellformedType{\env}{\tys}$ }
   { $\typingExp{\env}{\expr}{\ty}$ \ \ \ 
     $\instantiate{\env}{\ty}{\tys}{\ty'}$ }
   { $\typingExp{\env}{TAPP \ (\expr,\ \ty, \ \tys)}{\ty'}$ }

%% (seq)

%% env |- expi : tyi
%% -------------------------------------------------- 
%% env |- TPSEQ ([exp1,...,expn],[ty1,...,tyn]) : tyn


\ruleone{seq}
   { $\typingExp{\env}{\exprs}{\tys}$ }
   { $\typingExp{\env}{SEQ \ (\ \exprs,\ \tys \ )}{last \ \tys}$ }

\begin{itemize}
\item where
\begin{itemize}
\item $last \ \tys$ is the last element of $\tys$.
\end{itemize}
\end{itemize}

\ \\

\rulename{ $\typingExp{\env}{\exprs}{\tys}$ }

%% (explist)

%% env |- expi : tyi
%% -----------------------------------------
%% env |- [..., expi, ...] : [..., tyi, ...]

\ruleone{explist}
   { $\typingExp{\env}{\expr_i}{\ty_i}$ \ \ $(i\leq i\leq n)$ }
   { $\typingExp{\env}{[\expr_1, \ ... \ , \ \expr_n]}{[\ty_1, \ ... \ , \ \ty_n]}$ }

\ \\

\rulename{$\typingExpOpt{\env}{\expropt}{\tau}{\tau'}$}

%% (none)

%% -----------------------
%% env |- NONE : ty ==> ty

\ruleone{none-exp}
   {}
   { $\typingExpOpt{\env}{NONE}{\ty}{\ty}$ }

%% (some-exp)

%% env |- exp : ty
%% -----------------------------------
%% env |- SOME exp : ty -> ty' ==> ty'

\ruleone{some-exp}
   { $\typingExp{\env}{\expr}{\ty}$ }
   { $\typingExpOpt{\env}{SOME \ \expr}{\ty}{\ty'}$ }

\subsubsection{Typing patterns}

\rulename{ $\typingPat{\env}{\pat}{\ty}{\varenv}$ }

%% (patwild)

%% env |- ty
%% ---------------------------- 
%% env |- TPPATWILD ty : ty, {}

\ruleone{patwild}
   { $\wellformedType{\env}{\ty}$ }
   { $\typingPat{\env}{PATWILD \ \ty}{\ty}{\{ \}}$ }


%% (patvar)

%% env |- ty
%% varenv = {id|->VARID varinfo}
%% --------------------------------------------------
%% env |- TPPATVAR ({name=id,ty=ty},loc) : ty, varenv

\ruleone{patvar}
   { $\wellformedType{\env}{\ty}$ }
   { $\typingPat{\env}{PATVAR \ (varinfo, \ loc)}{\ty}{\{id \mapsto VARID \ varinfo \}}$ }

\begin{itemize}
\item where
\begin{itemize}
\item $varinfo \ = \ \{name=id, \ ty=\ty\}$ 
\end{itemize}
\end{itemize}

%% (patconstant)

%% env |- c : ty
%% ------------------------------------ 
%% env |- TPPATCONSTANT (c,ty) : ty, {}

\ruleone{patconstant}
   { $\typingConst{\env}{c}{\ty}$ }
   { $\typingPat{\env}{PATCONSTANT \ (c,\ \ty)}{\ty}{\{\}}$ }

%% (patconstruct)

%% env |- ty
%% env |- polyty
%% env |- tylist
%% env |- INST (polyty, tylist) = ty
%% env |- patopt : ty' ==> ty, varenv'
%% env = {tcenv=tcenv,...}

%% coninfo={name=id,funtycon=funtycon,ty=polyty,
%%          exntag=exntag,tycon=tycon}
%% tycon  ={name=tyname,arity=arity,id=id,
%%          eqkind=eqkind_ref,datacon=datacon_ref}
%% tcenv (tyname) = TYCON tycon
%% datacon_ref (id) = CONID coninfo

%% # of bound type vars (polyty) = arity
%% funtycon=true  if patopt=SOME exp
%%         =false if patopt=NONE
%% ---------------------------------------------------------------
%% env |- TPPATCONSTRUCT (path, coninfo,tylist,patopt,ty) : ty, varenv'

\rulethree{patconstruct}
   { $\wellformedType{\env}{\ty}$ \ \ \ 
     $\wellformedType{\env}{\ty_{poly}}$ \ \ \ 
     $\wellformedType{\env}{\tys}$  }
   { $\instantiate{\env}{\ty_{poly}}{\tys}{\ty}$ }
   { $\typingPatOpt{\env}{\patopt}{\ty}{\ty'}{\varenv}$ }
   { $\typingPat{\env}{PATCONSTRUCT \ (path, \ coninfo, \ \tys, \ \patopt, \ \ty)}{\ty'}{\varenv}$ }

\begin{itemize}
\item where
\begin{itemize}
\item $coninfo \ = \ 
       \{ name=id, \ funtycon=funtycon, \ ty=\ty_{poly} , \ 
          exntag=exntag, \ tycon=tycon \ \}$
\item $funtycon=true$ if $expopt=SOME \ \expr$, and
         $funtycon=false$ if $expopt=NONE$.
\item $tycon \ = \ 
       \{ name=tyname, \ arity=arity, \ id=id, \ eqkind=eqkind\_ref , \ 
          datacon=datacon\_ref \ \}$
\item $datacon\_ref \ (id) \ = \ CONID \ coninfo$
\item $\envTcenv{tyname} \ = \ TYCON \ tycon$
\end{itemize}
\end{itemize}

%% (patrecord)

%% env |- ty
%% env |- patfields : fieldenv, varenv
%% env |- ty : REC fieldenv
%% ----------------------------------------------- 
%% env |- TPPATRECORD (patfields,ty) : ty, varenv

%% N. fieldenv is the same type as varenv. 
%% N. Note that ty is either a record type or a type variable whose
%%    record kind is REC {...}. 
%% N. May ty have more fields than varenv'?

\ruletwo{patrecord}
   { $\wellformedType{\env}{\ty}$ \ \ \ 
     $\kindingType{\env}{\ty}{REC \ \fieldenv}$ }
   { $\typingPat{\env}{\patfields}{\fieldenv}{\varenv}$ }
   { $\typingPat{\env}{PATRECORD \ (\patfields, \ \ty)}{\ty}{\varenv}$ }


%% (patlayered)

%% dom (varenv1) intersection dom (varenv2) = {}
%% env |- pat : ty, varenv1
%% env |- pat' : ty, varenv2
%% ------------------------------------------------------- 
%% env |- TPPATLAYERED (pat,pat') : ty, varenv1 @ varenv2

%% N. pat=TPPATVAR (TPPATVAR (varinfo,loc),...).

\ruleone{patlayered}
   { $\typingPat{\env}{\pat_1}{\ty}{\varenv_1}$ \ \ \ 
     $\typingPat{\env}{\pat_2}{\ty}{\varenv_2}$ }
   { $\typingPat{\env}{PATLAYERED \ (\pat_1, \pat_2)}{\ty}{\extend{\varenv_1}{\varenv_2}}$ }

\begin{itemize}
\item where
\begin{itemize}
\item $\pat_1 \ = \ PATVAR \ (varinfo, \ loc)$
\item $dom(\varenv_1) \ \cap \ dom(\varenv_2) \ = \ \emptyset$
\end{itemize}
\end{itemize}

\ \\

\rulename{$\typingPatOpt{\env}{\patopt}{\ty}{\ty'}{\varenv}$}

%% (pat-none)

%% -------------------------------------------------- 
%% env |- NONE : ty ==> ty, {}

\ruleone{pat-none}
   {}
   { $\typingPatOpt{\env}{NONE}{\ty}{\ty}{\{\}}$ }

%% (pat-some)

%% env |- pat : ty, varenv'
%% -------------------------------------------- 
%% env |- SOME pat : ty-> ty'  ==> ty', varenv'

\ruleone{pat-some}
   { $\typingPat{\env}{\pat}{\ty}{\varenv}$ }
   { $\typingPatOpt{\env}{SOME \ \pat}{FUNty \ (\ty,\ty')}{\ty'}{\varenv}$ }

\ \\

\rulename{$\typingPatFields{\env}{\patfields}{\fieldtys}{\varenv}$}

\ruleone{patfields}
   { $\typingPat{\env}{\pat_i}{\ty_i}{\varenv_i}$ \ \ \ $(1\leq i \leq n)$}
   { $\typingPatFields{\env}{\{label_1=\pat_1,...,label_n=\pat_n\}}{\{label_1=\ty_1,...,label_n=\ty_n\}}{\varenv}$ }

\begin{itemize}
\item where
\begin{itemize}
\item $dom(\varenv_i) \ \cap \ dom(\varenv_j) \ = \ \emptyset$ \ \ for any $i,j$.
\item $\varenv \ = \ \varenv_1 \cup \ ... \ \cup \varenv_n$
\end{itemize}
\end{itemize}

\ \\

\rulename{$\typingPatExp{\env}{\pat}{\expr}{\ty}{\ty'}$}

\ruleone{patexp}
   { $\typingPat{\env}{\pat}{\ty}{\varenv}$ \ \ \ 
     $\typingExp{\extend{\env}{\varenv}}{\expr}{\ty'}$ }
   { $\typingPatExp{\env}{\pat}{\expr}{\ty}{\ty'}$ }


\ruleone{patexps}
   { $\typingPatExp{\env}{\pat_i}{\expr_i}{\ty}{\ty'}$ \ \ \
     $1 \leq i \leq n$ }
   { $\typingPatExps{\env}{[(\pat_1,\expr_1), \ ... \ ,(\pat_n,\expr_n)]}{\ty}{\ty'}$ }

\ \\

\rulename{$\typingFields{\env}{\fields}{\fieldtys}$}

\ruleone{fields}
   { $\typingExp{\env}{\expr_i}{\ty_i}$ \ \ \ 
     $1 \leq i \leq n$ }   
   { $\typingFields{\env}{\{label_1 \mapsto \expr_1, \ ... \ , label_n \mapsto \expr_n\}}{\{label_1 \mapsto \ty_1, \ ... \ , label_n \mapsto \ty_n\}}$ }


\subsubsection{Typing declarations}

\rulename{$\typingDecl{\env}{\decl}{\tcenv}{\varenv}$}


%% (val)

%% varinfoi={name=idi,ty=tyi}
%% env |- expi : tyi
%% ---------------------------------------
%% env |- VAL [...,(varinfoi,expi),...] 
%%     : {},{...,idi|->VARID varinfoi,...}

\ruleone{val}
   { $\wellformedType{\env}{\ty_i}$ \ \ \ 
     $\typingExp{\env}{\expr_i}{\ty_i}$ \ \ \ 
     $(1 \leq i \leq n)$ }
   { $\typingDecl{\env}{VAL \ binds}{\{\}}{\varenv}$ }

\begin{itemize}
\item where
\begin{itemize}
\item $binds \ = \ [(varinfo_1,\expr_1), ..., (varinfo_n,\expr_n)]$
\item $varinfo_i \ = \ \{name=id_l, \ ty=\ty_i\}$ 
\item $\varenv \ = \ \{id_1\mapsto VARID \ varinfo_1, \ ... \ , id_n\mapsto VARID \ varinfo_n\}$
\end{itemize}
\end{itemize}

%% (valrec)

%% varinfoi={name=idi,ty=tyi}
%% env |- tyi
%% env @ [..., (idi,VARID varinfoi), ...] |- expi : tyi
%% ----------------------------------------------------
%% env |- VALREC [...,(varinfoi,tyi,expi),...] 
%%     : {},{...,idi|->varinfoi,...}

\ruleone{valrec}
   { $\wellformedType{\env}{\ty_i}$ \ \ \ 
     $\typingExp{\extend{\env}{\varenv}}{\expr_i}{\ty_i}$ \ \ \ 
     $(1 \leq i \leq n)$ }
   { $\typingDecl{\env}{VALREC \ recbinds}{\{\}}{\varenv}$ }

\begin{itemize}
\item where
\begin{itemize}
\item $recbinds \ = \ [(varinfo_1,\ty_i,\expr_1), ..., (varinfo_n,\ty_i,\expr_n)]$
\item $varinfo_i \ = \ \{name=id_l, \ ty=\ty_i\}$ 
\item $\varenv \ = \ \{id_1\mapsto VARID \ varinfo_1, \ ... \ , id_n\mapsto VARID \ varinfo_n\}$
\end{itemize}
\end{itemize}


%% (valpolyrec)

%% varinfoi={name=idi,ty=tyi}
%% env @ btvenv |- tyi
%% env @ btvenv @ [..., (idi,VARID varinfoi), ...] |- expi : tyi
%% -------------------------------------------------------------
%% env |- VALPOLYREC (btvenv,[...,(varinfoi,tyi,expi),...]) 
%%     : {},{...,idi|->varinfoi,...}

\ruleone{valpolyrec}
   { $\wellformedType{\extend{\env}{\btvenv}}{\ty_i}$ \ \ \ 
     $\typingExp{\extend{\env}{\varenv}}{\expr_i}{\ty_i}$ }
   { $\typingDecl{\env}{VALPOLYREC \ (btvenv, \ polyrecbinds)}{\{\}}{varenv}$ }

\begin{itemize}
\item where
\begin{itemize}
\item $polyrecbinds \ = \ [(varinfo_1,\ty_1,\expr_1),...,(varinfo_n,\ty_n,\expr_n)]$
\item $varinfo_i \ = \ \{name=id_l, \ ty=\ty_i\}$ 
\item $\varenv \ = \ \{id_1\mapsto VARID \ varinfo_1, \ ... \ , id_n\mapsto VARID \ varinfo_n\}$
\end{itemize}
\end{itemize}


%% (localdec)

%% env |- decllist1 : tcenv1, varenv1
%% env @ btvenv1 @ varenv1 |- decllist2 : tcenv2, varenv2
%% -------------------------------------------------------
%% env |- LOCALDEC (decllist1,decllist2) : tcenv2, varenv2

\ruletwo{localdec}
   { $\typingDecl{\env}{\decls_1}{\tcenv_1}{\varenv_1}$ }
   { $\typingDecl{\extend{\extend{\env}{\tcenv_1}}{\varenv_1}}{\decls_2}{\tcenv_2}{\varenv_2}$ }
   { $\typingDecl{\env}{LOCALDEC \ (\decls_1,\decls_2)}{\tcenv_2}{\varenv_2}$ }


%% (datadec)

%% tycon_i = {name=tyname_i, arity=arity_i, id=id_i, 
%%           eqkind=eqkindref_i, datacon=dataconref_i}
%% dataconref_i=[..., CONID coninfo_j, ...]
%% eqkindref_i = EQ    if for all j. polyty_j admits equality
%%             = NONEQ otherwise
%% coninfo_j = {name=id_j, ty=polyty_j, funtycon=funtycon_j, 
%%              exntag=exntag_j, tycon=tycon_j}

%% # of bound type vars (polyty_j) = arity
%% funtycon_j=true  if polyty_j is a (polymorphic) function type
%%           =false otherwise
%% exntag_j=???
%% tycon_i=tycon_j for all j.
%% -------------------------------------------------------------
%% env |- DATADEC [..., tycon_i, ...] 
%%     : {...,id_i|->CONID tycon_i,...}, {}

%% Q. How do we check the well-formedness of each tyconi?
%% Q. What is exntag_j in datatype declaration?
%% Q. There is a problem on the part of eqkindref_i.
%%    We may need a different interpretation on the eqkind of 
%%    a datatype. NONEQ means that we do not allow to use = on
%%    all values of this datatype, and EQ means that we allow 
%%    to use = on all values of this datatype. 

\ruleone{datadec}
   { }
   { $\typingDecl{\env}{DATADEC \ [tycon_1, ... , tycon_n]}{\tcenv}{\{\}}$ }

\begin{itemize}
\item where
\begin{itemize}
\item $\tcenv \ = \ \{id_1\mapsto TYCON \ tycon_1, ... ,  id_n\mapsto TYCON \ tycon_n\}$
\item $tycon_i \ = \ \{name=tyname_i, \ arity=arity_i, \ id=id_i, \ eqkind=eqkind\_ref_i, \ datacon=datacon\_ref_i \}$ \ \ \ for $1 \leq i \leq n$
\item $datacon\_ref_i \ = \ [CONID \ coninfo_1, \ ..., \ CONID \ coninfo_m]$
\item $coninfo_j \ = \ \{name=id_j, \ ty=\ty_j, \ funtycon=functycon_j, \ exntag=false, \ tycon=tycon_j  \}$ \ \ \ for $1 \leq j \leq n$
\item $eqkind\_ref_i \ = \ EQ$ if all $\ty_j$ admit equality.
Otherwise, $eqkind\_ref_i \ = \ NONEQ$.
\item the number of bound type vars of $\ty_j$ \ $=$ \ $arity_i$
\item $funtycon_j \ = \ true$ if $\ty_j$ is a (polymorphic) function type. Otherwise, $funtycon_j \ = \ false$.
\item $tycon_i \ = \ tycon_j$ for all $j$
\end{itemize}
\end{itemize}

%% (datarepdec)

%% ---------------------------------
%% env |- DATAREPDEC (s,s') : {}, {}

\ruleone{datarepdec}
   {}
   { $\typingDecl{\env}{DATAREPDEC \ (s,s')}{\{\}}{\{\}}$ }

%% (exndec)

%% coninfos = [..., coninfoi, ...]
%% coninfoi = {name=idi,funtycon=_,ty=tyi,exntag=_,tycon=_}
%% varenv = {..., idi|->VARID{name=idi,ty=tyi}, ...}
%% --------------------------------------------------------
%% env |- EXNDEC coninfos : {}, varenv


\ruleone{exndec}
   {}
   { $\typingDecl{\env}{EXNDEC \ [coninfo_1, ... , coninfo_n]}{\{\}}{\varenv}$ }

\begin{itemize}
\item where
\begin{itemize}
\item $coninfo_i \ = \ \{name=id_i, \ funtycon=funtycon_i\ , \ ty=\ty_i, \  exntag=true, \ tycon=tycon_i \}$
\item $funtycon_i = true$ if $\ty_i$ is a function type. Otherwise, $funtycon_i = false$.
\item Need to check the well-formedness of $tycon_i$ ?
\item $varenv \ = \ \{id_1\mapsto VARID \ \{name=id_1,ty=\ty_1\}, ..., id_n\mapsto VARID \ \{name=id_n,ty=\ty_n\}\}$
\end{itemize}
\end{itemize}

%% (exnrepdec)

%% --------------------------------
%% env |- EXNREPDEC (s,s') : {}, {}

\ruleone{datarepdec}
   {}
   { $\typingDecl{\env}{EXNREPDEC \ (s,s')}{\{\}}{\{\}}$ }

%% (type)

%% env={tcenv=tcenv,...}
%% tysyns={...,(tvars,id),...}
%% tcenv (id)=TYFUN {tyargs=_,body=_}
%% ----------------------------------
%% env |- TYPE tysyns : {}, {}

\ruleone{type}
   { }
   { $\typingDecl{\env}{TYPE \ tybindinfos}{\{\}}{\{\}}$ }

\begin{itemize}
\item $tybindinfos \ = \ [tybindinfo_1, \ ... \ , tybindinfo_n]$

\item $tybindinfo_i$ is either 
      $TYCON \ tycon$ or $TYFUN \ \{name:string,tyargs:btvenv,body:ty\}$.

%% \item $\envTcenv{id_i} \ = \ TYFUN \ \{name=\ , tyargs=\ , body=\ \}$

\item Need to check the well-formedness of type declarations ?

\end{itemize}

\ \\

\rulename{$\typingDecl{\env}{\decls}{\tcenv}{\varenv}$}

\ruleone{decllist}
   { $\typingDecl{\env}{\decl_i}{\tcenv_i}{\varenv_i}$ \ \ \ 
     $(1 \leq i \leq n)$ }
   { $\typingDecl{\env}{[\decl_1, ..., \decl_n]}{\tcenv_1 \extendop \ ... \ \extendop \tcenv_n}{\varenv_1 \extendop \ ... \ \extendop \varenv_n}$ }

\end{document}

+---------------------------------------+
|A Typechecker Specification for TypedPL|
+---------------------------------------+


===================
Typing environments
===================

(environement)
env : tyckenv

  where
    tyckenv = {tcenv:tcenv,   genv:varenv,
               btvenv:btvenv, varenv:varenv }

    tcenv  ::= {..., con |-> tybindinfo, ... }
    genv   ::= {..., id  |-> idstate, ... }
    btvenv ::= {..., i   |-> btvkind, ... }
    varenv ::= {..., id  |-> idstate, ... }

    con = string
    id  = string
    i   = int

    tybindinfo ::= TYCON tycon 
                 | TYFUN {name:string,tyargs:btvenv,body:ty}

    tybindinfos = tybindinfo list

    tycon = { name : string, 
              arity : int, 
              id : int, 
              eqkind : eqkind ref, 
              datacon : varEnv ref}

    idstate ::= VARID varinfo    
              | CONID coninfo    
              | PRIM  priminfo

    varinfo ={name : string, ty : ty}
    priminfo={name : string, ty : ty}
    coninfo ={name : string, ty : ty, 
              funtycon : bool, exntag : int, 
              tycon : tycon}

    btvkind ={reckind : reckind, eqkind : eqkind, 
              rank : bool, index : int}

    eqkind = NONEQ | EQ

    reckind = UNIV | REC {..., labeli |-> tyi, ...}

    label = string

(environment extension)

env @ varenv   (implemented by extendVarEnv env varenv)
env @ btvenv   (implemented by extendBtvEnv env btvenv)
env @ tcenv    (implemented by extendTcEnv env tcenv)


=============
Kinding rules
=============

* env |- ty : (eqkind,reckind)

N. (IMPL.) (eqkind,reckind)= calcEqRecKind env ty


(tyvarty-tvar)

tvkind={id=_,reckind=reckind,
        eqkind=eqkind,tyvarname=_}
-----------------------------------------------------
env |- TYVARty (ref (TVAR tvkind)) : (eqkind,reckind)

N. We do not check well-formedness of types. 

(tyvar-subst)

env |- ty : (eqkind,reckind)
-------------------------------------------------------- 
env |- TYVARty (ref (SUBSTITUTED ty)) : (eqkind,reckind)

(boundvarty)

env = {btvenv=btvenv,...}
btvenv (i) = {reckind=reckind,eqkind=eqkind,rank=_,index=_}
----------------------------------------------------------- 
env |- BOUNDVARty i : (EQ,reckind)

(boundvarty)

env |- ty1 : (eqkind1,reckind1)
env |- ty2 : (eqkind2,reckind2)
-------------------------------------
env |- FUNty (ty1,ty2) : {NONEQ,UNIV}

(iabsty)

env |- tylist : [...,(eqkindi,reckindi),...]
env |- ty : (eqkind,reckind)
--------------------------------------------
env |- IABSty (tylist,ty) : (NONEQ,UNIV)

(recordty)

btvenv |- tyi : (eqki,recki)
eqk = EQ    if for all i. eqk_i=EQ
    = NONEQ otherwise
rek = REC{...,li|->tyi,...}
------------------------------------------------
env |- RECORDty {..., li|->tyi, ...} : (eqk,rek)

(conty)

tycon={arity=arity,eqkind=eqkind,...}
arity = #tylist
env |- tylist : [...,(eqkind_i,reckind_i),...]
eqk = eqkind if all i. eqkind_i=EQ
      NONEQ  otherwise
---------------------------------------------------
env |- CONty {tycon=tycon,args=tylist} : (eqk,UNIV)

(polyty)

env @ btvenv |- ty : (eqkind,reckind)
----------------------------------------------------------
env |- POLYty {boundtvars=btvenv, body=ty} : (NONEQ,UNIV)

(dummyty)

-----------------------------
env |- DUMMYty : (NONEQ,UNIV)

(boxedty)

-----------------------------
env |- BOXEDty : (NONEQ,UNIV)

(atomty)

----------------------------
env |- ATOMty : (NONEQ,UNIV)

(indexty)

env |- ty : {eqkind=eqkind,reckind=REC fieldtys}
(label|->ty') is included in fieldtys
env |- ty' : (eqkind',reckind')
------------------------------------------------
env |- INDEXty (ty,label): (eqkind',reckind')

(bmsabsty)

env |- tylist : tykindlist
env |- ty : tykind
----------------------------------------
env |- BMABSty (tylist,ty): (NONEQ,UNIV)

(bitmapty)

true                          if bittyi=DC
env |- tyi : (eqkind,reckind) if bittyi=TRACE tyi
-------------------------------------------------
env |- BITMAPty [..., bittyi,... ] : (NONEQ,UNIV)


================
Well-formed type
================

* env |- ty    
* env |- tys  

N. (IMPL.)  _ = checkType env ty
N. (IMPL.)  _ = checkTypes env tys


(types-[])

---------
env |- []

(types-::)

env |- ty
env |- tys
--------------
env |- ty::tys

(tyvarty-substituted)

env |- ty
-------------------------------------
env |- TYVARty (ref (SUBSTITUTED ty)) 

(tyvarty-tvar)

tvkind={id=id,reckind=reckind,
        eqkind=eqkind, tyvarname=stringopt}
true                 if reckind=UNIV
forall i. env |- tyi if reckind=REC {...,li|->tyi ...}
------------------------------------------------------
env |- TYVARty (ref (TVAR tvkind)) 

N. It is not clear why we do need this rule.

(boundvarty)

env = {btvenv=btvenv,...}
btvenv (i) = {reckind=reckind,
              eqkind=eqkind,rank=bool,index=int}
true                 if reckind=UNIV
forall i. env |- tyi if reckind=REC {...,li|->tyi ...}
------------------------------------------------------
env |- BOUNDVARTY i

(funty)

env |- ty1
env |- ty2
----------------------
env |- FUNty (ty1,ty2)

(iabsty)

env |- ty1
env |- ty2
----------------------
env |- IABSty (tys,ty2)

(recordty)

env |- tyi
----------------------------------
env |- RECORDty {...,li|->tyi,...}

N. Unique labels.

(conty)

env |- tys
-----------------------------------
env |- CONty {tycon=tycon,args=tys}

Q. We leave tycon unchecked. Do we need to maintain a list of
   "varEnv ref"-typed values? We can check well-formedness of
    tycon by looking for "#datacon tycon" in the list if we
    have such a list.

(polyty)

env @ btvenv |- ty
-----------------------------------------
env |- POLYty {boundtvars=btvenv,body=ty}

(dummyty)

--------------
env |- DUMMYty

(boxedty)

--------------
env |- BOXEDty

(atomty)

--------------
env |- ATOMty

(indexty)

env |- ty
-------------------------
env |- INDEXty (ty,label)

(bmabsty)

env |- ty
env |- tys
-----------------------
env |- BMABSty (tys,ty)

(bitmapty)

true      if bittyi=DC
env |- ty if bittyi=TRACE ty
----------------------------------
env |- BITMAPty [..., bittyi, ...]


=============
Instantiation
=============

* env |- INST (ty,tylist) = ty'

(inst-poly)

env |- POLYty (btvenv,ty)
env |- tylist
tylist=[ty1,      ..., tyn]
btvenv=[1|->btv1, ..., n|->btvn]
env |- tyi : (eqkindi,reckindi)
for all i. #eqkind  btvi <= eqkindi 
           #reckind btvi <= reckindi
----------------------------------------
env |- INST (POLYty (btvenv,ty), tylist) 
    =  ty [ty1/btv1,...,tyn/btvn]

N. ty [tylist/btvenv] is implemented by 
   "TypesUtils.substBTvar subst ty" where
   "subst" is [ty1/btv1,...,tyn/btvn].

(inst-mono)

env |- ty
ty <> POLYty (_,_)
------------------------- 
env |- INST (ty, []) = ty

===============
Kind Inequality
===============

(eqkind)

EQ    <= EQ
EQ    <= NONEQ
NONEQ <= EQ
NONEQ <= NONEQ

N. (IMPL.) leqEqKind eqkind1 eqkind2

(reckind)

UNIV <= UNIV
UNIV <= REC fieldtys

fieldtys1={l1|->ty1,...,ln|->tyn}
fieldtys2={l1|->ty1,...,ln|->tyn,ln+1|->tyn+1,...}
--------------------------------------------------
REC fieldtys1 <= REC fieldtys2

N. (IMPL.) leqRecKind reckind1 reckind2

============
Typing rules
============

@(CONST) 
* env |- const : ty


------------------------- (int)  
env |- INTCONST i : intty

-------------------------- (string) 
env |- STRING s : stringty

---------------------- (real)
env |- REAL f : realty

---------------------- (char)
env |- CHAR c : charty

---------------------- (word)
env |- WORD w : wordty




@(EXPR) 
* env |- exp : ty

(constant)

env |- c : ty
---------------------- 
env |- CONSTANT c : ty

(var)

env = {varenv=varenv, ...}
varenv (id) = VARID {name=id, ty=ty}
------------------------------------
env |- VAR {name=id, ty=ty} : ty

N. The implementation didn't check the equality of ids. 

(global)

env = {genv=genv, ...}
genv (id) = VARID {name=id, ty=ty}
----------------------------------- 
env |- GLOBAL {name=id, ty=ty} : ty

(primapply)

env |- polyty
env |- tylist
env |- INST (polyty, tylist) = ty
env |- expopt : ty ==> ty'
---------------------------------------------------------- 
env |- PRIMAPPLY ({name=id,ty=polyty},tylist,expopt) : ty'

N. expopt ::= NONE | SOME exp

(construct)

env |- polyty
env |- tylist
env |- INST (polyty, tylist) = ty
env |- expopt : ty ==> ty'
env={tcenv=tcenv,...}

coninfo={name=id,funtycon=funtycon,ty=polyty,
         exntag=exntag,tycon=tycon}
tycon  ={name=tyname,arity=arity,id=id,
         eqkind=eqkind_ref,datacon=datacon_ref}
tcenv (tyname) = TYCON tycon
datacon_ref (id) = CONID coninfo

# of bound type vars (polyty) = arity
funtycon=true  if expopt=SOME exp
        =false if expopt=NONE
------------------------------------------------
env |- TPCONSTRUCT (coninfo,tylist,expopt) : ty'

N. This rule compares tycon with tcenv(tyname) implicitly.
N. This rule compares tycon with datacon_ref (id) implicitly.

Q. #tylist is not necessarily the same as #(boundtvars polyty)?
   The typechecker assumes either #(boundtvars polyty)=#tylist or 
   #tylist=0. That is, no polymorphic type is partially applied.

(app)

env |- ty1->ty2
env |- exp1 : ty1->ty2
env |- exp2 : ty1
--------------------------------------- 
env |- TPAPP (exp1,ty1->ty2,exp2) : ty2

(monolet)

env |- valbindlist : varenv
env @ varenv |- exp : ty 
--------------------------------------- 
env |- TPMONOLET (valbindlist,exp) : ty

(let)

env |- tylist
env |- decl : (tcenv, varenv)
env @ tcenv @ varenv |- explist : tylist
------------------------------------------------ 
env |- TPLET (decl,explist,tylist) : last tylist

N. explist ::= [] | exp :: explist.

(record)

env |- ty
env |- fields : ty
ty = RECORDTy (_)
-------------------------------- 
env |- TPRECORD (fields,ty) : ty

(select)

env |- exp : ty
env |- ty : REC { label |-> ty' }
-------------------------------------- 
env |- TPSELECT (label, exp, ty) : ty'

N. env |- ty is implied by env |- ty : REC {label|->ty'}. Right?
N. ty is either a record type or a type variable that has a record kind.

(raise)

env |- exp : exn
---------------------------- 
env |- TPRAISE (exp,ty) : ty

N. The type of TPRAISE exp is arbitrary, but it must be determined
   in a predictable way for the implementation of typechecker. 
   The functions checkExp, and etc have an extra parameter TY, which
   we will decide to assign the raise expression.

(handle)

env |- exp : ty
varenv = {id|->VARID {name=id,ty=exnty}}
env @ varenv |- exp' : ty
-------------------------------------------------- 
env |- TPHANDLE (exp,{name=id,ty=exnty},exp') : ty

N. exnty=CONty {tycon=exnTycon args=nil}

(case)

env |- ty
env |- ty'
env |- exp : ty
env |- patexplist : ty ==> ty'
----------------------------------------------------
env |- TPCASE (exp,ty,patexplist,ty',casekind) : ty'

Q. casekind = BIND | MATCH | HANDLE
   What do we do with casekind in this rule?

(fn)

env |- ty'
varenv = {id|->VARID{name=id,ty=ty}}
env @ varenv |- exp : ty'
-----------------------------------------------------
env |- TPFN ({name=id,ty=ty},ty',exp) : ty'

(polyfn)

env @ btvenv |- ty
varenv = {id |-> VARID {name=id,ty=ty}}
env @ btvenv @ varenv |- exp : ty'
polyty = POLYty{boundtvars=btvenv,body=FUNty(ty,ty')}
--------------------------------------------------------- 
env |- TPPOLYFN (btvenv,{name=id,ty=ty},ty',exp) : polyty 

N. "btvenv" has the same type as "btvenv'" so that we can merge them.

(poly)

env @ btvenv |- ty
env @ btvenv |- exp : ty
polyty = POLYty {boundtvars=btvenv,body=ty'}
-------------------------------------------- 
env |- TPPOLY (btvenv,ty,exp) : polyty

(tapp)

env |- ty
env |- tylist
env |- exp : ty
env |- INST (ty, tylist) = ty'
----------------------------------- 
env |- TPTAPP (exp,ty,tylist) : ty'

(seq)

env |- expi : tyi
-------------------------------------------------- 
env |- TPSEQ ([exp1,...,expn],[ty1,...,tyn]) : tyn


@(PATTERN) 
* env |- pat : ty, varenv

(patwild)

btvenv |- ty
---------------------------- 
env |- TPPATWILD ty : ty, {}

(patvar)

env |- ty
varenv = {id|->VARID varinfo}
--------------------------------------------------
env |- TPPATVAR ({name=id,ty=ty},loc) : ty, varenv

(patconstant)

env |- c : ty
------------------------------------ 
env |- TPPATCONSTANT (c,ty) : ty, {}

(patconstruct)

env |- ty
env |- polyty
env |- tylist
env |- INST (polyty, tylist) = ty
env |- patopt : ty' ==> ty, varenv'
env = {tcenv=tcenv,...}

coninfo={name=id,funtycon=funtycon,ty=polyty,
         exntag=exntag,tycon=tycon}
tycon  ={name=tyname,arity=arity,id=id,
         eqkind=eqkind_ref,datacon=datacon_ref}
tcenv (tyname) = TYCON tycon
datacon_ref (id) = CONID coninfo

# of bound type vars (polyty) = arity
funtycon=true  if patopt=SOME exp
        =false if patopt=NONE
---------------------------------------------------------------
env |- TPPATCONSTRUCT (coninfo,tylist,patopt,ty) : ty, varenv'

(patrecord)

env |- ty
env |- patfields : fieldenv, varenv
env |- ty : REC fieldenv
----------------------------------------------- 
env |- TPPATRECORD (patfields,ty) : ty, varenv

N. fieldenv is the same type as varenv. 
N. Note that ty is either a record type or a type variable whose
   record kind is REC {...}. 
N. ty may have more fields than varenv'. There is a serious bug here.

(patlayered)

dom (varenv1) intersection dom (varenv2) = {}
env |- pat : ty, varenv1
env |- pat' : ty, varenv2
------------------------------------------------------- 
env |- TPPATLAYERED (pat,pat') : ty, varenv1 @ varenv2

N. pat=TPPATVAR (TPPATVAR (varinfo,loc),...).


(PatOption)

(pat-none)

-------------------------------------------------- 
env |- NONE : ty ==> ty, {}

(pat-some)

env |- pat : ty, varenv'
-------------------------------------------- 
env |- SOME pat : ty-> ty'  ==> ty', varenv'




@(PatFields)
* env |- patfields : fieldtys, varenv

(patfields)

dom (varenvi) intersection dom (varenvj) = {} for all pairs (i,j)
env |- pati : tyi, varenvi
--------------------------------------------------------------------
env |- {..., li=pati, ...} : {..., li:tyi, ...}, ... U varenvi U ...




@(PatExp)
* env |- pat : ty => ty'

(patexp)

env |- pat : ty, varenv
env @ varenv |- exp : ty'
------------------------------ 
env |- (pat, exp) : ty ==> ty'




@(PatExpList)
* env |- patexps : ty => ty'

(patexplist)

env |- patexpi : ty => ty'
---------------------------------------
env |- [..., patexpi, ...] : ty ==> ty'




@(ExpList)
* env |- exps : tys

(explist)

env |- expi : tyi
-----------------------------------------
env |- [..., expi, ...] : [..., tyi, ...]



@(ExpOption)
* env |- expopt : ty ==> ty'

(none)

-----------------------
env |- NONE : ty ==> ty

(some-exp)

env |- exp : ty
-----------------------------------
env |- SOME exp : ty -> ty' ==> ty'




@(Fields)
* env |- fields : fieldtys

(fields)

env |- expi : tyi
--------------------------------------------------------- 
env |- {..., idi |-> expi, ...} : {..., idi |-> tyi, ...}




@(DECL)
* env |- decl : tcenv,varenv

(val)

varinfoi={name=idi,ty=tyi}
env |- expi : tyi
---------------------------------------
env |- VAL [...,(varinfoi,expi),...] 
    : {},{...,idi|->VARID varinfoi,...}

(valrec)

varinfoi={name=idi,ty=tyi}
env |- tyi
env @ [..., (idi,VARID varinfoi), ...] |- expi : tyi
----------------------------------------------------
env |- VALREC [...,(varinfoi,tyi,expi),...] 
    : {},{...,idi|->varinfoi,...}

(valpolyrec)

varinfoi={name=idi,ty=tyi}
env @ btvenv |- tyi
env @ btvenv @ [..., (idi,VARID varinfoi), ...] |- expi : tyi
-------------------------------------------------------------
env |- VALPOLYREC (btvenv,[...,(varinfoi,tyi,expi),...]) 
    : {},{...,idi|->varinfoi,...}

(localdec)

env |- decllist1 : tcenv1, varenv1
env @ btvenv1 @ varenv1 |- decllist2 : tcenv2, varenv2
-------------------------------------------------------
env |- LOCALDEC (decllist1,decllist2) : tcenv2, varenv2

(datadec)

tycon_i = {name=tyname_i, arity=arity_i, id=id_i, 
          eqkind=eqkindref_i, datacon=dataconref_i}
env={tcenv=tcenv,...}
dataconref_i=[..., CONID coninfo_j, ...]
eqkindref_i = EQ    if for all j. polyty_j admits equality
            = NONEQ otherwise
coninfo_j = {name=id_j, ty=polyty_j, funtycon=funtycon_j, 
             exntag=exntag_j, tycon=tycon_j}

# of bound type vars (polyty_j) = arity
funtycon_j=true  if polyty_j is a (polymorphic) function type
          =false otherwise
exntag_j=???
tycon_i=tycon_j for all j.
-------------------------------------------------------------
env |- DATADEC [..., tycon_i, ...] 
    : {...,id_i|->CONID tycon_i,...}, {}

Q. How do we check the well-formedness of each tyconi?
Q. What is exntag_j in datatype declaration?
Q. There is a problem on the part of eqkindref_i.
   We may need a different interpretation on the eqkind of 
   a datatype. NONEQ means that we do not allow to use = on
   all values of this datatype, and EQ means that we allow 
   to use = on all values of this datatype. 

(datarepdec)

---------------------------------
env |- DATAREPDEC (s,s') : {}, {}

(exndec)

coninfos = [..., coninfoi, ...]
coninfoi = {name=idi,funtycon=_,ty=tyi,exntag=_,tycon=_}
varenv = {..., idi|->VARID{name=idi,ty=tyi}, ...}
--------------------------------------------------------
env |- EXNDEC coninfos : {}, varenv

Q. 

(exnrepdec)

--------------------------------
env |- EXNREPDEC (s,s') : {}, {}

(type)

env={tcenv=tcenv,...}
tysyns={...,(tvars,id),...}
tcenv (id)=TYFUN {name=_,tyargs=_,body=_}
----------------------------------
env |- TYPE tysyns : {}, {}

Q. Do we have to add something to tcenv?

@(DECLLIST)
* env |- decls : tcenv,varenv

(decllist)

env |- decl : tcenv1, varenv1
env @ tcenv1 @ varenv1 |- decllist : tcenv2, varenv2
---------------------------------------------------------- 
env |- decl::decllist : tcenv1 @ tcenv2, varenv1 @ varenv2

