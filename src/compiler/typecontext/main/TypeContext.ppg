(**
 *	
 * type context for type inference.
 * @copyright (c) 2006, Tohoku University.
 * @author Atsushi Ohori 
 * @author Liu Bochao
 * @author YAMATODANI Kiyoshi
 * @version $Id: TypeContext.ppg,v 1.16 2007/01/21 13:41:33 kiyoshiy Exp $
 *)
structure TypeContext =
struct
  local
    open Types Path
    structure TU = TypesUtils
    structure TY = Types
  in

  (* dupcliate specifiction *)
  exception exDuplicateElem of string

  (*%
   * @params(btvEnv)
   * @formatter(smapWithEnclosure) SmlppgUtil.formatSmapWithEnclosure
   * @formatter(formatIdState) Types.format_idState
   *)
  type typeContextVarEnv =
       (*%
        * @format(idState:formatIdState smap:smapWithEnclosure) 
        *    smap(idState()(btvEnv))(":", +1, ~2[1"valbinds"] + 1, "")
        *)
        idState SEnv.map

  (*************************************************************)

 (*%
   * @params(btvEnv)
   * @formatter(formatTcEnv) Types.format_tyConEnv
   * @formatter(formatvarEnv) Types.format_typeContextVarEnv
   * @formatter(formatstrEnv) Types.format_strEnv
   * @formatter(formatsigEnv) Types.format_sigEnv
   * @formatter(formatfunEnv) Types.format_funEnv
   * @formatter(formattyNameSet) Types.format_tyNameSet
   *)
  type context = 
       (*%
        * @format({tyConEnv:tyConEnv:formatTcEnv,
        *          varEnv:varEnv:typeContextVarEnv,
        *          strEnv:strEnv:formatstrEnv,
        *          sigEnv:sigEnv:formatsigEnv,
        *          funEnv:funEnv:formatfunEnv}) 
        *        "TYCONENV" +1 5[tyConEnv()(btvEnv)] +1 
        *        "VARENV" +1 5[varEnv()(btvEnv)] +1 
        *        "STRENV" +1 5[strEnv()(btvEnv)] +1 
        *        "SIGENV" +1 5[sigEnv()(btvEnv)] +1
        *        "FUNENV" +1 5[funEnv] +1
        *)
       {
        tyConEnv : tyConEnv,
        varEnv : varEnv,
        strEnv : strEnv,
        sigEnv : sigEnv,
        funEnv : funEnv
       }

  val emptyContext =
      {
        tyConEnv = TY.emptyTyConEnv,
        varEnv = TY.emptyVarEnv,
        strEnv = TY.emptyStrEnv,
        sigEnv = TY.emptySigEnv,
        funEnv = TY.emptyFunEnv
      } : context

  (**
   * @params (context, path, name)
   * @param context
   * @param path the path of the structure
   * @param name name of tyCon to search
   *)
  fun lookupLongTyCon ({tyConEnv, strEnv = STRUCTURE strPathInfoSEnv,...} : context, 
                       path, 
                       name) = 
      let
        fun lookUp (tyConEnv, strPathInfoSEnv) NilPath =
            SEnv.find(tyConEnv, name)
          | lookUp (tyConEnv, strPathInfoSEnv)  (PStructure(id, strid, path)) =
            (case SEnv.find(strPathInfoSEnv, strid) of 
               NONE => NONE
             | SOME({env = (tyConEnv, _, STRUCTURE strPathInfoSEnv), ...}) =>
                 lookUp (tyConEnv, strPathInfoSEnv) path
            )
      in
        case lookUp (tyConEnv, strPathInfoSEnv) path of
          NONE => 
          let 
            val newpath = PStructure(topStrID, topStrName, path)
          in
            (newpath, lookUp (tyConEnv, strPathInfoSEnv) newpath)
          end
        | tyConoption => (path, tyConoption)
      end

  (**
   * @params (context, path, name)
   * @param context
   * @param path the path of the structure
   * @param name name of variable to search
   *)
  fun lookupLongVar ({strEnv = STRUCTURE strPathInfoSEnv, varEnv,...} : context, 
                     path, 
                     name) =
      let
        fun lookUp (varEnv, strPathInfoSEnv) NilPath = 
            SEnv.find(varEnv, name)
          | lookUp (varEnv, strPathInfoSEnv) (PStructure(strid, strName, path)) =
            (case SEnv.find(strPathInfoSEnv, strName) of 
               NONE => NONE
             | SOME( {env = (_, varEnv, STRUCTURE strPathInfoSEnv), ...}) =>
               lookUp (varEnv, strPathInfoSEnv) path)
      in
        case lookUp (varEnv, strPathInfoSEnv) path of
          NONE => 
            let 
              val newpath = PStructure(topStrID, topStrName, path)
            in
              (newpath, lookUp (varEnv, strPathInfoSEnv) newpath)
            end
        | Varoption => (path, Varoption)
      end

  fun lookupLongStructure ({strEnv = STRUCTURE strPathInfoSEnv,...}:context, path) =
      let 
        fun lookUp _ NilPath = 
            raise Control.Bug "NilPath in lookupLongStructure"
          | lookUp strPathInfoSEnv (PStructure(strid, strName, NilPath)) =
            (case (SEnv.find(strPathInfoSEnv,strName)) of
               NONE => NONE
             | SOME( strPathInfo) => SOME strPathInfo)
          | lookUp strPathInfoSEnv (PStructure(strid, strName, path)) = 
            (case SEnv.find(strPathInfoSEnv, strName) of
               NONE => NONE
             | SOME({env = (_, _, STRUCTURE strPathInfoSEnv), ...}) =>
                 lookUp strPathInfoSEnv path)
      in
        case lookUp strPathInfoSEnv path of
          NONE => 
            let 
              val newpath = PStructure(topStrID, topStrName, path)
            in
              (newpath, lookUp strPathInfoSEnv newpath)
            end
        | x => (path, x)
      end

   fun injectTyConEnvToContext tyConEnv = 
      {
        tyConEnv = tyConEnv,
        varEnv = TY.emptyVarEnv,
        strEnv = TY.emptyStrEnv,
        sigEnv = TY.emptySigEnv,
        funEnv = TY.emptyFunEnv
      } 

   fun injectVarEnvToContext varEnv = 
      {
        tyConEnv = TY.emptyTyConEnv,
        varEnv = varEnv,
        strEnv = TY.emptyStrEnv,
        sigEnv = TY.emptySigEnv,
        funEnv = TY.emptyFunEnv
      } 

   fun injectStrEnvToContext strEnv = 
      {
        tyConEnv = TY.emptyTyConEnv,
        varEnv = TY.emptyVarEnv,
        strEnv = strEnv,
        sigEnv = TY.emptySigEnv,
        funEnv = TY.emptyFunEnv
      } 

   fun injectSigEnvToContext sigEnv = 
      {
        tyConEnv = TY.emptyTyConEnv,
        varEnv = TY.emptyVarEnv,
        strEnv = TY.emptyStrEnv,
        sigEnv = sigEnv,
        funEnv = TY.emptyFunEnv
      } 

   fun injectEnvToContext (tyConEnv,varEnv,strEnv) = 
      {
        tyConEnv = tyConEnv,
        varEnv = varEnv,
        strEnv = strEnv,
        sigEnv = TY.emptySigEnv,
        funEnv = TY.emptyFunEnv
      } 

   fun bindTyConInEmptyContext (string, tyCon) = 
      {
        tyConEnv = SEnv.singleton(string, tyCon),
        varEnv = TY.emptyVarEnv,
        strEnv = TY.emptyStrEnv,
        sigEnv = TY.emptySigEnv,
        funEnv = TY.emptyFunEnv
      } 

   fun bindVarInEmptyContext (lambdaDepth, string, idstate) = 
      (TU.adjustDepthInIdstate lambdaDepth idstate;
      {
        tyConEnv = TY.emptyTyConEnv,
        varEnv = SEnv.singleton(string, idstate),
        strEnv = TY.emptyStrEnv,
        sigEnv = TY.emptySigEnv,
        funEnv = TY.emptyFunEnv
      } 
      )

   fun bindStrInEmptyContext (string, strEnvEntry) = 
      {
        tyConEnv = TY.emptyTyConEnv,
        varEnv = TY.emptyVarEnv,
        strEnv = STRUCTURE (SEnv.singleton(string, strEnvEntry)),
        sigEnv = TY.emptySigEnv,
        funEnv = TY.emptyFunEnv
      } 

   fun bindSigInEmptyContext (string, sigma) = 
      {
        tyConEnv = TY.emptyTyConEnv,
        varEnv = TY.emptyVarEnv,
        strEnv = TY.emptyStrEnv,
        sigEnv = SEnv.singleton(string, sigma),
        funEnv = TY.emptyFunEnv
      } 
   fun bindFunInEmptyContext (string, phi) = 
       {
        tyConEnv = TY.emptyTyConEnv,
        varEnv = TY.emptyVarEnv,
        strEnv = TY.emptyStrEnv,
        sigEnv = TY.emptySigEnv,
        funEnv = SEnv.singleton(string, phi)
        } 

   fun bindTyConInContext ({tyConEnv, varEnv, strEnv, sigEnv, funEnv} : context, 
                           string, tyCon)  = 
        {
          tyConEnv = SEnv.insert(tyConEnv, string, tyCon),
          varEnv = varEnv,
          strEnv = strEnv,
          sigEnv = sigEnv,
          funEnv = funEnv
        }

   fun bindVarInContext (lambdaDepth,
			 {tyConEnv, varEnv, strEnv, sigEnv, funEnv}: context, 
                         string, idstate) = 

     (
      TU.adjustDepthInIdstate lambdaDepth idstate;
      {
       tyConEnv = tyConEnv,
       varEnv = SEnv.insert(varEnv,string, idstate),
       strEnv = strEnv,
       sigEnv = sigEnv,
       funEnv = funEnv
       }
      )

   fun bindStrInContext ({tyConEnv, 
                          varEnv, 
                          strEnv = STRUCTURE strPathInfoSEnv, 
                          sigEnv, 
                          funEnv}: context, 
                         string, env) = 
        {
          tyConEnv = tyConEnv,
          varEnv = varEnv,
          strEnv = STRUCTURE (SEnv.insert(strPathInfoSEnv, string, env)),
          sigEnv = sigEnv,
          funEnv = funEnv
        }

   fun bindSigInContext ({tyConEnv, varEnv, strEnv, sigEnv, funEnv}: context, string, sigexp) = 
        {
          tyConEnv = tyConEnv,
          varEnv = varEnv,
          strEnv = strEnv,
          sigEnv = SEnv.insert(sigEnv, string, sigexp),
          funEnv = funEnv
        }

   fun extendContextWithTyConEnv ({tyConEnv, varEnv, strEnv, sigEnv, funEnv}: context, 
                                  newTyConEnv)
     = 
        {
          tyConEnv = SEnv.unionWith #1 (newTyConEnv, tyConEnv),
          varEnv = varEnv,
          strEnv = strEnv,
          sigEnv = sigEnv,
          funEnv = funEnv
          }

   fun extendContextWithVarEnv ({tyConEnv, varEnv, strEnv, sigEnv, funEnv}: context, newVarEnv) = 
        {
          tyConEnv = tyConEnv,
          varEnv = SEnv.unionWith #1 (newVarEnv, varEnv),
          strEnv = strEnv,
          sigEnv = sigEnv,
          funEnv = funEnv
        }

   fun extendContextWithStrEnv ({
                                 tyConEnv, 
                                 varEnv, 
                                 strEnv = STRUCTURE strPathInfoSEnv, 
                                 sigEnv, 
                                 funEnv
                                 }: context, 
                                newStrEnv) = 
        {
          tyConEnv = tyConEnv,
          varEnv = varEnv,
          strEnv = STRUCTURE (SEnv.unionWith #1 (newStrEnv, strPathInfoSEnv)),
          sigEnv = sigEnv,
          funEnv = funEnv
        }

   fun extendContextWithSigEnv ({tyConEnv, varEnv, strEnv, sigEnv, funEnv}: context, newSigEnv) = 
        {
          tyConEnv = tyConEnv,
          varEnv = varEnv,
          strEnv = strEnv,
          sigEnv = SEnv.unionWith #1 (newSigEnv, sigEnv),
          funEnv = funEnv
        }

   fun extendContextWithEnv ({
                              tyConEnv, 
                              varEnv, 
                              strEnv = STRUCTURE strEnvCont, 
                              sigEnv, 
                              funEnv
                              }: context, 
                             (newTyConEnv, newVarEnv, STRUCTURE newStrEnvCont)) = 
        {
          tyConEnv = SEnv.unionWith #1 (newTyConEnv, tyConEnv),
          varEnv = SEnv.unionWith #1 (newVarEnv, varEnv),
          strEnv = STRUCTURE (SEnv.unionWith #1 (newStrEnvCont, strEnvCont)),
          sigEnv = sigEnv,
          funEnv = funEnv
        }

   fun extendContextWithContext 
     {
      oldContext = {
                    tyConEnv, 
                    varEnv, 
                    strEnv= STRUCTURE strPathInfoSEnv, 
                    sigEnv, 
                    funEnv
                    } : context,
      newContext ={tyConEnv=newTyConEnv, 
                   varEnv = newVarEnv, 
                   strEnv=STRUCTURE newStrPathInfoSEnv, 
                   sigEnv = newSigEnv,
                   funEnv = newFunEnv}: context
      }
     =
     {
      tyConEnv = SEnv.unionWith #1 (newTyConEnv, tyConEnv),
      varEnv =  SEnv.unionWith #1 (newVarEnv, varEnv),
      strEnv = STRUCTURE (SEnv.unionWith #1 (newStrPathInfoSEnv, strPathInfoSEnv)),
      sigEnv = SEnv.unionWith #1 (newSigEnv, sigEnv),
      funEnv = SEnv.unionWith #1 (newFunEnv, funEnv)
      }

   fun unionContexts 
     (
      {tyConEnv=newTyConEnv, 
       varEnv = newVarEnv, 
       strEnv = STRUCTURE newStrPathInfoSEnv, 
       sigEnv = newSigEnv,
       funEnv = newFunEnv}: context,
      {tyConEnv, varEnv, strEnv = STRUCTURE strPathInfoSEnv, sigEnv, funEnv} : context
      )
     =
     let
       val checkDuplication = fn (key,x,y) => raise exDuplicateElem(key)
     in
       {
        tyConEnv = SEnv.unionWithi checkDuplication  (newTyConEnv, tyConEnv),
        varEnv =  SEnv.unionWithi checkDuplication (newVarEnv, varEnv),
        strEnv = STRUCTURE (SEnv.unionWithi checkDuplication (newStrPathInfoSEnv, strPathInfoSEnv)),
        sigEnv = SEnv.unionWithi checkDuplication (newSigEnv, sigEnv),
        funEnv = SEnv.unionWithi checkDuplication (newFunEnv, funEnv)
        }
     end

   fun mergeContexts 
     (
      {tyConEnv=newTyConEnv, 
       varEnv = newVarEnv, 
       strEnv = STRUCTURE newStrPathInfoSEnv, 
       sigEnv = newSigEnv,
       funEnv = newFunEnv}: context,
      {tyConEnv, varEnv, strEnv = STRUCTURE strPathInfoSEnv, sigEnv, funEnv} : context
      )
     =
     {
      tyConEnv = SEnv.unionWith #1  (newTyConEnv, tyConEnv),
      varEnv =  SEnv.unionWith #1 (newVarEnv, varEnv),
      strEnv = STRUCTURE (SEnv.unionWith #1 (newStrPathInfoSEnv, strPathInfoSEnv)),
      sigEnv = SEnv.unionWith #1 (newSigEnv, sigEnv),
      funEnv = SEnv.unionWith #1 (newFunEnv, funEnv)
      }

  fun getStructureEnvFromContext (context : context) =
      (
       #tyConEnv context,
       #varEnv   context,
       #strEnv   context
       ) 

  fun mergeBtvEnv (btvEnv1,btvEnv2) = IEnv.unionWith #1 (btvEnv1,btvEnv2)

  fun mergeSigEnv (sigEnv1,sigEnv2) = SEnv.unionWith #1 (sigEnv1,sigEnv2)

  fun mergeStrEnv (STRUCTURE strPathInfoSEnv1,STRUCTURE strPathInfoSEnv2) = 
      STRUCTURE (SEnv.unionWith #1 (strPathInfoSEnv1, strPathInfoSEnv2))

  fun mergeTyNameSet(tyNameSet1,tyNameSet2) =
      ISet.union(tyNameSet1,tyNameSet2)

  fun extractEnvFromContext (context:context) =
      (#tyConEnv context, #varEnv context, #strEnv context)

  (* ToDo : *)
  fun contextToString context =
      Control.prettyPrint (format_context nil context)

end
end
