(**
 * Utility functions for formatting using SMLFormat.
 * @copyright (c) 2006, Tohoku University.
 * @author Atsushi Ohori 
 * @version $Id: SmlppgUtil.ppg,v 1.7 2006/04/21 04:54:14 ohori Exp $
 *)
structure SmlppgUtil =
struct

  (***************************************************************************)

  structure FE = SMLFormat.FormatExpression

  (***************************************************************************)

  val spaceIndicator = FE.Indicator{space = true, newline = NONE}
  val ns_1_Indicator =
      FE.Indicator
      {space = false, newline = SOME{priority = FE.Preferred 1}}
  val s_1_Indicator =
      FE.Indicator
      {space = true, newline = SOME{priority = FE.Preferred 1}}
  val s_d_Indicator =
      FE.Indicator
      {space = true, newline = SOME{priority = FE.Deferred}}

  fun makeToken s = [FE.Term (String.size s, s)]

  fun format_int32 int =
      let val text = Int32.toString int
      in [FE.Term (size text, text)] end

  fun format_word32 word =
      let val text = Word32.toString word
      in [FE.Term (size text, text)] end

  local
    (**
     * @params isTyConArguments args
     * @param isTyConArguments true if this function is called to format type
     *        arguments to type constructor.
     * @param args a pair of element formatter, separator, prefix and suffix.
     *)
    fun formatElements
            isTyConArguments
            (elementFormatter, separator, prefixIfNotNull, suffixIfNotNull) =
        fn [] => [FE.Term (0, "")]
         | [e] =>
           if isTyConArguments
           then
             (* guard the element as:
              *   N3{ elem }
              * This assumes this function is called to format type arguments
              * of type constructor.
              *)
             [
               FE.Guard 
                   (
                     SOME{cut = false, strength = 3, direction = FE.Neutral},
                     elementFormatter e
                   ),
               s_d_Indicator
             ]
           else (elementFormatter e) @ [s_d_Indicator]
         | list =>
           prefixIfNotNull
           @ [
               FE.Guard 
                   (
                     SOME{cut = true, strength = 0, direction = FE.Neutral},
                     (SMLFormat.BasicFormatters.format_list
                          (elementFormatter, separator) list)
                   )
             ]
           @ suffixIfNotNull
  in
  fun formatTyConArgumentTypes arguments = formatElements true arguments
  fun formatListWithEnclosureOne arguments = formatElements false arguments
  end

  fun formatSSet (separator, prefixIfNotNull, suffixIfNotNull) sset = 
      let 
      val L = SSet.listItems sset
      in
         formatListWithEnclosureOne
         (
           SMLFormat.BasicFormatters.format_string,
           separator,
           prefixIfNotNull,
           suffixIfNotNull
         )
         L
      end


  fun formatIDSet (separator, prefixIfNotNull, suffixIfNotNull) idset = 
      let 
          val L = map ID.toString (ID.Set.listItems idset)
      in
          formatListWithEnclosureOne
              (
               SMLFormat.BasicFormatters.format_string,
               separator,
               prefixIfNotNull,
               suffixIfNotNull
               )
              L
      end
  (*
    This is for the usual list printing, u.e.
      nil => ""
      non nil => [e1,...,en] 
   *)
  fun formatListWithEnclosure
      (elementFormatter, separator, prefixIfNotNull, suffixIfNotNull) =
      fn [] => [FE.Term (0, "")]
       | list =>
         prefixIfNotNull @
         (SMLFormat.BasicFormatters.format_list
              (elementFormatter, separator) list) @
         suffixIfNotNull

  (*
    This is for the following printing
      nil => ""
      [e] => e
      [e1,...,en] => opne e1 sep e2 sep ... sep en close
   *)
  fun formatListWithEnclosureIfMoreThanOne
      (elementFormatter, separator, prefixIfNotNull, suffixIfNotNull) =
      fn [] => [FE.Term (0, "")]
       | [value] => elementFormatter value
       | list =>
         prefixIfNotNull @
         (SMLFormat.BasicFormatters.format_list
              (elementFormatter, separator) list) @
         suffixIfNotNull

 (*%
  * @params(bindsep,itemsep)
  *)
 type 'a record =
     (*%
      * @format(field fields)
      *           !N0{ "{" 2[1 fields(field)(itemsep)] 1 "}" }
      * @format:field(label * ty) {label} d bindsep d {ty}
      *)
     (string * 'a) list

 (*%
  * @params(bindsep,itemsep)
  *)
 type 'a varenv =
     (*%
      * @format(field fields)
      *           !N0{ fields(field)(itemsep)}
      * @format:field(label * ty) {label} +d bindsep +d {ty}
      *)
     (string * 'a) list

 (*%
  * @params(bindsep, itemsep, prefixIfNotNull, suffixIfNotNull)
  * @formatter(listWithEncousure)  formatListWithEnclosure
  *)
 type 'a varenvWithEnclosure =
     (*%
      * @format(field fields:listWithEncousure)
      *           fields(field)(itemsep, prefixIfNotNull, suffixIfNotNull)
      * @format:field(label * ty) label +d bindsep +d ty
      *)
     (string * 'a) list

 (*%
  * @params(itemsep)
  *)
 type 'a tupleTy = 
     (*%
      * @format(field fields)
      *           N2{ fields(field)(itemsep) }
      * @format:field(label * ty) N3{ty}
      *)
     (string * 'a) list

 (*%
  * @params(bindsep,itemsep)
  *)
 type 'a tupleExp = 
     (*%
      * @format(field fields)
      *           !N0{ "(" 2[1 fields(field)("," +1)] 1 ")" }
      * @format:field(label * exp) {exp}
      *)
     (string * 'a) list

  fun formatGenericFieldsTy
          (elementFormatter, bindsep, itemsepRecord, itemsep) L =
      let 
        fun isNumeric n nil = true
          | isNumeric n ((l,_)::tail) = 
            (case Int.fromString l  of
               SOME k => if k = n then isNumeric (n+1) tail else false
             | _ => false)
      in
        case L of
          nil => [FE.Term (3, "nil")]
        | [_] => format_record(elementFormatter, bindsep, itemsepRecord) L
        | _ =>  
          if isNumeric 1 L
          then format_tupleTy(elementFormatter, itemsep) L
          else format_record(elementFormatter, bindsep, itemsepRecord) L
      end

  fun formatGenericFieldsExp (elementFormatter,bindsep,itemsep) L =
      let 
      fun isNumeric n nil = true
        | isNumeric n ((l,_)::tail) = 
          (case Int.fromString l of
             SOME k => if k = n then isNumeric (n+1) tail else false
           | _ => false)
      in
        if isNumeric 1 L
        then format_tupleExp(elementFormatter,bindsep,itemsep) L
        else format_record(elementFormatter,bindsep,itemsep) L
      end

  fun formatGenericSmapTy params smap =
      let
        val L = SEnv.listItemsi smap
      in
        formatGenericFieldsTy params L
      end

  fun formatGenericSmapExp params smap =
      let 
        val L = SEnv.listItemsi smap
      in
        formatGenericFieldsExp params L
      end

  fun formatSmap (elementFormatter,bindsep,itemsep) smap =
      format_varenv(elementFormatter,bindsep,itemsep) (SEnv.listItemsi smap)

  fun formatSmapWithEnclosure
          (
            elementFormatter,
            bindsep,
            itemsep,
            prefixIfNotNull,
            suffixIfNotNull
          )
          smap
    =
      format_varenvWithEnclosure
      (elementFormatter, bindsep, itemsep, prefixIfNotNull, suffixIfNotNull)
      (SEnv.listItemsi smap)

  fun formatImap (elementFormatter) imap =
      SMLFormat.BasicFormatters.format_list
          (elementFormatter,makeToken ",") (IEnv.listItems imap)

  fun formatPrependedOpt (formatter, prefixIfSome) =
      fn NONE => [FE.Term (0, "")]
       | SOME value => prefixIfSome @ (formatter value)

  fun formatEnclosedOpt (formatter, prefixIfSome, suffixIfSome) =
      fn NONE => [FE.Term (0, "")]
       | SOME value => prefixIfSome @ (formatter value) @ suffixIfSome

  fun formatOptWithDefault (formatter, default) =
      fn NONE => default
       | SOME value => formatter value

  fun formatBinaryChoice (ifTrue, ifFalse) value =
      if value then ifTrue else ifFalse

  (***************************************************************************)

end
