/*
 * top.c
 * @copyright (c) 2015, Tohoku University.
 * @author UENO Katsuhiro
 */

#include "smlsharp.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

/*
 * Frame tables generated by SML# GC LLVM plugin.
 * See also smlsharp_gc.cpp.
 *
 *   struct align(intptr_t) {
 *     uint16_t NumSafePoints;
 *     struct {
 *       uint16_t FrameSize;                    // in words
 *       uint16_t NumRoots;
 *       uint16_t RootOffsets[NumRoots];        // in words
 *     } Layout;
 *     intptr_t SafePoints[NumSafePoints];      // in bytes
 *   } Descriptors[]; // terminated with NumSafePoints == 0
 *
 * Each of RootOffsets is an offset address of a pointer slot from the end
 * address of the stack.  The unit of FrameSize and RootOffsets is the
 * size of pointers, which is equal to sizeof(void*).
 * Each of SafePoints is an offset address of a GC-safe code point from the
 * entry address of the top-level code, which is labeled with _SML_top in
 * each object file.
 */
struct frame_descriptor {
	uint16_t num_safe_points;
	/* struct sml_frame_layout layout; */
	/* intptr_t safe_points[]; */
};
#define FRAME_LAYOUT(desc) \
	((const struct sml_frame_layout *)((uint16_t*)(desc) + 1))
#define FRAME_LAYOUT_SIZE(layout) \
	(sizeof(struct sml_frame_layout) \
	 + sizeof(uint16_t[(layout)->num_roots]))
#define SAFE_POINTS_OFFSET(desc) \
	CEILING(sizeof(uint16_t) + FRAME_LAYOUT_SIZE(FRAME_LAYOUT(desc)), \
		sizeof(intptr_t))
#define SAFE_POINTS(desc) \
	((const intptr_t *)((char*)(desc) + SAFE_POINTS_OFFSET(desc)))

/*
 * top-level dependency information generated by the SML# compiler.
 * See also LLVMGen.sml.
 */
struct top_dependency {
	uint64_t top_id;
	uint64_t num_requires;
	uint64_t requires[];
	/* char name[];   // immediately after the array of requires */
};
#define MODULE_NAME(dep) \
	((const char *)((dep)->requires + (dep)->num_requires))

/*
 * The set of root objects are given as an intptr_t array with its length.
 * Each integer in the array is the offset address of an object from the
 * address of the beginning of the array.  We do not use an offset array
 * rather than an address array to avoid a lot of relocations.
 */
struct root_object_offsets {
	uintptr_t num_objects;
	uintptr_t objects[];
};

/*
 * top-level information of each object file.
 */
struct top {
	const void *topfunc;    /* the address of the top-level code */
	const struct frame_descriptor *frametable;
	const struct top_dependency *dependency;
	const struct root_object_offsets *root_offsets;
	struct top *next;       /* for the result of tsort_top */
	struct top **adj;       /* work area for tsort_top */
	unsigned int num_adj;   /* work area for tsort_top */
	unsigned int ref_count; /* work area for tsort_top */
};

/* array of top */
struct toplevels {
	size_t fill, len;
	struct top ary[];
};
#define TOPLEVELS_STEP ((4096-sizeof(struct toplevels))/sizeof(struct top))
#define SIZEOF_TOPLEVELS(n) (sizeof(struct toplevels)+sizeof(struct top)*(n))

static struct toplevels *
alloc_toplevels()
{
	struct toplevels *ta;
	ta = xmalloc(SIZEOF_TOPLEVELS(TOPLEVELS_STEP));
	ta->fill = 0;
	ta->len = TOPLEVELS_STEP;
	return ta;
}

static struct top *
alloc_top(struct toplevels **ta)
{
	if ((*ta)->fill >= (*ta)->len) {
		(*ta)->len += TOPLEVELS_STEP;
		*ta = xrealloc(*ta, SIZEOF_TOPLEVELS((*ta)->len));
	}
	return (*ta)->ary + ((*ta)->fill++);
}

user_tlv_alloc(struct toplevels *, toplevels, free);

/*
 * A linked list of garbage collection information.
 * A gc_info structure is created for each load.
 * Usually, gc_info_list includes only one gc_info, which is created before
 * user code execution.  If the program loads SML# codes dynamically by
 * dlopen, gc_info_list grows.
 */
struct gc_info {
	_Atomic(struct gc_info *) next;  /* lock-free list */
	struct frametable {
		struct frametable_entry {
			const void *codeaddr;
			const struct sml_frame_layout *layout;
		} *ary;  /* sorted by codeaddr */
		size_t len;
	} frametable;
	void **root_objects;  /* terminated with NULL */
};

static _Atomic(struct gc_info *) gc_info_list;

static char *
module_name_list(const struct top *t)
{
	const struct top *i;
	size_t len = 1;
	int n;
	char *s, *p;

	for (i = t; i; i = i->next)
		len += strlen(MODULE_NAME(i->dependency)) + 19;

	s = xmalloc(len);

	for (i = t, p = s; i; i = i->next) {
		n = snprintf(p, len, "%s(%016"PRIx64") ",
			     MODULE_NAME(i->dependency),
			     i->dependency->top_id);
		p += n, len -= n;
	}

	return s;
}

static void **
load_root_objects(const struct toplevels *ta)
{
	size_t num_roots = 0, i, j;
	const struct root_object_offsets *offsets;
	void **roots, **dst;

	for (i = 0; i < ta->fill; i++) {
		offsets = ta->ary[i].root_offsets;
		if (offsets)
			num_roots += offsets->num_objects;
	}

	roots = xmalloc((num_roots + 1) * sizeof(void *));
	dst = roots;

	for (i = 0; i < ta->fill; i++) {
		offsets = ta->ary[i].root_offsets;
		if (!offsets)
			continue;
		for (j = 0; j < offsets->num_objects; j++)
			*(dst++) = (char*)offsets + offsets->objects[j];
	}
	*dst = NULL;

	return roots;
}

static size_t
load_frametable_entries(const struct toplevels *ta, struct frametable_entry *e)
{
	const struct top *t;
	size_t num_entries = 0, i, j;
	const struct frame_descriptor *ftab;
	const struct sml_frame_layout *layout;
	const intptr_t *points;

	for (i = 0; i < ta->fill; i++) {
		t = &ta->ary[i];
		ftab = t->frametable;
		while (ftab->num_safe_points > 0) {
			num_entries += ftab->num_safe_points;
			points = SAFE_POINTS(ftab);
			layout = FRAME_LAYOUT(ftab);
			if (!e) {
				points += ftab->num_safe_points;
				ftab = (void*)points;
				continue;
			}
			for (j = 0; j < ftab->num_safe_points; j++) {
				e->codeaddr = (char*)t->topfunc + *points;
				e->layout = layout;
				e++, points++;
			}
			ftab = (void*)points;
		}
	}

	return num_entries;
}

static int
frametable_entry_cmp(const void *x, const void *y)
{
	const struct frametable_entry *e1 = x, *e2 = y;
	uintptr_t m = (uintptr_t)e1->codeaddr, n = (uintptr_t)e2->codeaddr;
	if (m < n) return -1;
	else if (m > n) return 1;
	else return 0;
}

static struct gc_info *
load_gc_info(const struct toplevels *ta)
{
	struct gc_info *gi;
	size_t len;

	len = load_frametable_entries(ta, NULL);

	gi = xmalloc(sizeof(struct gc_info));
	atomic_init(&gi->next, NULL);
	gi->root_objects = load_root_objects(ta);
	gi->frametable.ary = xmalloc(len * sizeof(struct frametable_entry));
	gi->frametable.len = len;

	load_frametable_entries(ta, gi->frametable.ary);

	/* sort the frame table entries for binary search */
	qsort(gi->frametable.ary, gi->frametable.len,
	      sizeof(struct frametable_entry), frametable_entry_cmp);

	return gi;
}

static const struct sml_frame_layout *
lookup_frametable(void *retaddr, const struct frametable *ftab)
{
	uintptr_t addr, key = (uintptr_t)retaddr;
	size_t l = 0, r = ftab->len, c;

	while (l < r) {
		c = (l + r) / 2;
		addr = (uintptr_t)ftab->ary[c].codeaddr;
		if (addr == key) return ftab->ary[c].layout;
		else if (addr < key) l = c + 1;
		else r = c;
	}
	return NULL;
}

const struct sml_frame_layout *
sml_lookup_frametable(void *retaddr)
{
	struct gc_info *gi;
	const struct sml_frame_layout *ret;

	/* The first gc_info can be read safely without memory ordering since
	 * it has been created before user code execution. */
	gi = load_relaxed(&gc_info_list);

	while (gi) {
		ret = lookup_frametable(retaddr, &gi->frametable);
		if (ret)
			return ret;
		gi = load_acquire(&gi->next);
	}

	sml_fatal(0, "frametable lookup failed %p", retaddr);
}

void
sml_enum_global(void (*trace)(void **, void *), void *data)
{
	struct gc_info *gi;
	void **roots, *obj;

	/* The first gc_info can be read safely without memory ordering since
	 * it has been created before user code execution. */
	gi = load_relaxed(&gc_info_list);

	while (gi) {
		roots = gi->root_objects;
		while ((obj = *(roots++)))
			sml_obj_enum_ptr(obj, trace, data);
		gi = load_acquire(&gi->next);
	}
}

static void
register_gc_info(_Atomic(struct gc_info *) *gi_next, struct gc_info *new)
{
	struct gc_info *next;

	for (;;) {
		next = load_acquire(gi_next);
		if (!next && cmpswap_acq_rel(gi_next, &next, new))
			break;
		gi_next = &next->next;
	}
}

static struct top *
bsearch_top(struct top * const *tops, size_t fill, uint64_t key)
{
	size_t l = 0, r = fill, c;
	uint64_t id;

	while (l < r) {
		c = (l + r) / 2;
		id = tops[c]->dependency->top_id;
		if (id == key) return tops[c];
		else if (id < key) l = c + 1;
		else r = c;
	}
	return NULL;
}

static int
tops_cmp(const void *p1, const void *p2)
{
	const struct top * const *t1 = p1, * const *t2 = p2;
	uint64_t i1 = (*t1)->dependency->top_id, i2 = (*t2)->dependency->top_id;
	return (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;
}

static struct top *
tsort_top(struct toplevels *ta)
{
	struct top **tops, **adj, **adj_begin, *t, *t2;
	struct top *sorted, *last;
	size_t num_reqs, i, j;
	size_t num_sorted;

	tops = xmalloc(ta->fill * sizeof(struct top *));
	num_reqs = 0;
	for (i = 0; i < ta->fill; i++) {
		tops[i] = &ta->ary[i];
		num_reqs += ta->ary[i].dependency->num_requires;
		ta->ary[i].ref_count = 0;
	}
	adj_begin = xmalloc(num_reqs * sizeof(struct top *));

	/* sort tops by id for binary search */
	qsort(tops, ta->fill, sizeof(struct top *), tops_cmp);

	/* check duplicate id */
	for (i = 1; i < ta->fill; i++) {
		if (tops[i]->dependency->top_id
		    == tops[i-1]->dependency->top_id) {
			sml_fatal(0, "duplicate toplevel id "
				  "%s(%016"PRIx64") and %s(%016"PRIx64"); "
				  "recompile all objects",
				  MODULE_NAME(tops[i-1]->dependency),
				  tops[i-1]->dependency->top_id,
				  MODULE_NAME(tops[i]->dependency),
				  tops[i]->dependency->top_id);
		}
	}

	/* make an adjacency list for each node */
	for (i = 0, adj = adj_begin; i < ta->fill; i++) {
		t = tops[i];
		t->adj = adj;
		for (j = 0; j < t->dependency->num_requires; j++) {
			t2 = bsearch_top(tops, ta->fill,
					 t->dependency->requires[j]);
			if (t2) {
				*(adj++) = t2;
				t2->ref_count++;
			}
		}
		t->num_adj = adj - t->adj;
	}

	/* search for nodes with ref_count = 0 */
	sorted = NULL;
	num_sorted = 0;
	for (i = 0; i < ta->fill; i++) {
		if (ta->ary[i].ref_count == 0) {
			ta->ary[i].next = sorted;
			sorted = &ta->ary[i];
			num_sorted++;
		}
	}
	if (!sorted) {
		sml_fatal(0, "no toplevel entry found; recompile all objects");
	} else if (sorted->next) {
		sml_fatal(0, "multiple toplevel entries found; "
			  "recompile objects relevant to the following: %s",
			  module_name_list(sorted));
	}

	/* breath-first topological sort */
	last = NULL;
	do {
		struct top *tmp = sorted;
		for (t = sorted; t != last; t = t->next) {
			for (j = 0; j < t->num_adj; j++) {
				if (--(t->adj[j]->ref_count) == 0) {
					t->adj[j]->next = sorted;
					sorted = t->adj[j];
					num_sorted++;
				}
			}
		}
		last = tmp;
	} while (sorted != last);

	if (num_sorted != ta->fill)
		sml_fatal(0, "cyclic dependency found; recompile all objects");

	if (tops)
		free(tops);
	if (adj_begin)
		free(adj_begin);

	return sorted;
}

void
sml_register_top(const void *topfunc, const void *dependency,
		 const void *frametable, const void *root_offsets)
{
	struct toplevels *ta;
	struct top *t;

	/* allocate current_mutator user_tlv as the first tls key. */
	sml_control_init();

	ta = user_tlv_get_or_init(toplevels);
	if (!ta)
		ta = alloc_toplevels();
	t = alloc_top(&ta);
	t->topfunc = topfunc;
	t->dependency = dependency;
	t->frametable = frametable;
	t->root_offsets = root_offsets;
	user_tlv_set(toplevels, ta);
}

typedef void topfn(void);

void
sml_run()
{
	struct toplevels *ta;
	struct top *t;
	struct gc_info *gi;
	topfn **topfuncs, **p;

	ta = user_tlv_get_or_init(toplevels);
	user_tlv_set(toplevels, NULL);

	t = tsort_top(ta);
	gi = load_gc_info(ta);
	register_gc_info(&gc_info_list, gi);

	/* free toplevels to leave memory for user code as much as possible */
	topfuncs = xmalloc(sizeof(topfuncs[0]) * (ta->fill + 1));
	for (p = topfuncs; t; t = t->next, p++)
		*p = (topfn*)t->topfunc;
	*p = NULL;
	free(ta);

	for (p = topfuncs; *p; p++)
		(*p)();

	free(topfuncs);
}
