(**
 * constant terms.
 * @copyright (c) 2006, Tohoku University.
 * @author Atsushi Ohori
 * @author Liu Bochao
 * @author YAMATODANI Kiyoshi
 * @version $Id: ConstantTerm.ppg,v 1.2 2007/02/12 01:59:17 kiyoshiy Exp $
 *)
structure ConstantTerm =
struct

  structure P = Path
  structure PT = PredefinedTypes
  structure T = Types
  structure TP = TypeParser
  structure TU = TypesUtils

  (*%
   * @formatter(Int32.int) SmlppgUtil.format_int32
   * @formatter(Word32.word) SmlppgUtil.format_word32
   *)
  datatype constant 
    = (*%
       * @format(value) value
       *)
      INT of Int32.int
    | (*%
       * @format(value) "0wx" value
       *)
      WORD of Word32.word
    | (*%
       * @format(value) "\"" value "\""
       *)
      STRING of string
    | (*%
       * @format(value) value
       *)
      REAL of string
    | (*%
       * @format(value) value "f"
       *)
      FLOAT of string
    | (*%
       * @format(value) "#\"" value "\""
       *)
      CHAR of char
    | (*%
       * @format(value) "()"
       *)
      UNIT 

  fun compare (x,y) = 
      case (x,y) of
        (INT i1, INT i2) => Int32.compare(i1, i2)
      | (INT _, _) => LESS
      | (WORD _,INT _) => GREATER
      | (WORD w1,WORD w2) => Word32.compare(w1,w2)
      | (WORD w1,_) => LESS
      | (STRING _, INT _) => GREATER
      | (STRING _, WORD _) => GREATER
      | (STRING s1, STRING s2) => String.compare (s1, s2)
      | (STRING _, _) => LESS
      | (REAL r1, INT _) => GREATER
      | (REAL r1, WORD _) => GREATER
      | (REAL r1, STRING _) => GREATER
      | (REAL r1, REAL r2) => String.compare(r1, r2)
      | (REAL r1, _) => LESS
      | (FLOAT r1, INT _) => GREATER
      | (FLOAT r1, WORD _) => GREATER
      | (FLOAT r1, STRING _) => GREATER
      | (FLOAT _, REAL _) => GREATER
      | (FLOAT r1, FLOAT r2) => String.compare(r1, r2)
      | (FLOAT r1, _) => LESS
      | (CHAR _, INT _) => GREATER
      | (CHAR _, WORD _) => GREATER
      | (CHAR _, STRING _) => GREATER
      | (CHAR _, REAL _) => GREATER
      | (CHAR _, FLOAT _) => GREATER
      | (CHAR c1, CHAR c2) => Char.compare(c1,c2)
      | (CHAR _, _) => LESS
      | (UNIT, UNIT) => EQUAL
      | (UNIT, _) => GREATER

  local
    structure OCord : ordsig =
      struct
        (* Note: compare only type of constant. *)
        fun compare (INT _, INT _)             = EQUAL
          | compare (INT _, _)                 = LESS
          | compare (WORD _, INT _)            = GREATER
          | compare (WORD _, WORD _)           = EQUAL
          | compare (WORD _, _)                = LESS
          | compare (STRING _, INT _)          = GREATER
          | compare (STRING _, WORD _)         = GREATER
          | compare (STRING _, STRING _)       = EQUAL
          | compare (STRING _,  _)             = LESS
          | compare (REAL _, UNIT)             = LESS
          | compare (REAL _, CHAR _)           = LESS
          | compare (REAL _, REAL _)           = EQUAL
          | compare (REAL _, _)                = GREATER
          | compare (CHAR _, UNIT)             = LESS
          | compare (CHAR _, CHAR _)           = EQUAL
          | compare (CHAR _, _)                = GREATER
          | compare (UNIT, UNIT)               = EQUAL
          | compare (UNIT, _)                  = GREATER
        type ord_key = constant
      end
    structure OCMap = BinaryMapFn(OCord)
    val constantTypeDefs =
        [
          (INT (0),  "['a#{int,largeInt}.'a]"),
          (WORD (0w0), "['a#{word,largeWord,byte}.'a]"),
          (STRING (""), "string"),
          (REAL ("0.0"), "['a#{real,float}.'a]"),
          (CHAR (#"c"),  "char"),
          (UNIT,  "unit")
        ]
    val constantTypeMap =
        foldl
            (fn ((const, tyRep), constTypeMap) =>
                OCMap.insert
                    (constTypeMap, const, TP.readTy PT.initialTyConEnv tyRep))
            OCMap.empty
            constantTypeDefs
  in
    fun constTy const =
        case OCMap.find(constantTypeMap, const) of
          SOME ty => ty
        | _ => raise (Control.Bug "InitialTypeContext constTy")
  end

  fun constDefaultTy const =
      case const of
        INT _ => PT.intty
      | WORD _ => PT.wordty
      | REAL _ => PT.realty
      | FLOAT _ => PT.floatty
      | STRING _ => PT.stringty
      | CHAR _ => PT.charty
      | UNIT => PT.unitty

  fun castConst (const, ty) =
      let
        datatype constTy =
                 INTty | WORDty | CHARty | STRINGty | REALty | FLOATty
               | LARGEINTty | LARGEWORDty | BYTEty | UNITty
        val constTy =
            case TU.derefTy ty of
              T.CONty {tyCon={id,...}, args=[]} =>
              if ID.eq (id, PT.intTyConid) then INTty
              else if ID.eq (id, PT.wordTyConid) then WORDty
              else if ID.eq (id, PT.charTyConid) then CHARty
              else if ID.eq (id, PT.stringTyConid) then STRINGty
              else if ID.eq (id, PT.realTyConid) then REALty
              else if ID.eq (id, PT.floatTyConid) then FLOATty
              else if ID.eq (id, PT.largeIntTyConid) then LARGEINTty
              else if ID.eq (id, PT.largeWordTyConid) then LARGEWORDty
              else if ID.eq (id, PT.byteTyConid) then BYTEty
              else if ID.eq (id, PT.unitTyConid) then UNITty
              else raise Control.Bug "castConst"
            | _ => raise Control.Bug "castConst"
      in
        case (const, constTy) of
          (INT _, INTty) => const
        | (INT _, LARGEINTty) => const
        | (WORD _, WORDty) => const
        | (WORD _, LARGEWORDty) => const
        | (WORD _, BYTEty) => const
        | (STRING _, STRINGty) => const
        | (REAL _, REALty) => const
        | (REAL x, FLOATty) => FLOAT x
        | (FLOAT _, FLOATty) => const
        | (FLOAT x, REALty) => REAL x
        | (CHAR _, CHARty) => const
        | (UNIT, UNITty) => const
        | _ => raise Control.Bug "castConst"
      end

end