<HTML>
<HEAD>
<TITLE>Utility</TITLE>
</HEAD>
<BODY><TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="1">
<TR>
<TD>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="3" CELLPADDING="0">
<TR ALIGN=CENTER VALIGN=TOP>
<TD BGCOLOR="#EEEEFF">
<B><A HREF="overview-summary.html">Overview</A></B>&nbsp;
</TD><TD BGCOLOR="#EEEEFF">
<B><A HREF="index-all.html">Index</A></B>&nbsp;
</TD><TD BGCOLOR="#EEEEFF">
<B><A HREF="help-doc.html">Help</A></B>&nbsp;
</TD></TR></TABLE>
</TD><TD ALIGN=RIGHT VALIGN=TOP>
<em>SMLDoc</em>
</TD></TR></TABLE>
<HR>
<H2>Utility</H2>
<HR>
<P>
<CODE>structure&nbsp;<A HREF="StrUtility.html">Utility</A>&nbsp;=<br>
struct<br>
&nbsp;&nbsp;exception&nbsp;<A HREF="StrUtility.html#ExceptionMissingEscapedChar">MissingEscapedChar</A><br>
&nbsp;&nbsp;val&nbsp;<A HREF="StrUtility.html#Valinterleave">interleave</A><br>
&nbsp;&nbsp;val&nbsp;<A HREF="StrUtility.html#ValinterleaveString">interleaveString</A><br>
&nbsp;&nbsp;val&nbsp;<A HREF="StrUtility.html#ValisPrefixOf">isPrefixOf</A><br>
&nbsp;&nbsp;val&nbsp;<A HREF="StrUtility.html#ValsplitLast">splitLast</A><br>
&nbsp;&nbsp;val&nbsp;<A HREF="StrUtility.html#Valsort">sort</A><br>
&nbsp;&nbsp;val&nbsp;<A HREF="StrUtility.html#Valuniq">uniq</A><br>
&nbsp;&nbsp;val&nbsp;<A HREF="StrUtility.html#ValsatisfyAny">satisfyAny</A><br>
&nbsp;&nbsp;val&nbsp;<A HREF="StrUtility.html#ValsatisfyAll">satisfyAll</A><br>
&nbsp;&nbsp;val&nbsp;<A HREF="StrUtility.html#ValcompareStringNoCase">compareStringNoCase</A><br>
&nbsp;&nbsp;val&nbsp;<A HREF="StrUtility.html#ValtokenizeString">tokenizeString</A><br>
&nbsp;&nbsp;val&nbsp;<A HREF="StrUtility.html#ValreplaceString">replaceString</A><br>
&nbsp;&nbsp;val&nbsp;<A HREF="StrUtility.html#ValreplaceStringByTable">replaceStringByTable</A><br>
&nbsp;&nbsp;val&nbsp;<A HREF="StrUtility.html#ValreplaceFile">replaceFile</A><br>
end</CODE>
<P>

<DL>
<DD>
  This module provides functions independent of the specific applications.


<P>

<DD>
<DL>
<DT> <B>Author:</B>
<DD>
YAMATODANI Kiyoshi

<DT> <B>Version:</B>
<DD>
$Id: StrUtility.html,v 1.9 2007/02/17 07:01:58 kiyoshiy Exp $
 

</DL>
</DL>
<P>

<P>
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<TABLE WIDTH="100%" BORDER="1" CELLSPACING="1" CELLPADDING="3">
<TR BGCOLOR="#CCCCFF">
<TH COLSPAN=1>
<FONT SIZE="+2">Value detail</FONT>
</TH></TR></TABLE>
<A NAME="Valinterleave"><!-- --></A>
<H3>interleave</H3>
<P>
<CODE>fun&nbsp;interleave&nbsp;separator&nbsp;list</CODE>
<DL>
<DD>
  interleave elements of a list with separators.

<P>

<DD>
<DL>
<DT> <B>Parameters:</B>
<DD>
<DL>
<DT> <CODE>separator</CODE>
<DD>
 the separator

<DT> <CODE>list</CODE>
<DD>
 the list

</DL>
<DT> <B>Returns:</B>
<DD>
the list interleaved with separators
   

</DL>
</DL>
<HR>
<A NAME="ValinterleaveString"><!-- --></A>
<H3>interleaveString</H3>
<P>
<CODE>fun&nbsp;interleaveString&nbsp;separator&nbsp;strings</CODE>
<DL>
<DD>
  Concat strings with separator.
 <p>
  <code>String.concatWith</code> in the SMLBasis library provides
 the same functionality, but this function is not implemented by some
 version of SML/NJ.
 </p>


<P>

<DD>
<DL>
<DT> <B>Parameters:</B>
<DD>
<DL>
<DT> <CODE>separator</CODE>
<DD>
 the separator

<DT> <CODE>string</CODE>
<DD>
 the list of string

</DL>
<DT> <B>Returns:</B>
<DD>
the concatenation of the strings using the separator
   

</DL>
</DL>
<HR>
<A NAME="ValisPrefixOf"><!-- --></A>
<H3>isPrefixOf</H3>
<P>
<CODE>fun&nbsp;isPrefixOf&nbsp;(left,&nbsp;right)</CODE>
<DL>
<DD>
 indicates whether a list is a prefix of another list.

<P>

<DD>
<DL>
<DT> <B>Parameters:</B>
<DD>
<DL>
<DT> <CODE>left</CODE>
<DD>
 left list

<DT> <CODE>right</CODE>
<DD>
 right list

</DL>
<DT> <B>Returns:</B>
<DD>
true if the <code>left</code> is a prefix of the
     <code>right</code>.
   

</DL>
</DL>
<HR>
<A NAME="ValsplitLast"><!-- --></A>
<H3>splitLast</H3>
<P>
<CODE>fun&nbsp;splitLast&nbsp;list</CODE>
<DL>
<DD>
 split a list into a pair of the elements but the last element and
 the last element.
 <p>
 Example:
 <pre>splitLast [1, 2, 3, 4]</pre>
 returns
 <pre>([1, 2, 3], 4)</pre>


<P>

<DD>
<DL>
<DT> <B>Parameters:</B>
<DD>
<DL>
<DT> <CODE>list</CODE>
<DD>
 a list

</DL>
<DT> <B>Returns:</B>
<DD>
a pair of first n-1 elements and the last element if the
         <code>list</code> has n elements.
   

</DL>
</DL>
<HR>
<A NAME="Valsort"><!-- --></A>
<H3>sort</H3>
<P>
<CODE>fun&nbsp;sort&nbsp;comparator&nbsp;list</CODE>
<DL>
<DD>
 sorts a list.
 <p>
 ToDo : use efficient algorithm.
 </p>

<P>

<DD>
<DL>
<DT> <B>Parameters:</B>
<DD>
<DL>
<DT> <CODE>comparator</CODE>
<DD>
 a function which compares two elements in the list.
       When applied to (left, right), it must return true if left < right.

<DT> <CODE>list</CODE>
<DD>
 the list to be sorted.

</DL>
<DT> <B>Returns:</B>
<DD>
the sorted list
   

</DL>
</DL>
<HR>
<A NAME="Valuniq"><!-- --></A>
<H3>uniq</H3>
<P>
<CODE>fun&nbsp;uniq&nbsp;list</CODE>
<DL>
<DD>
 filter out repeated elements in a list.

<P>

<DD>
<DL>
<DT> <B>Parameters:</B>
<DD>
<DL>
<DT> <CODE>list</CODE>
<DD>
 sorted list

</DL>
<DT> <B>Returns:</B>
<DD>
a list in which adjacent equal elements are merged
   

</DL>
</DL>
<HR>
<A NAME="ValsatisfyAny"><!-- --></A>
<H3>satisfyAny</H3>
<P>
<CODE>fun&nbsp;satisfyAny&nbsp;conditions&nbsp;value</CODE>
<DL>
<DD>
 build a predicator which is a disjunction of predicators.

<P>

<DD>
<DL>
<DT> <B>Parameters:</B>
<DD>
<DL>
<DT> <CODE>conditions</CODE>
<DD>
 a list of predicator whose type is <code>'a -&gt; bool
        </code>

<DT> <CODE>value</CODE>
<DD>
 the value to be examined.

</DL>
<DT> <B>Returns:</B>
<DD>
true if any of conditions returns true when applied to the <code>
        value</code>.
   

</DL>
</DL>
<HR>
<A NAME="ValsatisfyAll"><!-- --></A>
<H3>satisfyAll</H3>
<P>
<CODE>fun&nbsp;satisfyAll&nbsp;conditions&nbsp;value</CODE>
<DL>
<DD>
 build a predicator which is a conjunction of predicators.

<P>

<DD>
<DL>
<DT> <B>Parameters:</B>
<DD>
<DL>
<DT> <CODE>conditions</CODE>
<DD>
 a list of predicator whose type is <code>'a -&gt; bool
        </code>

<DT> <CODE>value</CODE>
<DD>
 the value to be examined.

</DL>
<DT> <B>Returns:</B>
<DD>
true if all of conditions return true when applied to the <code>
        value</code>.
   

</DL>
</DL>
<HR>
<A NAME="ValcompareStringNoCase"><!-- --></A>
<H3>compareStringNoCase</H3>
<P>
<CODE>fun&nbsp;compareStringNoCase&nbsp;(left,&nbsp;right)</CODE>
<DL>
<DD>
 case-insensitive version of <code>String.collate</code>

<P>

<DD>
<DL>
<DT> <B>Parameters:</B>
<DD>
<DL>
<DT> <CODE>left</CODE>
<DD>
 left string

<DT> <CODE>right</CODE>
<DD>
 right string

</DL>
<DT> <B>Returns:</B>
<DD>
<code>order</code>
   

</DL>
</DL>
<HR>
<A NAME="ValtokenizeString"><!-- --></A>
<H3>tokenizeString</H3>
<P>
<CODE>fun&nbsp;tokenizeString&nbsp;isDelimiter&nbsp;string</CODE>
<DL>
<DD>
 break a string into tokens (with escape interpretation facility).
 <p>
 Example:
 <pre>
 tokenizeString Char.isSpace " --header=Generated\\ by\\ SMLDoc\\ 1.0 foo.sml "
 </pre>
 returns
 <pre>
["--header=Generated by SMLDoc 1.0","foo.sml"]
 </pre>
 A charcter following a backslash is treated as an ordinary char.

<P>

<DD>
<DL>
<DT> <B>Parameters:</B>
<DD>
<DL>
<DT> <CODE>isDelimiter</CODE>
<DD>
 a function which receive a character and returns true
                    if it is a delimiter char.

<DT> <CODE>string</CODE>
<DD>
 a string

</DL>
<DT> <B>Exception:</B>
<DD>
<DL>
<DT> <CODE><A HREF="StrUtility.html#ExceptionMissingEscapedChar">MissingEscapedChar</A></CODE>
<DD>
 if the string ends a backslash which is
                    not escaped by preceding another backslash.
   

</DL>
</DL>
</DL>
<HR>
<A NAME="ValreplaceString"><!-- --></A>
<H3>replaceString</H3>
<P>
<CODE>fun&nbsp;replaceString&nbsp;oldString&nbsp;newString&nbsp;string</CODE>
<DL>
<DD>
  replaces string.
 <p>
  example:
 <pre>
 - Utility.replaceString "foo" "bar" "fooboofooboofoo";
 val it = (3,"barboobarboobar") : int * string
 </pre>
 </p>

<P>

<DD>
<DL>
<DT> <B>Parameters:</B>
<DD>
<DL>
<DT> <CODE>oldString</CODE>
<DD>
 the string to be replaced

<DT> <CODE>newString</CODE>
<DD>
 the string to be inserted

</DL>
<DT> <B>Returns:</B>
<DD>
a pair of <ul>
   <li>the number of replace performed</li>
   <li>the string in which occurrences of <code>oldString</code> are
     replaced with <code>newString</code></li>
 </ul>
   

</DL>
</DL>
<HR>
<A NAME="ValreplaceStringByTable"><!-- --></A>
<H3>replaceStringByTable</H3>
<P>
<CODE>val&nbsp;replaceStringByTable</CODE>

<HR>
<A NAME="ValreplaceFile"><!-- --></A>
<H3>replaceFile</H3>
<P>
<CODE>fun&nbsp;replaceFile&nbsp;keyValuePairs&nbsp;(srcFileName,&nbsp;destFileName)</CODE>
<DL>
<DD>
 replaces strings in the contents of a file.
 This function reads the contents of the source file and replaces the
 occurrences of the first element of a pair in the
 <code>keyValuePairs</code> with the second element of that pair.
 The result of replace is output to the destination file.


<P>

<DD>
<DL>
<DT> <B>Parameters:</B>
<DD>
<DL>
<DT> <CODE>keyValuePairs</CODE>
<DD>
 a list of pairs of oldString and newString

<DT> <CODE>srcFileName</CODE>
<DD>
 the name of source file

<DT> <CODE>destFileName</CODE>
<DD>
 the name of destination file

</DL>
<DT> <B>Returns:</B>
<DD>
unit
   

</DL>
</DL>
<P>

&nbsp;
<TABLE WIDTH="100%" BORDER="1" CELLSPACING="1" CELLPADDING="3">
<TR BGCOLOR="#CCCCFF">
<TH COLSPAN=1>
<FONT SIZE="+2">Exception detail</FONT>
</TH></TR></TABLE>
<A NAME="ExceptionMissingEscapedChar"><!-- --></A>
<H3>MissingEscapedChar</H3>
<P>
<CODE>exception&nbsp;MissingEscapedChar</CODE>
<DL>
<DD>
  raised by the <code>tokenizeString</code> if the string ends with
 a unescaped backslash.
   

<P>

<DD>
<DL>
</DL>
</DL>
<P>

<HR>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="1">
<TR>
<TD>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="3" CELLPADDING="0">
<TR ALIGN=CENTER VALIGN=TOP>
<TD BGCOLOR="#EEEEFF">
<B><A HREF="overview-summary.html">Overview</A></B>&nbsp;
</TD><TD BGCOLOR="#EEEEFF">
<B><A HREF="index-all.html">Index</A></B>&nbsp;
</TD><TD BGCOLOR="#EEEEFF">
<B><A HREF="help-doc.html">Help</A></B>&nbsp;
</TD></TR></TABLE>
</TD><TD ALIGN=RIGHT VALIGN=TOP>
<em>SMLDoc: Documentation generator for SML</em>
</TD></TR></TABLE>
</BODY></HTML>
