// VirtualMachineTestUtil
// jp_ac_jaist_iml_runtime

#include "VirtualMachine.hh"
#include "Executable.hh"
#include "Instructions.hh"

namespace jp_ac_jaist_iml_runtime
{

///////////////////////////////////////////////////////////////////////////////

/**
 * packs a bytes array of 4 elements into a 32bit word.
 *
 * @param bytes char array of 4 elements
 */
#define PACK_4BYTES_TO_WORD32(bytes) \
(WordOperations::pack_1_1_1_1((bytes)[0], (bytes)[1], (bytes)[2], (bytes)[3]))

/**
 *  synthesizes a 4 bytes word of the format with an instruction
 * and a 3 bytes word operand.
 *
 * @param instruction the opcode of the instruction
 * @param triByte 3 bytes word operand
 */
#define EMBED_INSTRUCTION_3(instruction, triByte) \
(WordOperations::pack_1_3(instruction, triByte))

/**
 *  synthesizes a 4 bytes word of the format with an instruction
 * and a 1 byte word and a 2 bytes word operand.
 *
 * @param instruction the opcode of the instruction
 * @param singleByte 1 byte operand
 * @param doubleByte 2 bytes word operand
 */
#define EMBED_INSTRUCTION_1_2(instruction, singleByte, doubleByte) \
(WordOperations::pack_1_1_2((instruction), (singleByte), (doubleByte)))

UInt32Value
embedString(UInt32Value* code, UInt32Value offset, const char* string)
{
    int stringLength = ::strlen(string);
    int index = 0;
    for(; index + 4 < stringLength; index += sizeof(UInt32Value)){
        code[offset++] = PACK_4BYTES_TO_WORD32(string + index);
    }
    // remaining characters and trailing '\0' are embedded.
    switch(stringLength - index){
      case 0:
        code[offset++] = 0; // terminater zeros.
        break;
      case 1:
        code[offset++] = WordOperations::pack_1_1_1_1(string[index], 0, 0, 0);
        break;
      case 2:
        code[offset++] =
        WordOperations::pack_1_1_1_1(string[index], string[index + 1], 0, 0);
        break;
      case 3:
        code[offset++] =
        WordOperations::pack_1_1_1_1(string[index],
                                     string[index + 1],
                                     string[index + 2],
                                     0);
        break;
    }
    return offset;
}

Executable*
buildExecutable(UInt32Value codeLength, UInt32Value code[])
{
    // NOTE: This function allocates objects from dynamic memory.
    //       This buffer is not released.
    //       Because this is for test code, memory leak can be ignored.

    // NOTE: totalLength and buffer will not be referenced to.
    UInt32Value totalLength = codeLength + 1;
    UInt32Value* buffer = (UInt32Value*)ALLOCATE_MEMORY(sizeof(UInt32Value));
    buffer[0] = codeLength;// the first word holds the number of words of code

    Executable *executable = new Executable(totalLength, buffer);
    executable->code = code;
    executable->codeWordLength = codeLength;

    return executable;
}

////////////////////////////////////////

class FunInfo
{
    ////////////////////////////////////////
  public:

    UInt32Value arity_;
    UInt32Value* argsDest_;
    UInt32Value bitmapvalsArgsCount_;
    UInt32Value* bitmapvalsArgs_;
    UInt32Value bitmapvalsFreesCount_;
    UInt32Value* bitmapvalsFrees_;
    UInt32Value pointers_;
    UInt32Value atoms_;
    UInt32Value recordGroupsCount_;
    UInt32Value* recordGroups_;

    ////////////////////////////////////////
  private:

    /** true, if argsDest_ is generated by a constructor, not passed from user.
     * Then, argsDest_ should be freed at destructor.
     */
    bool argsDestGenerated_;

    ////////////////////////////////////////
  public:

    FunInfo(UInt32Value arity,
            UInt32Value* argsDest,
            UInt32Value bitmapvalsArgsCount,
            UInt32Value* bitmapvalsArgs,
            UInt32Value bitmapvalsFreesCount,
            UInt32Value* bitmapvalsFrees,
            UInt32Value pointers,
            UInt32Value atoms,
            UInt32Value recordGroupsCount,
            UInt32Value* recordGroups)
        : arity_(arity),
          argsDest_(argsDest),
          bitmapvalsArgsCount_(bitmapvalsArgsCount),
          bitmapvalsArgs_(bitmapvalsArgs),
          bitmapvalsFreesCount_(bitmapvalsFreesCount),
          bitmapvalsFrees_(bitmapvalsFrees),
          pointers_(pointers),
          atoms_(atoms),
          recordGroupsCount_(recordGroupsCount),
          recordGroups_(recordGroups),
          argsDestGenerated_(false)
    {
    };

    FunInfo(UInt32Value arity,
            UInt32Value pointers,
            UInt32Value atoms)
        : arity_(arity),
          bitmapvalsArgsCount_(0),
          bitmapvalsArgs_(NULL),
          bitmapvalsFreesCount_(0),
          bitmapvalsFrees_(NULL),
          pointers_(pointers),
          atoms_(atoms),
          recordGroupsCount_(0),
          recordGroups_(NULL),
          argsDestGenerated_(true)
    {
        argsDest_ = new UInt32Value[arity];
    };

    FunInfo(UInt32Value pointers, UInt32Value atoms)
        : arity_(0),
          argsDest_(NULL),
          bitmapvalsArgsCount_(0),
          bitmapvalsArgs_(NULL),
          bitmapvalsFreesCount_(0),
          bitmapvalsFrees_(NULL),
          pointers_(pointers),
          atoms_(atoms),
          recordGroupsCount_(0),
          recordGroups_(NULL),
          argsDestGenerated_(false)
    {
    };

    ////////////////////////////////////////

    virtual
    ~FunInfo()
    {
        if(argsDestGenerated_){
            delete[] argsDest_;
        }
    }

    ////////////////////////////////////////

    /**
     *  the index of the entry which holds the record bitmap in a frame
     *
     */
    UInt32Value getBitmapEntry()
    {
        return 3;
    };

    /**
     * the entry index of the local pointer variable in a frame
     *
     * @param index the index of the target pointer variable within
     *            pointer local entries in the frame
     */
    UInt32Value getPointerEntry(UInt32Value index)
    {
        return (3 + (index) + 1);
    }

    /**
     * the entry index of the local atom variable in a frame
     *
     * @param index the index of the target atom variable within atom local
     *              entries in the frame
     */
    UInt32Value getAtomEntry(UInt32Value index)
    {
        return (3 + pointers_ + index + 1);
    }

    /**
     * the entry index of the local record variable in a frame
     *
     * @param index the index of the target record variable within record local
     *       entries in the frame
     */
    UInt32Value getRecordEntry(UInt32Value index)
    {
        return (3 + pointers_ + atoms_ + index + 1);
    }

    /**
     * the index of the PC slot entry in a frame
     *
     */
    UInt32Value getPCSlotEntry()
    {
        return (getFrameSize());
    }

    /**
     * the size of a stack frame (in 32bit words)
     *
     */
    UInt32Value getFrameSize()
    {
        UInt32Value size = 3; // frameSize, funInfo, bitmap
        size += pointers_;
        size += atoms_;
        for(int index = 0; index < recordGroupsCount_; index += 1){
            size += recordGroups_[index];
        }
        size += 1; // return address
        return size;
    }

    /**
     *  code sequence which sets up the function entry
     *
     */
    int embedFunEntry(UInt32Value* code, UInt32Value offset)
    {
        code[offset++] = EMBED_INSTRUCTION_3(FunEntry, 0);
        code[offset++] = arity_;
        for(int index = 0; index < arity_; index += 1){
            code[offset++] = argsDest_[index];
        }
        code[offset++] = bitmapvalsArgsCount_;
        for(int index = 0; index < bitmapvalsArgsCount_; index += 1){
            code[offset++] = bitmapvalsArgs_[index];
        }
        code[offset++] = bitmapvalsFreesCount_;
        for(int index = 0; index < bitmapvalsFreesCount_; index += 1){
            code[offset++] = bitmapvalsFrees_[index];
        }
        code[offset++] = getFrameSize();
        code[offset++] = pointers_;
        code[offset++] = atoms_;
        code[offset++] = recordGroupsCount_;
        for(int index = 0; index < recordGroupsCount_; index += 1){
            code[offset++] = recordGroups_[index];
        }
        return offset;
    }
};

///////////////////////////////////////////////////////////////////////////////


class SnapshotExecutionMonitor
    : public VirtualMachineExecutionMonitor
{
    ///////////////////////////////////////////////////////////////////////////

  public:
    
    int offset_;
    Executable* executable_;
    UInt32Value* PC_;
    Cell* ENV_;
    UInt32Value* SP_;

    ///////////////////////////////////////////////////////////////////////////

  public:
        
    SnapshotExecutionMonitor(int offset)
        :offset_(offset)
    {}

    virtual
    void beforeExecution(Executable* &executable,
                         UInt32Value* &PC,
                         Cell* &ENV,
                         UInt32Value* &SP)
    {
        executable_ = executable;
    }
};

class BeforeSnapshotExecutionMonitor
    : public SnapshotExecutionMonitor
{
    ///////////////////////////////////////////////////////////////////////////

  public:

    BeforeSnapshotExecutionMonitor(int offset)
        : SnapshotExecutionMonitor(offset)
    {}

    ///////////////////////////////////////////////////////////////////////////

  public:

    virtual
    void beforeInstruction(UInt32Value* &PC,
                           Cell* &ENV,
                           UInt32Value* &SP)
    {
        if(offset_ == (PC - executable_->code)){
            PC_ = PC;
            ENV_ = ENV;
            SP_ = SP;
        }
    }

};

class AfterSnapshotExecutionMonitor
    : public SnapshotExecutionMonitor
{
    ///////////////////////////////////////////////////////////////////////////

  public:

    AfterSnapshotExecutionMonitor(int offset)
        : SnapshotExecutionMonitor(offset)
    {}

    ///////////////////////////////////////////////////////////////////////////

  public:

    virtual
    void afterInstruction(UInt32Value* &PC,
                          Cell* &ENV,
                          UInt32Value* &SP)
    {
        if(offset_ == (PC - executable_->code)){
            PC_ = PC;
            ENV_ = ENV;
            SP_ = SP;
        }
    }
};
    
class BeforeExecutionMonitor : public VirtualMachineExecutionMonitor
{
    ///////////////////////////////////////////////////////////////////////////

  public:
        
    Executable* executable_;
    UInt32Value* PC_;
    Cell* ENV_;
    UInt32Value* SP_;

    ///////////////////////////////////////////////////////////////////////////

  public:
        
    virtual
    void beforeExecution(Executable* &executable,
                         UInt32Value* &PC,
                         Cell* &ENV,
                         UInt32Value* &SP)
    {
        executable_ = executable;
        PC_ = PC;
        ENV_ = ENV;
        SP_ = SP;
    }
};
    
class AfterExecutionMonitor : public VirtualMachineExecutionMonitor
{
    ///////////////////////////////////////////////////////////////////////////

  public:
        
    UInt32Value* PC_;
    Cell* ENV_;
    UInt32Value* SP_;

    ///////////////////////////////////////////////////////////////////////////

  public:
        
    virtual
    void afterExecution(UInt32Value* &PC,
                        Cell* &ENV,
                        UInt32Value* &SP)
    {
        PC_ = PC;
        ENV_ = ENV;
        SP_ = SP;
    }
};

///////////////////////////////////////////////////////////////////////////////

};
