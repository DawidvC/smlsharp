(**
 * @copyright (c) 2006, Tohoku University.
 * @author Liu Bochao
 * @version $Id: TopBasis.sml,v 1.27 2008/08/06 17:23:40 ohori Exp $
 *)
structure TopBasis =
struct
(**
 global context : 
  fixEnv : elaboration phase
  externalVarIDBasis : uniqueIdAllocation phase, 
                       a map from name to abstract index(a number)
  topTypeContext : type inference phase
  nameMap : module compiler phase
             its usage : 1. error detection for structure 
                         2. structure replication
                         3. open structure declaration
    For item 2 and 3, nameMap need to be looked up to generate
    static rebindings. These kind of rebindings are eliminated 
    by uniqueIdAllocation phase.
  globalIndexEnv : symbolic code generation phase, 
                   a map from abstract index to real index in the global array
  inlineEnv : inling phase
  functorEnv : functor linker phase
  globalSymbolEnv: a map from global IDs to globally unique symbol names.
   This is an workaround for native backend and separate compilation.
*)
  type context =
       {
        fixEnv : Fixity.fixity SEnv.map,
	externalVarIDBasis : VarIDContext.topExternalVarIDBasis,
        topTypeContext : InitialTypeContext.topTypeContext,
        nameMap : NameMap.topNameMap,
        globalSymbolEnv : DeclarationRecovery.globalSymbolEnv,
        globalIndexEnv : GlobalIndexEnv.globalIndexEnv,
	inlineEnv : InlineEnv.globalInlineEnv,
        functorEnv : FunctorLinker.functorEnv
       }

 (**
  glboal stamps : 
    boundTypeVarIDStamp : bound type variable
    exceptionGlobalTagStamp : exception tag field
    tyConIDKeyStamp : type constructor global identifier 
    externalVarID : free abstract index for external variable
  
  compileUnitStamp :
    count of current compilation unit.
    This is a workaround for sequential compilation by native backend.
  type stamps = 
       {
        compileUnitStamp : int,
        boundTypeVarIDStamp : BoundTypeVarID.id,
        exnTagIDKeyStamp : ExnTagID.id,
        tyConIDKeyStamp : TyConID.id,
        clusterIDKeyStamp : ClusterID.id,
        externalVarIDKeyStamp : ExternalVarID.id
       }
  *)           
           
 (**
  local context : 
   flattenedNamePathEnvOpt
          : generated by module compiler, consumed by type inference.
   FlattendNamePathEnv is a flattened name map. For example, the following 
   code
          structure S = struct val x = 1 end
          structure S = struct val y = true val z = 1.0 end
   corresponds to the nameMap generated by Module Compiler as follows:
              S -> {
                    { y -> $1.S.y,
                      z -> $1.S.z
                    }
                   }
   the flattened name map as follows:
              S.y -> $1.S.y
              S.z -> $1.S.z
   and the flattened Code as follows:
           $0.S.x = 1
           $1.S.y = true
           $1.S.z = 1.0
   Type inference type infers the above flattened code and generates the
   following type environment:
           $0.S.x : int 
           $1.S.y : bool
           $1.S.z : real
   Since $0.S.x should be hidden from the outside, we resort to the flattened
   name map above to reestablish the type environment as follows:
              S.y : int
              S.z : real

   typeContextOpt : generated by type inference, consumed by printer code
   generation
  *)
  type localContext = 
       {
        flattenedNamePathEnvOpt : NameMap.basicNameNPEnv option,
        typeContextOpt : TypeContext.context option,
        newTopExternalVarIDBasisOpt : VarIDContext.topExternalVarIDBasis option
       }
           
  type sysParam =
       {session : SessionTypes.Session,
        standardOutput : ChannelTypes.OutputChannel,
        standardError : ChannelTypes.OutputChannel,
        loadPathList : string list,
        getVariable : string -> string option}


 (**
  * compilation basis
  * context : global context, untouched during the compilation for one unit,
  * accumlated interactively
  * stamps : global stamps, updated during the comiplation for unit, passed
  * to the next compilation 
  * localContext : local context, accumulated during the compilation for one
  * unit, discarded  in the next compilation
  * sysParam : initialized at the beginning of compilation, never touched
  *)
  type compileUnitStamp = int

  fun initializeCompileUnitStamp () = 0

  type basis = 
       {
        context : context, 
        compileUnitStamp : compileUnitStamp,
        localContext : localContext,
        sysParam : sysParam
       }

  val emptyContext = 
      {
       fixEnv = SEnv.empty : Fixity.fixity SEnv.map,
       externalVarIDBasis =
         UniqueIdAllocationContext.emptyTopExternalVarIDBasis
         : VarIDContext.topExternalVarIDBasis,
       topTypeContext =
         InitialTypeContext.emptyTopTypeContext
         : InitialTypeContext.topTypeContext,
       nameMap = NameMap.emptyTopNameMap :  NameMap.topNameMap,
       globalSymbolEnv = DeclarationRecovery.emptyGlobalSymbolEnv,
       globalIndexEnv =
         GlobalIndexEnv.emptyGlobalIndexEnv : GlobalIndexEnv.globalIndexEnv,
       inlineEnv =
         InlineEnv.GIE ExternalVarID.Map.empty : InlineEnv.globalInlineEnv,
       functorEnv = SEnv.empty : FunctorLinker.functorEnv
      } : context
      

  fun initializeLocalContext () = 
      {
       flattenedNamePathEnvOpt = NONE,
       typeContextOpt = NONE,
       newTopExternalVarIDBasisOpt = NONE
      } : localContext

  fun initializeContext () =
      {
       fixEnv = Fixity.initialFixEnv,
       topTypeContext = InitialTypeContext.initialTopTypeContext,
       externalVarIDBasis =
         UniqueIdAllocationContext.initialTopExternalVarIDBasis,
       nameMap = InitialNameMap.initialTopNameMap,
       globalSymbolEnv = DeclarationRecovery.initialGlobalSymbolEnv,
       globalIndexEnv =  GlobalIndexEnv.initialGlobalIndexEnv,
       functorEnv = FunctorLinker.initialFunctorEnv,
       inlineEnv = InlineEnv.initialInlineEnv
      } : context

  fun extendContextFixEnv (context:context) newFixEnv =
      {
       fixEnv = SEnv.unionWith #1 (newFixEnv, #fixEnv context),
       externalVarIDBasis = #externalVarIDBasis context,
       topTypeContext = #topTypeContext context,
       nameMap = #nameMap context,
       globalSymbolEnv = #globalSymbolEnv context,
       globalIndexEnv = #globalIndexEnv context,
       inlineEnv = #inlineEnv context,
       functorEnv = #functorEnv context
      } : context

  fun extendContextNameMapWithCurrentNameMap (context:context) currentNameMap =
      {
       fixEnv = #fixEnv context,
       externalVarIDBasis = #externalVarIDBasis context,
       topTypeContext = #topTypeContext context,
       nameMap = NameMap.extendTopNameMapWithCurrentNameMap
                   {
                    currentNameMap = currentNameMap, 
                    topNameMap = #nameMap context
                   },
       globalSymbolEnv = #globalSymbolEnv context,
       globalIndexEnv = #globalIndexEnv context,
       inlineEnv = #inlineEnv context,
       functorEnv = #functorEnv context
      } : context

  fun extendContextTopTypeContextWithCurrentTypeContext
        (context:context) current =
      {
       fixEnv = #fixEnv context,
       externalVarIDBasis = #externalVarIDBasis context,
       topTypeContext =
         InitialTypeContext.extendTopTypeContextWithContext
           (#topTypeContext context) current,
       nameMap = #nameMap context,
       globalSymbolEnv = #globalSymbolEnv context,
       globalIndexEnv = #globalIndexEnv context,
       inlineEnv = #inlineEnv context,
       functorEnv = #functorEnv context
      } : context

  fun extendContextWithExternalVarIDBasis
        (context:context) externalVarIDBasis =
      {
       fixEnv = #fixEnv context,
       externalVarIDBasis = 
       VarIDContext.extendTopVarExternalVarIDBasisWithTopVarExternalVarIDBasis
         {new = externalVarIDBasis, old = #externalVarIDBasis context},
       topTypeContext = #topTypeContext context,
       nameMap = #nameMap context,
       globalSymbolEnv = #globalSymbolEnv context,
       globalIndexEnv = #globalIndexEnv context,
       inlineEnv = #inlineEnv context,
       functorEnv = #functorEnv context
      } : context

  fun extendContextFunctorEnv (context:context) newFunctorEnv =
      {
       fixEnv = #fixEnv context,
       externalVarIDBasis = #externalVarIDBasis context,
       topTypeContext = #topTypeContext context,
       nameMap = #nameMap context,
       globalSymbolEnv = #globalSymbolEnv context,
       globalIndexEnv = #globalIndexEnv context,
       inlineEnv = #inlineEnv context,
       functorEnv = SEnv.unionWith #1 (newFunctorEnv, (#functorEnv context))
      } : context

  fun setContextExternalVarIDEnv (context:context) externalVarIDBasis =
      {
       fixEnv = #fixEnv context,
       externalVarIDBasis = externalVarIDBasis,
       topTypeContext = #topTypeContext context,
       nameMap = #nameMap context,
       globalSymbolEnv = #globalSymbolEnv context,
       globalIndexEnv = #globalIndexEnv context,
       inlineEnv = #inlineEnv context,
       functorEnv = #functorEnv context
      } : context

  fun setContextInlineEnv (context:context) inlineEnv =
      {
       fixEnv = #fixEnv context,
       externalVarIDBasis = #externalVarIDBasis context,
       topTypeContext = #topTypeContext context,
       nameMap = #nameMap context,
       globalSymbolEnv = #globalSymbolEnv context,
       globalIndexEnv = #globalIndexEnv context,
       inlineEnv = inlineEnv,
       functorEnv = #functorEnv context
      } : context


  fun setContextGlobalIndexEnv (context:context) globalIndexEnv =
      {
       fixEnv = #fixEnv context,
       externalVarIDBasis = #externalVarIDBasis context,
       topTypeContext = #topTypeContext context,
       nameMap = #nameMap context,
       globalSymbolEnv = #globalSymbolEnv context,
       globalIndexEnv = globalIndexEnv,
       inlineEnv = #inlineEnv context,
       functorEnv = #functorEnv context
      }

  fun extendContextGlobalSymbolEnv (context:context) globalSymbolEnv =
      {
       fixEnv = #fixEnv context,
       externalVarIDBasis = #externalVarIDBasis context,
       topTypeContext = #topTypeContext context,
       nameMap = #nameMap context,
       globalSymbolEnv =
         DeclarationRecovery.extendGlobalSymbolEnv
           (#globalSymbolEnv context, globalSymbolEnv),
       globalIndexEnv = #globalIndexEnv context,
       inlineEnv = #inlineEnv context,
       functorEnv = #functorEnv context
      }

  fun incrementCompileUnitStamp compileUnitStamp =
       compileUnitStamp + 1

  (**************************************************************************)
  fun setBasisContext (basis:basis) context = 
      {
       context = context, 
       compileUnitStamp = #compileUnitStamp basis,
       localContext = #localContext basis,
       sysParam = #sysParam basis
      } : basis

  fun setBasisLocalContext (basis:basis) localContext = 
      {
       context = #context basis, 
       compileUnitStamp = #compileUnitStamp basis,
       localContext = localContext,
       sysParam = #sysParam basis
      } : basis

  fun setBasisCompileUnitStamp (basis:basis) compileUnitStamp =
      {
       context = #context basis, 
       compileUnitStamp = compileUnitStamp,
       localContext = #localContext basis,
       sysParam = #sysParam basis
      } : basis

 (***************************************************************************)
  fun setLocalContextFlattenedNamePathEnvOpt
        (localContext:localContext) flattenedNamePathEnv = 
      {
       flattenedNamePathEnvOpt = SOME flattenedNamePathEnv,
       typeContextOpt = #typeContextOpt localContext,
       newTopExternalVarIDBasisOpt = #newTopExternalVarIDBasisOpt localContext
      } : localContext

  fun setLocalContextTypeContextOpt (localContext:localContext) typeContext = 
      {
       flattenedNamePathEnvOpt = #flattenedNamePathEnvOpt localContext,
       typeContextOpt = SOME typeContext,
       newTopExternalVarIDBasisOpt = #newTopExternalVarIDBasisOpt localContext
      } : localContext

  fun setLocalContextNewExternalVarIDBasisOpt
        (localContext:localContext) externalVarIDBasis =  
      {
       flattenedNamePathEnvOpt = #flattenedNamePathEnvOpt localContext,
       typeContextOpt = #typeContextOpt localContext,
       newTopExternalVarIDBasisOpt = SOME externalVarIDBasis
      } : localContext
            
  fun getStandardOutputInBasis (basis : basis) = 
      #standardOutput (#sysParam basis)

  fun getStandardErrorInBasis (basis : basis) = 
      #standardError (#sysParam basis)

  fun getStandardOutputInSysParam (sysParam : sysParam) = 
      #standardOutput sysParam

  fun getStandardErrorInSysParam (sysParam : sysParam) = 
      #standardError sysParam


end
