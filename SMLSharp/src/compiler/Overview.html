<html>
<head>
<title>The Internals and Data Structures of the SML# Compiler Version 0.30.</title>
</head>
<body>

<hr>
<hr>

<h2>
Internals and data structures of the SML# Compiler 0.20.
</h2>

<dl>
<dt>authors</dt>
<dd>Atsushi Ohori and YAMATODANI Kiyoshi</dd>
<dt>version</dt>
<dd>$Id: Overview.html,v 1.16 2007/12/16 15:23:48 ohori Exp $</dd>
</dl>
<hr>

We intentd to report internal technical details and data structures of
the SML# compiler in some technical forum in near future. 
<P>
This section is for those technical minds who would like to read the
SML# Compiler Source code.
<P>
We believe that the following two tables are sufficient for you
to get started with the source code.
If you would like to know any particular aspect of the compiler, 
please  contact Atsushi Ohori (ohori at riec dot tohoku dot ac dot jp).


<center>
<h3>
the set of SML#  intermediate languages ver. 0.20
</h3>
<table border="1">
  <tr>
    <th>Language</th>
    <th>Structure Name</th>
    <th>Directory</th>
  </tr>
  <tr>
    <td>Abstract Syntax Trees</td>
    <td>Absyn</td>
    <td>compiler/absyn</td>
  </tr>
  <tr>
    <td>Untyped Pattern Expressions (1)</td>
    <td>PatternCalc</td>
    <td>compile/patterncalc</td>
  </tr>
  <tr>
    <td>Untyped Pattern Expressions (2)</td>
    <td>PatternCalcWithTvars</td>
    <td>compile/patterncalcWithTvars|</td>
  </tr>
  <tr>
    <td>Typed Pattern Expressions(1)</td>
    <td>TypedCalc</td>
    <td>compile/typedcalc</td>
  </tr>
  <tr>
    <td>Typed Pattern Expressions(2)</td>
    <td>TypedFlatCalc</td>
    <td>compile/typedflatcalc</td>
  </tr>
  <tr>
    <td>Polymorphic Record Calculus</td>
    <td>RecordCalc</td>
    <td>compile/recordcalc</td>
  </tr>
  <tr>
    <td>Typed Lambda Calculs</td>
    <td>TypedLambda</td>
    <td>compile/typedlambda</td>
  </tr>
  <tr>
    <td>Lambda Calculs with Static Annotation</td>
    <td>AnnotatedCalc</td>
    <td>compile/annotatedcalc</td>
  </tr>
  <tr>
    <td>Multiple Value Calculs</td>
    <td>MultipleValueCalc</td>
    <td>compile/multiplevaluecalc</td>
  </tr>
  <tr>
    <td>Cluster Calculs</td>
    <td>ClusterCalc</td>
    <td>compile/clustercalc</td>
  </tr>
  <tr>
    <td>Record/Bitmap-Passing Calculus</td>
    <td>RBUCCalc</td>
    <td>compile/rbucalc</td>
  </tr>
  <tr>
    <td>Typed A-Normal Form</td>
    <td>ANormal</td>
    <td>compile/anormal</td>
  </tr>
  <tr>
    <td>SML# Symbolict Instruction Set</td>
    <td>SymbolicInstructions</td>
    <td>compile/symbolicinstructions</td>
  </tr>
  <tr>
    <td>SML# Instruction</td>
    <td>Instructions</td>
    <td>instructions/compile/instructions</td>
  </tr>
  <tr>
    <td>SML# Bytecode Language</td>
    <td>Instructions.cc(definitions in C)</td>
    <td>instructions/runtime/instructions</td>
  </tr>
</table>
</center>

<center>
<h3>
the SML#  compilation steps ver. 0.20
</h3>
<table border="1">
  <tr>
    <th> Step </th>
    <th>description</th>
    <th>compile module</th>
    <th>directory</th>
    <th>input</th>
    <th>output</th>
  </tr>
  <tr>
    <td></td>
    <td>the compiler top level </td>
    <td>Top</td>
    <td>compile/toplevel</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>1.</td>
    <td>Parsing </td>
    <td>Parser</td>
    <td>compile/parse</td>
    <td>the source program </td>
    <td> Absyn</td>
  </tr>
  <tr>
    <td>2.</td>
    <td>Elaboration</td>
    <td>Elaborator</td>
    <td>compile/elaborate</td>
    <td>Absyn</td>
    <td>PattarnCalc</td>
  </tr>
  <tr>
    <td>3.</td>
    <td>function definition optimization</td>
    <td>VALREC_Optimizer</td>
    <td>compile/valrecoptimization</td>
    <td>PatternCalc</td>
    <td>PatternCalc</td>
  </tr>
  <tr>
    <td>4.</td>
    <td>simple function declaration elaboration (without uncurrying optimization)</td>
    <td>TransFundecl</td>
    <td>compile/valrecoptimization</td>
    <td>PatternCalc</td>
    <td>PatternCalc</td>
  </tr>
  <tr>
    <td>5.</td>
    <td>user type variable evaluation</td>
    <td>SetTVars</td>
    <td>compile/settvars</td>
    <td>PatternCalc</td>
    <td>PatternCalcWithTvars</td>
  </tr>
  <tr>
    <td>6.</td>
    <td>type inference</td>
    <td>TypeInferencer</td>
    <td>compile/typeinference</td>
    <td>PatternCalcWithTvars</td>
    <td>TypedCalc</td>
  </tr>
  <tr>
    <td>7.</td>
    <td>uncurrying optimization</td>
    <td>UncurryFundecl</td>
    <td>compile/typeinference</td>
    <td>TypedCalc</td>
    <td>TypedCalc</td>
  </tr>
  <tr>
    <td>8.</td>
    <td>printer code generation</td>
    <td>PrinterGenerator</td>
    <td>compile/printergeneration</td>
    <td>TypedCalc</td>
    <td>TypedCalc</td>
  </tr>
  <tr>
    <td>8.</td>
    <td>unique id allocation</td>
    <td>UniqueIDAllocation</td>
    <td>compile/uniqueidallocation</td>
    <td>TypedCalc</td>
    <td>TypedFlatCalc</td>
  </tr>
  <tr>
    <td>10.</td>
    <td>match compilation</td>
    <td>MatchCompiler</td>
    <td>compile/matchcompilation</td>
    <td>TypedFlatCalc</td>
    <td>RecordCalc</td>
  </tr>
  <tr>
    <td>11.</td>
    <td>Typed Lambda Normalization</td>
    <td>TLNormalization</td>
    <td>compile/tlnormalization</td>
    <td>RecordCalc</td>
    <td>TypedLambda</td>
  </tr>
  <tr>
    <td>12.</td>
    <td>Type Check</td>
    <td></td>
    <td>compile/typedlambda</td>
    <td>TypedLambda</td>
    <td>TypedLambda</td>
  </tr>
  <tr>
    <td>13.</td>
    <td>Static Analysis</td>
    <td></td>
    <td>compile/staticanalysis</td>
    <td>TypedLambda</td>
    <td>AnnotatedCalc</td>
  </tr>
  <tr>
    <td>14.</td>
    <td>Record Unboxing</td>
    <td>RecordUnboxing</td>
    <td>compile/recordunboxing</td>
    <td>AnnotatedCalc</td>
    <td>MultipleValueCalc</td>
  </tr>
  <tr>
    <td>15.</td>
    <td>Multiple value calculus optimization</td>
    <td>MVOptimization.sml</td>
    <td>compiler/mvoptimization</td>
    <td>MultipleValueCalc</td>
    <td>MultipleValueCalc</td>
  </tr>
  <tr>
    <td>16.</td>
    <td>function localization</td>
    <td>FunctionLocalize</td>
    <td>compiler/functionlocalize</td>
    <td>MultipleValueCalc</td>
    <td>MultipleValueCalc</td>
  </tr>
  <tr>
    <td>17.</td>
    <td>Type Check</td>
    <td>MVTypeCheck</td>
    <td>compile/multiplevaluecalc</td>
    <td>MultipleValueCalc</td>
    <td>MultipleValueCalc</td>
  </tr>
  <tr>
    <td>18.</td>
    <td>Functor Linker</td>
    <td>FunctorLinker</td>
    <td>compiler/functorlinker</td>
    <td>MultipleValueCalc</td>
    <td>MultipleValueCalc</td>
  </tr>
  <tr>
    <td>19.</td>
    <td>Clustering</td>
    <td>Clustering</td>
    <td>compiler/clustering</td>
    <td>MultipleValueCalc</td>
    <td>ClusterCalc</td>
  </tr>
  <tr>
    <td>20.</td>
    <td>Record/Bitmap/unbox/closure conversion</td>
    <td>RBUTransformation</td>
    <td>compile/rbutransformation</td>
    <td>ClusterCalc</td>
    <td>RBUCalc</td>
  </tr>
  <tr>
    <td>21.</td>
    <td>A-normalization</td>
    <td>ANormalTranslator</td>
    <td>compile/anormaltransform</td>
    <td>RBUCalc</td>
    <td>ANormal</td>
  </tr>
  <tr>
    <td>22.</td>
    <td>generate intermediate language</td>
    <td>ILTransformation</td>
    <td>compile/iltransformation</td>
    <td>ANormal</td>
    <td>IntermediateLanguage</td>
  </tr>
  <tr>
    <td>23.</td>
    <td>symbolic code generation</td>
    <td>Linearizer</td>
    <td>compile/linearize</td>
    <td>ANormal</td>
    <td>SymbolicInstructions</td>
  </tr>
  <tr>
    <td>24.</td>
    <td>stack slot optimization</td>
    <td>Reallocater</td>
    <td>compile/sioptimization</td>
    <td>SymbolicInstructions</td>
    <td>SymbolicInstructions</td>
  </tr>
  <tr>
    <td>25.</td>
    <td>assemble</td>
    <td>Assembler</td>
    <td>compile/assemble</td>
    <td>SymbolicInstructions</td>
    <td>Instructions</td>
  </tr>
  <tr>
    <td>26.</td>
    <td>code emmition</td>
    <td>ExecutableSerializer</td>
    <td>instructions/compiler</td>
    <td>Instructions</td>
    <td>(bytecode in binary form)</td>
  </tr>
</table>
</center>

<hr>

</body>
</html>
