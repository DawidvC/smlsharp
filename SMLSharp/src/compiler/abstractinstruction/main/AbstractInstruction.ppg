(* -*- sml -*- *)
(**
 * Abstract Instructions.
 * @copyright (c) 2007, Tohoku University.
 * @author UENO Katsuhiro
 * @version $Id: AbstractInstruction.ppg,v 1.12 2008/08/06 17:23:39 ohori Exp $
 *)

structure AbstractInstruction =
struct

  structure Target = TargetProperty(VMTarget)
  structure Formatter = TargetPlatformFormatter(Target)

  local
    fun format_word_asInt x =
        [SMLFormat.BasicFormatters.format_string (Word.fmt (StringCvt.DEC) x)]

    fun formatMap foldli formatKey (formatter,prefix,sep,suffix) map =
        foldli
            (fn (k,v,z) =>
                z @ prefix @ formatKey k @ sep @ formatter v @ suffix)
            nil map

    fun formatIDMap x y =
        formatMap VarID.Map.foldli VarID.format_id x y
    fun formatSEnv x y =
        formatMap SEnv.foldli SMLFormat.BasicFormatters.format_string x y
  in

  (*% @formatter(Target.uint) Formatter.format_uint *)
  type targetUInt = Target.uint

  (*% @formatter(Target.sint) Formatter.format_sint *)
  type targetSInt = Target.sint

  (*% @formatter(Loc.loc) Loc.format_loc *)
  type loc = Loc.loc

  (*% @formatter(VarID.id) VarID.format_id *)
  type id = VarID.id

  (*% @formatter(ANormal.ffiAttributes) ANormal.format_ffiAttributes *)
  type ffiAttributes = ANormal.ffiAttributes

  (*% *)
  type label =
       (*% @format(id) "L" id *)
       id

  (*% @formatter(ClusterID.id) ClusterID.format_id *)
  type clusterId =
       (*% @format(id) "C" id *)
       ClusterID.id

  (*% *)
  datatype tag =
      (*% @format "1" *)
      Boxed
    | (*% @format "0" *)
      Unboxed
    | (*% @format(p) "tag=" p *)
      ParamTag of paramInfo
    | (*% @format({offset, bit}) "tag=Env[" offset ":" bit "]" *)
      IndirectTag of {offset: targetUInt, bit: word}
(*
    | VarTag of varInfo

    All tag informations must be given from outside of cluster.
    This is due to restriction of bitmap calculation. If we allow
    polymorphic tail call between two functions in same cluster,
    such as polymorphic recursion and polymorphic inner functions,
    we need to allow to save tag information into local variables
    and modify it in cluster.
*)

  (* TODO: we need more types! *)
  and ty =
      (*% @format(u) u *)
      UNION of union
    | UINT                (* unsigned int *)
    | SINT                (* singed int *)
    | BYTE                (* unsigned char < UINT *)
    | CHAR                (* signed char < UINT *)
    | BOXED               (* pointer to heap (tagged for GC) *)
    | HEAPPOINTER         (* pointer to middle of heap *)
    | CODEPOINTER         (* pointer to code *)
    | CPOINTER            (* arbitrary pointer of C *)
    | ENTRY               (* pointer to cluster entry (clusterId * entryAddr) *)
    | EXNTAG              (* pointer as exception tag *)
    | FLOAT               (* single precision floating-point *)
    | DOUBLE              (* double precision floating-point *)
    | INDEX               (* < UINT? *)
    | BITMAP              (* < UINT? *)
    | OFFSET              (* < UINT? *)
    | SIZE                (* < UINT? *)
    | TAG                 (* < UINT? *)
    | ATOMty              (* deprecated *)
    | DOUBLEty            (* deprecated *)

  withtype paramInfo =
      (*%
       * @format({id, ty, displayName})
       * "p" id d ":" d ty
       *)
      { id: id, ty: ty, displayName: string }

  and varInfo =
      (*%
       * @format({id, ty, displayName})
       * "v" id d ":" d ty
       *)
      { id: id, ty: ty, displayName: string }

  and union =
      (*%
       * @format({variants: ty tys, tag})
       * "{" { tys(ty)(d "+") 3 ":" tag "}" }
       *)
      { variants: ty list, tag: tag }

  val allTys =
      [UINT, SINT, BYTE, CHAR, BOXED, HEAPPOINTER, CODEPOINTER, CPOINTER,
       ENTRY, FLOAT, DOUBLE, INDEX, BITMAP, OFFSET, SIZE, TAG, EXNTAG]

  (* for YASIGenerator *)
  (*% *)
  datatype sisize =
      (*% @format "<1>" *)
      SISINGLE
    | (*% @format "<2>" *)
      SIDOUBLE
    | (*% @format(v) "<" v ">" *)
      SIVARIANT of varInfo
    | (*% @format(v) "<" v ">" *)
      SIPARAMVARIANT of paramInfo
    | (*% @format "_" *)
      SIIGNORE

  (*% *)
  datatype objectType =
      Array
    | Vector
    | Record

  (* for YASIGenerator *)
  type globalIndex =
       {arrayIndex: BasicTypes.UInt32, offset: BasicTypes.UInt32}

  (* for YASIGenerator *)
  datatype globalValue =
      GLOBAL_VAR of globalIndex
    | GLOBAL_TAG of BasicTypes.UInt32

  (*% *)
  type globalLabel =
       (*% @format({label, value}) label *)
       {
         label: string,
         value: globalValue option  (* for YASIGenerator *)
       }

  (*% *)
  datatype value =
      (*% @format(x) x "U" *)
      UInt of targetUInt
    | (*% @format(x) x *)
      SInt of targetSInt
    | (*% @format(x) x "d" *)
      Real of string
    | (*% @format(x) x "f" *)
      Float of string
    | (*% @format(x) x *)
      Var of varInfo
    | (*% @format(x) x *)
      Param of paramInfo
    | (*% @format(x) "e" x *)
      Exn of paramInfo            (* handled exception *)
    | (*% *)
      Env                         (* closure environment. cluster local *)
    | (*% *)
      Empty                       (* empty block in ML *)
    | (*% *)
      Nowhere                     (* null code pointer *)
    | (*% *)
      Null                        (* null C pointer *)
    | (*% @format(id) "c" id *)
      Const of id                 (* constant heap object : BOXED *)
    | (*% @format(id) "i" id *)
      Init of id                  (* data for initialization : HEAPPOINTER *)
    | (*% @format({clusterId, entry}) clusterId ":" entry *)
      (* entry address of ML function *)
      Entry of {clusterId: clusterId, entry: label}
    | (*% @format(l) l *)
      (* local label *)
      Label of label
    | (*% @format({ty, label}) "GLOBAL:" label ":" ty *)
      (* global label declared in same linkage unit *)
      Global of {ty: ty, label: globalLabel}
    | (*% @format({ty, label}) label "@EXT" ":" ty *)
      (* global label declared in other linkage unit *)
      Extern of {ty: ty, label: globalLabel}

  (*%
   * @formatter(BigInt.int) SmlppgUtil.format_BigInt
   * @formatter(str) Formatter.format_string_ML
   * @formatter(hex) Formatter.format_uint_hex
   *)
  datatype const =
      (*% @format(x) x:str *)
      ConstString of string
    | (*% @format(x) x *)
      ConstReal of string
    | (*% @format(x) x *)
      ConstIntInf of BigInt.int
    | (*%
       * @format({objectType,
       *          bitmaps: bitmap bitmaps,
       *          payloadSize,
       *          fields: field fields})
       * { "(" { objectType ","
       *         +5 "bitmaps=[" { bitmaps(bitmap)("," +d) "]" } ","
       *         +5 "size=" payloadSize ","
       *         +4 fields(field)("," +4) } ")" }
       * 
       * @format:field({size, value})
       * { size +1 ":" 2[ +2 value ] }
       *)
      ConstObject of
      {
        objectType: objectType,
        bitmaps: targetUInt list,
        payloadSize: targetUInt,
        fields: {size: targetUInt, value: value} list
      }
(*
    | (*% @format(x) x "U" *)
      ConstUInt of targetUInt
    | (*% @format(x) x *)
      ConstSInt of targetSInt
    | (*% @format(x) "c" x *)
      ConstRef of id
    | (*%
       * @format({bitmap, totalSize, values: value values})
       * "(" values(value)("," +) ")" + ":" + bitmap:hex + ":" + totalSize
       *)
      ConstBlock of {bitmap: targetUInt, totalSize: targetUInt,
                     values: const list}
*)

  (*% *)
  datatype extCallee =
      (*% @format({oldPrimName, name, hasEffect, builtin}) "PRIM:" name *)
      Primitive of
      {
        oldPrimName: string, (* for YASIGenerator *)
        name: string,
        hasEffect: bool,
        builtin: bool
      }
    | (*%
       * @format({function, attributes})
       * "EXT:" attributes ":" function
       *)
      Foreign of {function: value, attributes: ffiAttributes}

  (*% @params(x) *)
  datatype op1 =
      (*% @format "-" x *)
      Neg
    | (*% @format "abs(" x ")" *)
      Abs
    | (*% @format "Cast(" x ")" *)
      (* data representation conversion *)
      Cast
    | (*% @format "~" x *)
      Notb
    | (*% @format "Length(" x ")" *)
      (* array length in bytes *)
      Length

  (*% @params(x,y) *)
  datatype op2 =
      (*% @format L5{ x +1 "+" +2 y } *)
      Add
    | (*% @format L5{ x +1 "-" +2 y } *)
      Sub
    | (*% @format L6{ x +1 "*" +2 y } *)
      Mul
    | (*% @format L6{ x +1 "/" +2 y } *)
      Div
    | (*% @format L6{ x +1 "%" +2 y } *)
      Mod
    | (*% @format "div(" { x "," +2 y } ").quot" *)
      Quot
    | (*% @format "div(" { x "," +2 y } ").rem" *)
      Rem
    | (*% @format L2{ x +1 "<" +2 y } *)
      Lt
    | (*% @format L2{ x +1 ">" +2 y } *)
      Gt
    | (*% @format L2{ x +1 "<=" +2 y } *)
      Lteq
    | (*% @format L2{ x +1 ">=" +2 y } *)
      Gteq
    | (*% @format L2{ x +1 "==" +2 y } *)
      (* monomorphic equality *)
      MonoEqual
    | (*% @format L3{ x +1 "&" +2 y } *)
      Andb
    | (*% @format L3{ x +1 "|" +2 y } *)
      Orb
    | (*% @format L3{ x +1 "^" +2 y } *)
      Xorb
    | (*% @format L3{ x +1 "<<" +2 y } *)
      LShift
    | (*% @format L3{ x +1 ">>" +2 y } *)
      RShift
    | (*% @format L3{ x +1 ">>>" +2 y } *)
      ArithRShift

  (*% *)
  datatype barrier =
      (*% @format *)
      NoBarrier
    | (*% @format "," +5 "barriered" *)
      WriteBarrier
    | (*% @format(v) "," +5 "barrier=" v *)
      BarrierTag of value

  (*%
   * @formatter(word) format_word_asInt
   * @formatter(enclosedOpt) SmlppgUtil.formatEnclosedOpt
   * @formatter(enclosedList) SmlppgUtil.formatListWithEnclosureIfMoreThanOne
   * @formatter(choice) SmlppgUtil.formatBinaryChoice
   * @formatter(Target.Instruction.instruction)
   *            Target.Instruction.format_instruction
   *)
  datatype instruction =
      (*%
       * @format({dst, ty, value, loc, size})
       * { dst + "=" 4[ +3 value 4[ +2 "as" + ty ";" ] ]
       * +2 "[" "si" "=" size "]" }
       *)
      Move of
      {
        dst: varInfo,
        ty: ty,              (* unnecessary? *)
        value: value,
        loc: loc,
        size: sisize         (* for YASIGenerator *)
      }
    | (*%
       * @format({dst, ty, block, offset, size, loc})
       * { dst + "=" 4[ +3 block 4 "[" { offset "," +4 "size=" size "]" }
       * 4[ +2 "as" + ty ";" ] ] }
       *)
      Load of
      {
        dst: varInfo,
        ty: ty,
        block: value,
        offset: value,
        size: value,
        loc: loc
      }
     | (*%
        * @format({block, offset, ty, size, value, barrier, loc})
        * { block "[" { offset "," +4 "size=" size barrier "]" } +d "="
        * 4[ +3 value 4[ +2 "as" + ty ";" ] ] }
        *)
      Update of
      {
        block: value,
        offset: value,
        ty: ty,
        size: value,
        value: value,
        barrier: barrier,
        loc: loc
      }
    | (*%
       * @format({dst, objectType, bitmaps: bitmap bitmaps,
       *          payloadSize, fieldInfo, loc})
       * { dst + "=" 4[ +3 "Alloc("
       *    { objectType ","
       *      +4 "bitmaps=[" { bitmaps(bitmap)("," +d) "]" } ","
       *      +4 "size=" payloadSize ")" } ] }
(*
       * fieldInfo
       * @format:fieldInfo(f fs)
       * 5[ 1 "::" + fs(f)(","+) ]
       * @format:f({size, tag})
       * "(" size "," tag ")"
*)
       *)
      Alloc of
      {
        dst: varInfo,
        objectType: objectType,
        bitmaps: value list,
        payloadSize: value,
        fieldInfo: {size: sisize, tag: tag} list,  (* only for YASIGenerator *)
        loc: loc
      }
    | (*%
       * @format({dst, op1: op1 * ty1 * ty, arg, loc})
       * { dst + "=" 4[ +3 op1()(arg)
       *             4[ +2 "as" + {ty1 +4 "->" + ty} ";" ] ] }
       *)
      PrimOp1 of
      {
        dst: varInfo,
        op1: op1 * ty * ty,
        arg: value,
        loc: loc
      }
    | (*%
       * @format({dst, op2: op2 * ty1 * ty2 * ty, arg1, arg2, loc})
       * { dst + "=" 4[ +3 op2()(arg1, arg2)
       *             4[ +2 "as" + {"(" { ty1 "," +4 ty2 ")" }
       *                            +6 "->" +7 ty} ";" ] ] }
       *)
      PrimOp2 of
      {
        dst: varInfo,
        op2: op2 * ty * ty * ty,
        arg1: value,
        arg2: value,
        loc: loc
      }
    | (*%
       * @format({dstVarList: dst dsts:enclosedList,
       *          callee,
       *          argList: arg args,
       *          calleeTy: argTy argTys * retTy retTys:enclosedList,
       *          loc})
       * { 1[ dsts(dst)("," +4, "(", ")") ] + "="
       *     4[ +3 callee "(" { args(arg)("," +3) } ")"
       *       4[ +2 "as" + { "(" { argTys(argTy)("," +3) } ")"
       *          +2 "->" + { retTys(retTy)("," +3, "(", ")") } ";" } ] ] }
       *)
      CallExt of
      {
        dstVarList: varInfo list,
        callee: extCallee,
        argList: value list,
        calleeTy: ty list * ty list,
        loc: loc
      }
    | (*%
       * @format({dstVarList: dst dsts:enclosedList,
       *          entry, env,
       *          argList: arg args,
       *          argTyList: argTy argTys,
       *          resultTyList: retTy retTys,
       *          argSizeList,
       *          loc})
       * { 1[ dsts(dst)("," +4, "(", ")") ] + "="
       *     4[ +3 entry "<" env ">" "(" { args(arg)("," +3) } ")"
       *       4[ +2 "as" + { "(" { argTys(argTy)("," +3) } ")"
       *                      +2 "->" + "(" { retTys(retTy)("," +4) } ")" }
       *        ] ] }
       *)
      Call of
      {
        dstVarList: varInfo list,
        entry: value,
        env: value,
        argList: value list,
        argTyList: ty list,          (* unnecessary? *)
        resultTyList: ty list,       (* unnecessary? *)
        argSizeList: sisize list,    (* for YASIGenerator *)
        loc: loc
      }
    | (*%
       * @format({entry, env,
       *          argList: arg args,
       *          argTyList: argTy argTys,
       *          resultTyList: retTy retTys,
       *          argSizeList,
       *          loc})
       * { entry "<" env ">" "(" { args(arg)("," +3) } ")"
       *   4[ +2 "as" + { "(" { argTys(argTy)("," +3) } ")"
       *                  +2 "->" + "(" { retTys(retTy)("," +4) } ")" } ] }
       *)
      (*
       * NOTE: TailCall should not be in a block which has a handler.
       *)
      TailCall of
      {
        entry: value,
        env: value,
        argList: value list,
        argTyList: ty list,          (* unnecessary? *)
        resultTyList: ty list,       (* unnecessary? *)
        argSizeList: sisize list,    (* for YASIGenerator *)
        loc: loc
      }
    | (*%
       * @format({dst, entry, env,
       *          exportTy: argTy argTys * retTy retTys,
       *          loc})
       * { dst + "=" 4[ +3 "ExportClosure(" entry "," + env ")"
       *             4[ +2 "as" + { "(" { argTys(argTy)("," +3) } ")"
       *                +2 "->" + "(" { retTys(retTy)("," +3) } ");" } ] ] }
       *)
      ExportClosure of
      {
        dst: varInfo,
        entry: value,
        env: value,
        exportTy: ty list * ty list,
        loc: loc
      }
    | (*%
       * @format({valueList: value values, tyList: ty tys, valueSizeList, loc})
       * { "return" + { values(value)("," +3) }
       *   4[ +2 "as" + "(" { tys(ty)("," +3) } ")" ";" ] }
       *)
      Return of
      {
        valueList: value list,
        tyList: ty list,             (* unnecesarry? *)
        valueSizeList: sisize list,  (* for YASIGenerator *)
        loc: loc
      }
    | (*%
       * @format({op2: op2 * ty1 * ty2 * ty, value1, value2,
       *          thenLabel, elseLabel, loc})
       * { "if" 4[ +3 op2()(value1, value2)
       *        4[ +2 "as" + {"(" { ty1 "," +4 ty2 ")" }
       *                        +6 "->" +7 ty} ] ]
       *   +1 "then" + "goto" + thenLabel
       *   +1 "else" + "goto" + elseLabel }
       *)
      If of
      {
        value1: value,           (* preferred for variable *)
        value2: value,           (* preferred for constant *)
        op2: op2 * ty * ty * ty,
        thenLabel: label,
        elseLabel: label,
        loc: loc
      }
    | (*%
       * @format({exn, loc})
       * { "raise" + exn ";" }
       *)
      Raise of
      {
        exn: value,
        loc: loc
      }
    | (*%
       * @format({block, offset, passLabel, failLabel, loc})
       * { 4[ +3 "checkBoundary(" { "array=" block "," +3
       *                            "offset=" offset "," +3 ")" } ]
       *   +1 "pass" + "=>" + passLabel ","
       *   +1 "fail" + "=>" + failLabel }
       *)
      (* If offset >= length(block), then goto passLabel,
       * else goto failLabel. *)
      CheckBoundary of
      {
        block: value,
        offset: value,
        passLabel: label,
        failLabel: label,
        loc: loc
      }
    | (*%
       * @format({label, knownDestinations: dest dests, loc})
       * { "goto" +d label ";" }
       * 5[ +1 "-->" +d {dests(dest)("," +1)} ]
       *)
      Jump of
      {
        label: value,
        knownDestinations: label list,
        loc: loc
      }

  (*%
   * @formatter(choice) SmlppgUtil.formatBinaryChoice
   *)
  (*% @prefix format_valof_
   * @formatter(label) format_label
   * @formatter(varInfo) format_varInfo
   *)
  datatype handler =
      (*% @format *)
      (*% @prefix format_valof_ @format "NoHandler" *)
      NoHandler
    | (*%
       * @format(label)
       * 1 "#" + "handle" + "=>" + "goto" + label
       *)
      (*% @prefix format_valof_ @format(label) label *)
      StaticHandler of label
    | (*%
       * @format({current, outside, handlers: handler handlers})
       * 1 "#" + "handle" + "=>" + "goto" + "*" current
       * + "(" { handlers(handler)("," +d)
       * outside:choice()("," +d "OUTSIDE",)
       * ")" }
       *)
      (*% @prefix format_valof_
       * @format({current, outside, handlers}) current *)
      DynamicHandler of
      {
        current: varInfo,        (* variable holding current handler address *)
        outside: bool,           (* true if raise may go outside *)
        handlers: label list     (* handlers which may be available *)
      }

  (*% *)
  datatype handlerChange =
      (*% @format({popHandlerLabel})  "Push->" popHandlerLabel *)
      PushHandler of {popHandlerLabel: label}
    | (*% @format({pushHandlerLabel}) pushHandlerLabel "->Pop" *)
      PopHandler of {pushHandlerLabel: label}

  (*%
   * @formatter(boolOpt) format_boolOpt
   * @formatter(handler') format_valof_handler
   *)
  datatype blockKind =
      (* just an ordinary basic block *)
      Basic
    | (* *)
      Branch
    | (* *)
      Merge
    | (* loop header *)
      Loop
    | (* continuation of local call *)
      LocalCont
    | (*%
       * @format(var)
       * "Handler" + var
       *)
      Handler of paramInfo
    | (*%
       * @format({change: ch chopt, previousHandler})
       * "ChangeHandler" + chopt(ch) + "from" +2 previousHandler:handler'
       *)
      (*
       * Exception handler is changed at the beginning of this block
       * (after entering this block, before executing any instructions
       * in this block).
       * "previousHandler" indicates previously enabled exception handler,
       * and "handler" of basicBlock indicates new one.
       *)
      ChangeHandler of
      {change: handlerChange option, previousHandler: handler}
    | (*%
       * @format(param params)
       * "FunEntry" 2[ +1
       * "#" + { "params = (" 4[ 2 params(param)("," +2) ] 2 ")" } ]
       *)
      FunEntry of paramInfo list
    | (* *)
      CodeEntry
    | (* *)
      BoundaryCheckFailed

  (*%
   * @formatter(VarID.Map.map) formatIDMap
   *)
  type basicBlock =
      (*%
       * @format({label,
       *          blockKind,
       *          handler,
       *          instructionList: insn insns,
       *          loc})
       * (* loc 1 *)
       * "BEGIN" + label + ":" + blockKind
       * 2[ handler
       *    1 insns(insn)(1)
       *  ]
       *)
      {
        label: label,
        blockKind: blockKind,
        handler: handler,
        instructionList: instruction list,
        loc: loc
      }

  (*% *)
  type cluster =
       (*%
        * @format({name,
        *          body: block blocks,
        *          loc})
        * +1 "cluster" + name +1
        * "{"
        *    2[
        *       +1 "loc" + "=" + loc
        *       +1 1 blocks(block)(1 1)
        *     ] 1
        * "}"
        *)
       {
         name: clusterId,
         body: basicBlock list,
         loc: loc
       }

  (*%
   * @formatter(VarID.Map.map) formatIDMap
   * @formatter(SEnv.map) formatSEnv
   *)
  type program =
       (*%
        * @format({toplevel: top topopt,
        *          clusters: cluster clusters,
        *          constants: const consts,
        *          globals: global globals,
        *          aliases: alias aliases})
        * "Toplevel:" topopt(top) 1
        * "Clusters:"
        * 2[ clusters(cluster)(+1) ]
        * +1 1 "Constants:"
        * 2[ consts(const)(1 "c",+ "=" +,";") ]
        * +1 1 "Globals:"
        * 2[ globals(global)(1, ":" +,) ]
        * +1 1 "Aliases:"
        * 2[ aliases(alias)(1, ":" +,) ]
        * @format:top({clusterId, funLabel}) clusterId ":" funLabel
        * @format:alias(a al) al(a)("," +)
        *)
       {
         toplevel: {clusterId: clusterId, funLabel: id} option,
         clusters: cluster list,
         constants: const VarID.Map.map,  (* constId -> const *)
         globals: ty SEnv.map,          (* globalLabel -> ty *)
         aliases: string list SEnv.map  (* globalLabel -> alias label list *)
       }

  end
end
