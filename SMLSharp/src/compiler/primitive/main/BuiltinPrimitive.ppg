(* -*- sml -*- *)
(**
 * built-in primitives.
 * @copyright (c) 2009, Tohoku University.
 * @author UENO Katsuhiro
 * @version $Id: $
 *)
structure BuiltinPrimitive =
struct

  (*
   * Each primitive whose name ends with "_unsafe" doesn't check validity
   * which specification of Basis Library requires.
   *)

  (*% *)
  datatype ov_=
      (*% @format "ov" *) OverflowCheck
    | (*% @format *) NoOverflowCheck

  (*
   * This file is not only program but source file for generating
   * BuiltinPrimitiveInfo.sml which have information of each primitive
   * including type information.
   * You need to write each primitives in the following syntax:
   *
   * (1)  <PrimName>  (* => <Expression> *)
   *  <Expression> is expanded as is to BuiltinPrimitiveInfo.sml.
   *
   * (2)  <PrimName>  (* <Type> [/ <Exception>, <Exception>, ...] [+ effect] *)
   *  <Type> is type of <PrimName>.
   *  If <Exception>s exist, this primitive may raise those exceptions.
   *  If +effect exist, this primitive may have side-effect.
   *)

  (*% *)
  (* These special form are translated to terms of intermediate languages.
   * ToDo: these are to be merged to either primitives or an intermadiate
   * language.
   *)
  datatype specialForm =
      Assign                (* ['a.('a)ref * 'a -> unit] + effect *)
    | Array_array           (* ['a.int * 'a -> ('a)array] / Size *)
    | Array_vector          (* ['a.int * 'a -> ('a)array] / Size *)
    (* native runtime generates boundary check code, so Array_sub_unsafe is safe. *)
    | Array_sub_unsafe      (* ['a.('a)array * int -> 'a] *)
    (* native runtime generates boundary check code, so Array_update_unsafe is safe. *)
    | Array_update_unsafe   (* ['a.('a)array * int * 'a -> unit] + effect *)
    (* Array_copy_unsafe doesn't check boundary. *)
    | Array_copy_unsafe     (* ['a.('a)array * int * ('a)array * int * int -> unit] + effect *)
    |  List_first            (* ['a.('a)list * ('a)list -> ('a)list] *)
    |  List_second            (* ['a.('a)list * ('a)list -> ('a)list] *)
    |  Array_first           (* ['a.('a)array * ('a)array -> ('a)array] *)
    |  Array_second           (* ['a.('a)array * ('a)array -> ('a)array] *)
    |  Int_first              (* int * int -> int *)
    |  Real_second            (* real * real -> real *)

  (*% *)
  (*
   * Each primitive is either
   * (1) a machine-level primitive operation, or
   * (2) a foreign function with which compiler need to deal in a
   *     special way. (overloaded, inline-expanded, etc.)
   * If it is not needed for a functionality to be taken special care
   * by compiler, it should be implemented as a ordinary foreign function,
   * not a primitive.
   *)
  datatype primitive =
      (* RuntimePrim is provided for backward compatibility. *)
      RuntimePrim of string (* => raise Control.Bug "RuntimePrim" *)
    | PolyEqual             (* [''a.''a * ''a -> bool] *)
    | ObjectEqual           (* [''a::boxed.''a * ''a -> bool] *)
    | PointerEqual          (* ['a::boxed.'a * 'a -> bool] *)
    | Array_length          (* ['a.('a)array -> int] *)
    | Byte_add              (* Word8.word * Word8.word -> Word8.word *)
    | Byte_div              (* Word8.word * Word8.word -> Word8.word / Div *)
    | Byte_equal            (* Word8.word * Word8.word -> bool *)
    | Byte_fromInt          (* int -> Word8.word *)
    | Byte_gt               (* Word8.word * Word8.word -> bool *)
    | Byte_gteq             (* Word8.word * Word8.word -> bool *)
    | Byte_lt               (* Word8.word * Word8.word -> bool *)
    | Byte_lteq             (* Word8.word * Word8.word -> bool *)
    | Byte_mod              (* Word8.word * Word8.word -> Word8.word / Div *)
    | Byte_mul              (* Word8.word * Word8.word -> Word8.word *)
    | Byte_sub              (* Word8.word * Word8.word -> Word8.word *)
    | Byte_toIntX           (* Word8.word -> int *)
    (* Char_chr doesn't raise Chr even if operand cannot be represented as char. *)
    | Char_chr_unsafe       (* int -> char *)
    | Char_equal            (* char * char -> bool *)
    | Char_gt               (* char * char -> bool *)
    | Char_gteq             (* char * char -> bool *)
    | Char_lt               (* char * char -> bool *)
    | Char_lteq             (* char * char -> bool *)
    | Char_ord              (* char -> int *)
    | Float_abs             (* Real32.real -> Real32.real *)
    | Float_add             (* Real32.real * Real32.real -> Real32.real *)
    | Float_div             (* Real32.real * Real32.real -> Real32.real *)
    (* Float_equal: Real32.== operation *)
    | Float_equal           (* Real32.real * Real32.real -> bool *)
    | Float_fromInt         (* int -> Real32.real *)
    | Float_fromReal        (* real -> Real32.real *)
    | Float_gt              (* Real32.real * Real32.real -> bool *)
    | Float_gteq            (* Real32.real * Real32.real -> bool *)
    | Float_lt              (* Real32.real * Real32.real -> bool *)
    | Float_lteq            (* Real32.real * Real32.real -> bool *)
    | Float_mul             (* Real32.real * Real32.real -> Real32.real *)
    | Float_neg             (* Real32.real -> Real32.real *)
    | Float_sub             (* Real32.real * Real32.real -> Real32.real *)
    | Float_toReal          (* Real32.real -> real *)
    (* Float_trunc_unsafe doesn't raise Domain even if operand is NaN. *)
    | Float_trunc_unsafe of ov_  (* Real32.real -> int / Overflow *)
    | IntInf_abs            (* IntInf.int -> IntInf.int *)
    | IntInf_add            (* IntInf.int * IntInf.int -> IntInf.int *)
    | IntInf_div            (* IntInf.int * IntInf.int -> IntInf.int / Div *)
    | IntInf_equal          (* IntInf.int * IntInf.int -> bool *)
    | IntInf_gt             (* IntInf.int * IntInf.int -> bool *)
    | IntInf_gteq           (* IntInf.int * IntInf.int -> bool *)
    | IntInf_lt             (* IntInf.int * IntInf.int -> bool *)
    | IntInf_lteq           (* IntInf.int * IntInf.int -> bool *)
    | IntInf_mod            (* IntInf.int * IntInf.int -> IntInf.int / Div *)
    | IntInf_mul            (* IntInf.int * IntInf.int -> IntInf.int *)
    | IntInf_neg            (* IntInf.int -> IntInf.int *)
    | IntInf_sub            (* IntInf.int * IntInf.int -> IntInf.int *)
    | Int_abs of ov_        (* int -> int / Overflow *)
    | Int_add of ov_        (* int * int -> int / Overflow *)
    | Int_div of ov_        (* int * int -> int / Div, Overflow *)
    | Int_equal             (* int * int -> bool *)
    | Int_gt                (* int * int -> bool *)
    | Int_gteq              (* int * int -> bool *)
    | Int_lt                (* int * int -> bool *)
    | Int_lteq              (* int * int -> bool *)
    | Int_mod of ov_        (* int * int -> int / Div, Overflow *)
    | Int_mul of ov_        (* int * int -> int / Overflow *)
    | Int_neg of ov_        (* int -> int / Overflow *)
    | Int_quot of ov_       (* int * int -> int / Div, Overflow *)
    | Int_rem of ov_        (* int * int -> int / Div, Overflow *)
    | Int_sub of ov_        (* int * int -> int / Overflow *)
    | Ptr_advance           (* ['a.('a)ptr * int -> ('a)ptr] *)
    (* Ptr_deref: ad-hoc primitives for C pointer dereference *)
    | Ptr_deref_int         (* (int)ptr -> int *)
    | Ptr_deref_real        (* (real)ptr -> real *)
    | Ptr_deref_float       (* (Real32.real)ptr -> Real32.real *)
    | Ptr_deref_word        (* (word)ptr -> word *)
    | Ptr_deref_char        (* (char)ptr -> char *)
    | Ptr_deref_byte        (* (Word8.word)ptr -> Word8.word *)
    | Ptr_deref_ptr         (* ['a.(('a)ptr)ptr -> ('a)ptr] *)
    | Ptr_store_int         (* (int)ptr * int -> unit *)
    | Ptr_store_real        (* (real)ptr * real -> unit *)
    | Ptr_store_float       (* (Real32.real)ptr * Real32.real -> unit *)
    | Ptr_store_word        (* (word)ptr * word -> unit *)
    | Ptr_store_char        (* (char)ptr * char -> unit *)
    | Ptr_store_byte        (* (Word8.word)ptr * Word8.word -> unit *)
    | Ptr_store_ptr         (* ['a.(('a)ptr)ptr * ('a)ptr -> unit] *)
    | Real_abs              (* real-> real *)
    | Real_add              (* real * real -> real *)
    | Real_div              (* real * real -> real *)
    (* Real_equal: Real.== operation *)
    | Real_equal            (* real * real -> bool *)
    | Real_fromInt          (* int -> real *)
    | Real_gt               (* real * real -> bool *)
    | Real_gteq             (* real * real -> bool *)
    | Real_lt               (* real * real -> bool *)
    | Real_lteq             (* real * real -> bool *)
    | Real_mul              (* real * real -> real *)
    | Real_neg              (* real -> real *)
    | Real_sub              (* real * real -> real *)
    (* Real_trunc_unsafe doesn't raise Domain even if operand is NaN. *)
    | Real_trunc_unsafe of ov_ (* real -> int / Overflow *)
    | String_array          (* int * char -> string / Size *)
    (* String_copy_unsafe doesn't check boundary. *)
    | String_copy_unsafe    (* string * int * string * int * int -> unit + effect *)
    | String_equal          (* string * string -> bool *)
    | String_gt             (* string * string -> bool *)
    | String_gteq           (* string * string -> bool *)
    | String_lt             (* string * string -> bool *)
    | String_lteq           (* string * string -> bool *)
    | String_size           (* string -> int *)
    (* String_sub_unsafe doesn't check boundary. *)
    | String_sub_unsafe     (* string * int -> char *)
    (* String_update_unsafe doesn't check boundary. *)
    | String_update_unsafe  (* string * int * char -> unit + effect *)
    | String_vector         (* int * char -> string / Size *)
    | Word_add              (* word * word -> word *)
    | Word_andb             (* word * word -> word *)
    | Word_arshift          (* word * word -> word *)
    | Word_div              (* word * word -> word / Div *)
    | Word_equal            (* word * word -> bool *)
    | Word_fromInt          (* int -> word *)
    | Word_gt               (* word * word -> bool *)
    | Word_gteq             (* word * word -> bool *)
    | Word_lshift           (* word * word -> word *)
    | Word_lt               (* word * word -> bool *)
    | Word_lteq             (* word * word -> bool *)
    | Word_mod              (* word * word -> word / Div *)
    | Word_mul              (* word * word -> word *)
    | Word_notb             (* word -> word *)
    | Word_orb              (* word * word -> word *)
    | Word_rshift           (* word * word -> word *)
    | Word_sub              (* word * word -> word *)
    | Word_toIntX           (* word -> int *)
    | Word_xorb             (* word * word -> word *)

  (* ToDo: special forms are to be merged to primitives or intermediate
   * languages.
   * prim_or_special is to be replaced with primitive. *)
  (*% *)
  datatype prim_or_special =
      (*% @format(x) x *) P of primitive
    | (*% @format(x) x *) S of specialForm

end
