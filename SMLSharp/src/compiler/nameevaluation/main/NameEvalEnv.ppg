(* the initial error code of this file : V-001 *)
(*
signature ORD_MAP =
  sig

    structure Key : ORD_KEY

    type 'a map

    val empty : 'a map (* The empty map *)

    val isEmpty : 'a map -> bool
	(* Return true if and only if the map is empty *)

    val singleton : (Key.ord_key * 'a) -> 'a map
	(* return the specified singleton map *)

    val insert  : 'a map * Key.ord_key * 'a -> 'a map
    val insert' : ((Key.ord_key * 'a) * 'a map) -> 'a map
	(* Insert an item. *)

    val insertWith  : ('a -> unit) -> 'a map * Key.ord_key * 'a -> 'a map

    val find : 'a map * Key.ord_key -> 'a option
	(* Look for an item, return NONE if the item doesn't exist *)

    val lookup : 'a map * Key.ord_key -> 'a
	(* look for an item, raise the NotFound exception if it doesn't exist *)

    val inDomain : ('a map * Key.ord_key) -> bool
	(* return true, if the key is in the domain of the map *)

    val remove : 'a map * Key.ord_key -> 'a map * 'a
	(* Remove an item, returning new map and value removed.
         * Raises LibBase.NotFound if not found.
	 *)

    val first : 'a map -> 'a option
    val firsti : 'a map -> (Key.ord_key * 'a) option
	(* return the first item in the map (or NONE if it is empty) *)

    val numItems : 'a map ->  int
	(* Return the number of items in the map *)

    val listItems  : 'a map -> 'a list
    val listItemsi : 'a map -> (Key.ord_key * 'a) list
	(* Return an ordered list of the items (and their keys) in the map. *)

    val listKeys : 'a map -> Key.ord_key list
	(* return an ordered list of the keys in the map. *)

    val collate : ('a * 'a -> order) -> ('a map * 'a map) -> order
	(* given an ordering on the map's range, return an ordering
	 * on the map.
	 *)

    val unionWith  : ('a * 'a -> 'a) -> ('a map * 'a map) -> 'a map
    val unionWithi : (Key.ord_key * 'a * 'a -> 'a) -> ('a map * 'a map) -> 'a map
	(* return a map whose domain is the union of the domains of the two input
	 * maps, using the supplied function to define the map on elements that
	 * are in both domains.
	 *)

    val intersectWith  : ('a * 'b -> 'c) -> ('a map * 'b map) -> 'c map
    val intersectWithi : (Key.ord_key * 'a * 'b -> 'c) -> ('a map * 'b map) -> 'c map
	(* return a map whose domain is the intersection of the domains of the
	 * two input maps, using the supplied function to define the range.
	 *)

    val mergeWith : ('a option * 'b option -> 'c option)
	  -> ('a map * 'b map) -> 'c map
    val mergeWithi : (Key.ord_key * 'a option * 'b option -> 'c option)
	  -> ('a map * 'b map) -> 'c map
	(* merge two maps using the given function to control the merge. For
	 * each key k in the union of the two maps domains, the function
	 * is applied to the image of the key under the map.  If the function
	 * returns SOME y, then (k, y) is added to the resulting map.
	 *)

    val app  : ('a -> unit) -> 'a map -> unit
    val appi : ((Key.ord_key * 'a) -> unit) -> 'a map -> unit
	(* Apply a function to the entries of the map in map order. *)

    val map  : ('a -> 'b) -> 'a map -> 'b map
    val mapi : (Key.ord_key * 'a -> 'b) -> 'a map -> 'b map
	(* Create a new map by applying a map function to the
         * name/value pairs in the map.
         *)

    val foldl  : ('a * 'b -> 'b) -> 'b -> 'a map -> 'b
    val foldli : (Key.ord_key * 'a * 'b -> 'b) -> 'b -> 'a map -> 'b
	(* Apply a folding function to the entries of the map
         * in increasing map order.
         *)

    val foldr  : ('a * 'b -> 'b) -> 'b -> 'a map -> 'b
    val foldri : (Key.ord_key * 'a * 'b -> 'b) -> 'b -> 'a map -> 'b
	(* Apply a folding function to the entries of the map
         * in decreasing map order.
         *)

    val filter  : ('a -> bool) -> 'a map -> 'a map
    val filteri : (Key.ord_key * 'a -> bool) -> 'a map -> 'a map
	(* Filter out those elements of the map that do not satisfy the
	 * predicate.  The filtering is done in increasing map order.
	 *)

    val mapPartial  : ('a -> 'b option) -> 'a map -> 'b map
    val mapPartiali : (Key.ord_key * 'a -> 'b option) -> 'a map -> 'b map
	(* map a partial function over the elements of a map in increasing
	 * map order.
	 *)

  end (* ORD_MAP *)

*)
structure NameEvalEnv =
struct
local
  structure I = IDCalc
  structure T = IDTypes
  structure E = NameEvalError
  structure EU = UserErrorUtils
  fun bug s = Control.Bug ("NameEvalEnv: " ^ s)


  (*% @formatter(T.tfun) T.format_tfun *)
  type tfun = (*% @format(x)  x *) T.tfun

  (*% @formatter(T.conSpec) T.format_conSpec *)
  type conSpec = (*% @format(x)  x *) T.conSpec

  (*% @formatter(T.formals) T.format_formals *)
  type formals = (*% @format(x)  x *) T.formals

  (*% @formatter(T.varE) T.format_varE *)
  type varE = (*% @format(x)  x *) T.varE

  (*% @formatter(T.typId) T.format_typId *)
  type typId = (*% @format(x)  x *) T.typId

  (*% @formatter(T.exnId) T.format_exnId *)
  type exnId = (*% @format(x)  x *) T.exnId

  (*% @formatter(T.tvar) T.format_tvar *)
  type tvar = (*% @format(x)  x *) T.tvar
  (*% @formatter(T.ty) T.format_ty *)
  type ty = (*% @format(x)  x *) T.ty

  (*% @formatter(I.varInfo) I.format_varInfo *)
  type varInfo = (*% @format(x)  x *) I.varInfo

  fun formatEnclosedSet listItems (format, lparen, comma, rparen) map =
      TermFormat.formatOptionalList
        (fn value => format value, lparen, comma, rparen)
        (listItems map)

  fun formatEnclosedTypidSet (lparen, comma, rparen)  map =
      formatEnclosedSet
        TypID.Set.listItems 
        (format_typId, lparen, comma, rparen)
        map
  fun formatEnclosedExnIdSet (lparen, comma, rparen)  map =
      formatEnclosedSet
        ExnID.Set.listItems 
        (format_exnId, lparen, comma, rparen)
        map

in
  (*%
     @formatter(bool) SmlppgUtil.formatBinaryChoice
   *)
   (* type structure *)
  datatype tstr 
    = (*%
        @format(tfun) 
          1["tystr" +1 tfun]
       *)
       TSTR of tfun
    | (*%
        @format({tfun, varE, formals, conSpec})
          "dtystr"
            +
          "{" 
             1[ 
               +1
                1["tfun:"+1 tfun]
               +1             
                1["varE:"+1 varE]
               +1
                1["formals:"+1 formals]
               +1
                1["conSpec:"+1 conSpec]
              ]
             1
           "}"
       *)
       TSTR_DTY of {tfun:tfun, varE:varE, formals:formals, conSpec:conSpec}
    | (*%
       * @format({id, iseq,tvar})
          "toTvar" + "=>" +d tvar
       *)
      (*
        "type foo" in a functor argument.
         foo is assigned to "id", and is converted
         to type variable "tvar" in its scope.
       *)
      TSTR_TOTVAR of {id:typId, iseq:bool, tvar:tvar}

  (*%
     @formatter(SEnv.map) TermFormat.formatEnclosedSEnvPlain
   *)
  (* type environment *)
  type tyE
    = (*%
        @format(tstr senv) 
          "{"
           1[
             senv(tstr)(1, ":"+)
            ]
           1
          "}"
       *)
      tstr SEnv.map

  (*%
     @formatter(SEnv.map) TermFormat.formatEnclosedSEnvPlain
   *)
  (* structure environment *)
  datatype strE
    = (*%
       * @format(env senv)
          "{"
           1[
             senv(env)(1, ":"+1)
            ]
           1
          "}"
       *)
      STR of env SEnv.map

  and env
    = (*%
         @format({varE, tyE, strE}) 
          "{"
           1[
             +1
              1["tyE:"+1 tyE]
             +1
              1["strE:"+1 strE]
             +1
              1["varE:"+1 varE]
            ]
           +1
           "}"
       *)
      ENV of {varE: varE, tyE: tyE, strE: strE}

  (*%
     @formatter(I.icexp) I.format_icexp
     @formatter(TypID.Set.set) formatEnclosedTypidSet
     @formatter(ExnID.Set.set) formatEnclosedExnIdSet
   *)
  type funEEntry
    = (*%
        @format({argSig,
                 argEnv,
                 argStrName,
                 dummyIdfunArgTy:dummyId opt,
                 polyArgTys:argTy argTys,
                 typidSet,
                 exnIdSet,
                 bodyEnv,
                 bodyVarExp})
           "{"
           1[+1
             {1["argSig:"+1 argSig]}
             +1
             {1["argEnv:"+1 argEnv]}
             +1 "argStrName:" argStrName
             +1
             {1["dummyIdfunArgTy:"+1 opt(dummyId)]}
             +1
             {1["polyArgTys:"+1 "[" argTys(argTy)(",") "]" ]}
             +1 
             {1["typidSet:"+1 typidSet()("(",",",") ") ]}
             +1 
             {1["exnIdSet:"+1 exnIdSet()("(",",",") ") ]}
             +1
             {1["bodyEnv:"+1 bodyEnv]}
             +1
             {1["bodyVarExp:"+1 bodyVarExp]}
           ]
           +1
           "}"
         *)
       {argSig: env,
        argEnv: env,
        argStrName: string,
        dummyIdfunArgTy: ty option,
        polyArgTys: ty list,
        typidSet: TypID.Set.set,
        exnIdSet: ExnID.Set.set,
        bodyEnv: env,
        bodyVarExp: I.icexp (* varInfo *)
       }
  (*% 
    @formatter(SEnv.map) TermFormat.formatEnclosedSEnvPlain
   *)
  type funE
    = (*%
         @format(funEEntry senv)
          "{"
           1[
             senv(funEEntry)(1, +":"+1)
            ]
           1
          "}"
       *)
      funEEntry SEnv.map
         
  (*% 
    @formatter(SEnv.map) TermFormat.formatEnclosedSEnvPlain
   *)
  type sigE
    = (*%
         @format(sigentry senv)  senv(sigentry)(+1"and"+, ":")
       *)
      env  SEnv.map

  (*%
   *)
  type topEnv
    = (*%
        @format({Env, FunE, SigE})
         Env
         +1
         FunE
         +1
         SigE
       *)
    {Env:env, FunE:funE, SigE: sigE}

  fun tstrFormals tstr =
      case tstr of 
       TSTR tfun => T.tfunFormals tfun
     | TSTR_TOTVAR {id, iseq, tvar} => nil
     | TSTR_DTY {tfun,...} => T.tfunFormals tfun

  fun tstrLiftedTys tstr =
      case tstr of 
       TSTR tfun => T.tfunLiftedTys tfun
     | TSTR_TOTVAR {id, iseq, tvar} => TvarSet.singleton tvar
     | TSTR_DTY {tfun,...} => T.tfunLiftedTys tfun

  fun tstrArity tstr = List.length (tstrFormals tstr)

  fun tstrToString tstr =
      Control.prettyPrint (format_tstr tstr)
  fun tyEToString tyE =
      Control.prettyPrint (format_tyE tyE)
  fun envToString env = 
      Control.prettyPrint (format_env env)
  fun topEnvToString (env:topEnv) = 
      Control.prettyPrint (format_topEnv env)
  fun funEToString funE = 
      Control.prettyPrint (format_funE funE)

  val emptyTyE = SEnv.empty : tyE
  val emptyEnv = ENV{varE=SEnv.empty,tyE = emptyTyE,strE=STR SEnv.empty}
  val emptyTopEnv = {Env=emptyEnv,FunE=SEnv.empty,SigE=SEnv.empty} : topEnv

  fun findTstr (ENV {varE, tyE, strE = STR envSEnvMap}, path) =
      case path of 
      nil => raise bug "*** nil to lookupTy *** "
    | name :: nil => SEnv.find(tyE, name) 
    | strname :: path =>
      (case SEnv.find(envSEnvMap, strname) of
         NONE => NONE
       | SOME env => findTstr (env, path)
      )

  exception LookupTstr
  fun lookupTstr env path : tstr =
      case findTstr (env, path) handle e => raise e
       of 
        NONE => raise LookupTstr
      | SOME tstr => tstr

  fun findId (ENV {varE, tyE, strE = STR envSEnvMap}, longid) =
      case longid of 
        nil => raise bug "nil to lookupId"
      | name :: nil => SEnv.find(varE, name)
      | strname :: path =>
        (case SEnv.find(envSEnvMap, strname) of
           NONE => NONE
         | SOME env => findId (env, path)
        )
  exception LookupId
  fun lookupId env longid : T.idstatus =
      case findId(env, longid) of
        NONE => raise LookupId
      | SOME idstatus => idstatus

  fun findStr (ENV {varE, tyE, strE = STR envSEnvMap}, stringList) = 
      case stringList of 
        nil => raise bug "nil to lookupStrId"
      | name :: nil =>  SEnv.find(envSEnvMap, name) 
      | strname :: path =>
        (case SEnv.find(envSEnvMap, strname) of
           NONE => NONE
         | SOME env => findStr (env, path)
        )
  exception LookupStr
  fun lookupStr env stringList : env = 
      case findStr (env, stringList) of
        NONE => raise LookupStr
      | SOME env => env

  fun rebindIdLongid
        (ENV{varE, tyE, strE = strE as STR envMap},
         longid,
         idstatus) : env =
      case longid of
        nil => raise bug "nil to rebindTypLongid"
      | name::nil =>
        ENV
          {
           varE = SEnv.insert(varE, name, idstatus),
           tyE = tyE,
           strE = strE
          }
      | strname::path =>
        let
          val env = case SEnv.find(envMap, strname) of
                      SOME env =>env
                    | NONE => emptyEnv
          val newEnv = rebindIdLongid(env, path, idstatus)
        in
          ENV
            {
             varE = varE,
             tyE = tyE,
             strE = STR (SEnv.insert(envMap, strname, newEnv))
          }
        end

  fun bindStr loc (env, name, strEnv) =
      let
        val ENV{varE, tyE, strE = STR envMap} = env
        val envMap =
            case SEnv.find(envMap, name) of
              NONE => SEnv.insert(envMap, name, strEnv)
            | SOME _ => 
              (EU.enqueueError (loc, E.DuplicateIdInSpec("050", name));
               envMap
              )
      in
        ENV {varE=varE, tyE=tyE, strE=STR envMap}
      end

  fun rebindTstr (ENV{varE,tyE,strE}, name, tstr) =
      ENV
        {
         varE = varE,
         tyE = SEnv.insert(tyE, name, tstr),
         strE = strE
        }

  fun rebindTstrLongid
        (ENV{varE, tyE, strE = strE as STR envMap},
         longid,
         tstr) : env =
      case longid of
        nil => raise bug "nil to rebindTypLongid"
      | name::nil =>
        ENV
          {
           varE = varE,
           tyE = SEnv.insert(tyE, name, tstr),
           strE = strE
          }
      | strname::path =>
        let
          val env = case SEnv.find(envMap, strname) of
                      SOME env =>env
                    | NONE => emptyEnv
          val newEnv = rebindTstrLongid(env, path, tstr)
        in
          ENV
            {
             varE = varE,
             tyE = tyE,
             strE = STR (SEnv.insert(envMap, strname, newEnv))
          }
        end
  fun rebindId (ENV{varE, tyE, strE}, name, idstatus) =
      ENV
        {varE = SEnv.insert(varE, name, idstatus),
         tyE = tyE,
         strE = strE
        }

  fun rebindStr (ENV{varE,tyE,strE=STR envMap}, name, strEntry) =
      ENV {varE = varE,
           tyE = tyE,
           strE = STR (SEnv.insert(envMap, name, strEntry))
          }

  fun singletonStr (name, strEntry) = rebindStr(emptyEnv, name, strEntry)

  fun varEWithVarE (varE1, varE2) = SEnv.unionWith #2 (varE1, varE2)

  fun tyEWithTyE (tyE1, tyE2) = SEnv.unionWith #2 (tyE1, tyE2)

  fun strEWithStrE (STR envMap1, STR envMap2) = 
      STR (SEnv.unionWith #2 (envMap1, envMap2))

  fun envWithVarE (ENV {varE, strE, tyE}, varE1 : T.varE) =
      ENV {varE = varEWithVarE (varE, varE1),
           strE = strE,
           tyE = tyE}

  (* this recursively merge two envs *)
  fun envWithEnv (ENV {varE=varE1, strE=strE1, tyE=tyE1},
                  ENV {varE=varE2, strE=strE2, tyE=tyE2}) =
      ENV {varE = varEWithVarE (varE1, varE2),
           strE = strEWithStrE (strE1, strE2),
           tyE = tyEWithTyE (tyE1,tyE2)
          }

  fun unionVarE code loc (varE1, varE2) =
      SEnv.unionWithi
        (fn (name,_,v)=>
            (EU.enqueueError (loc, E.DuplicateVar(code ^ "v", name));v))
        (varE1, varE2)

  fun unionTyE code loc (tyE1, tyE2) =
      SEnv.unionWithi 
        (fn (name, _, v) =>
            (EU.enqueueError (loc, E.DuplicateTypName(code ^ "v", name)); v)
        )
        (tyE1, tyE2)
            
  fun unionStrE code loc (STR map1, STR map2) =
      STR
        (
         SEnv.unionWithi
           (fn (name, _, v) => 
               (EU.enqueueError (loc, E.DuplicateStrName(code ^ "v", name)); v)
           )
           (map1, map2)
        )
            
  fun unionEnv code loc (ENV {varE=varE1, strE=strE1, tyE=tyE1},
                         ENV {varE=varE2, strE=strE2, tyE=tyE2})
      =
      let
        val varE = unionVarE code loc (varE1, varE2)
        val tyE = unionTyE code loc (tyE1, tyE2)
        val strE = unionStrE code loc (strE1, strE2)
      in
        ENV{varE=varE, strE=strE, tyE=tyE}
      end

  fun bindId loc (env, name, idstate) =
      let
        val ENV{varE, tyE, strE} = env
        val varE =
            SEnv.insertWith
              (fn _ =>(EU.enqueueError (loc,E.DuplicateIdInSpec("054",name))))
              (varE, name, idstate)
      in
        ENV {varE=varE, tyE=tyE, strE=strE}
      end

  fun bindTstr loc (env, name, tstr) =
      let
        val ENV{varE, tyE, strE} = env
        val tyE =
            SEnv.insertWith
            (fn _ =>(EU.enqueueError (loc, E.DuplicateTypInSpec("055", name))))
            (tyE, name, tstr)
      in
        ENV {tyE=tyE, varE=varE, strE=strE}
      end

  fun sigEWithSigE (sigE1, sigE2) =
      SEnv.foldli
      (fn (name, entry, sigE1) => SEnv.insert(sigE1, name, entry))
      sigE1
      sigE2

  fun funEWithFunE (funE1, funE2) =
      SEnv.foldli
      (fn (name, entry, funE1) => SEnv.insert(funE1, name, entry))
      funE1
      funE2

  fun unionSigE code loc (sigE1, sigE2) =
      SEnv.unionWithi
        (fn (name,_,v) =>
            (EU.enqueueError
               (loc, E.DuplicateSigname(code ^ "s", name));
             v)
        )
        (sigE1, sigE2)

  fun unionFunE code loc (funE1, funE2) =
      SEnv.unionWithi
        (fn (name,_,v) =>
            (EU.enqueueError
               (loc, E.DuplicateFunctor(code ^ "f", name));
             v)
        )
      (funE1, funE2)

  fun topEnvWithSigE ({Env, FunE, SigE}, sige) : topEnv =
      {Env = Env,
       FunE = FunE,
       SigE = sigEWithSigE (SigE, sige)
      }

  fun topEnvWithFunE ({Env, FunE, SigE}, funE) : topEnv =
      {Env = Env,
       FunE = funEWithFunE (FunE, funE),
       SigE = SigE
      }

  fun topEnvWithEnv ({Env, FunE, SigE}, env1) : topEnv =
      {Env = envWithEnv (Env, env1), FunE = FunE, SigE = SigE}

  fun topEnvWithTopEnv
        ({Env=env1,FunE=funE1,SigE=sige1},{Env=env2,FunE=funE2,SigE=sige2})
      : topEnv
      =
      {Env = envWithEnv (env1, env2),
       FunE = funEWithFunE (funE1, funE2),
       SigE = sigEWithSigE (sige1, sige2)
      }

  fun unionTopEnv code loc
        ({Env=env1,FunE=funE1,SigE=sige1},{Env=env2,FunE=funE2,SigE=sige2})
      : topEnv
      =
      {Env = unionEnv code loc (env1, env2),
       FunE = unionFunE code loc (funE1, funE2),
       SigE = unionSigE code loc (sige1, sige2)
      }
end
end
