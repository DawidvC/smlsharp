(**
 * @copyright (c) 2006, Tohoku University.
 * @author YAMATODANI Kiyoshi
 * @version $Id: ElaborateError.ppg,v 1.23.6.1 2009/12/23 22:24:58 hiro-en Exp $
 *)
structure ElaborateError =
struct


  (***************************************************************************)
  
  (*%
   * @formatter(Absyn.ty) Absyn.format_ty
   *)
  exception

  (**
   * <pre>
   *  type t = (int, int) option
   * </pre>
   *)
  (*%
   * @format({tyCon, wants, given})
   *   "type" +d "constructor" +d tyCon +d "given" +d given +d "arguments,"
   *  +d "wants" +d wants
   *)
  ArityMismatchInTypeDeclaration of {tyCon : string, wants : int, given : int}

  and
  (*%
   * @format(id) "expression" +d "or" +d "pattern" +d "begins" +d
   *            "with" +d "infix" +d "identifier" +d ":" +d id
   *)
  BeginWithInfixID of string

  and
  (**
   * <pre>
   *   exception true of int
   *   datatype dt = ref of int
   * </pre>
   *)
  (*%
   * @format(name) "Binding" +d "reserved" +d "name:" + name
   *)
  BindReservedName of string

  and
  (**
   * <pre>
   *   datatype t1 = D and t2 = D
   * </pre>
   *)
  (*%
   * @format(name) "Duplicate" +d  "constructor" +d "name" +d "in" +d
   *      "datatype:" + name
   *)
  DuplicateConstructorNameInDatatype of string

  and
  (**
   * <pre>
   *   exception e1 of int and e1 = Fail
   * </pre>
   *)
  (*%
   * @format(name) "Duplicate" +d  "constructor" +d "name" +d "in" +d
   *      "exception:" + name
   *)
  DuplicateConstructorNameInException of string
					 
  and
  (**
   * <pre>
   *    type t and t
   * </pre>
   *)
  (*%
   * @format(name) "Duplicate" +d  "type" +d "constructor:" + name
   *)
  DuplicateTypDesc of string

  and
  (**
   * <pre>
   *    type t and t
   * </pre>
   *)
  (*%
   * @format(name) "Duplicate" +d  "structure" +d "identifier:" + name
   *)
  DuplicateStrDesc of string

  and
  (**
   * <pre>
   *    type t and t
   * </pre>
   *)
  (*%
   * @format(name) "Duplicate" +d  "functor" +d "identifier:" + name
   *)
  DuplicateFunctorDesc of string

  and
  (**
   * <pre>
   *  val {a, a} = {a = 1, a = 2}
   * </pre>
   *)
  (*%
   * @format(label)
   *    "duplicate" +d "label" +d "in" +d "record:" label
   *)
  DuplicateRecordLabel of string

  and
  (**
   * <pre>
   *  val {a, a} = {a = 1, a = 2}
   * </pre>
   *)
  (*%
   * @format(label)
   *  "duplicate" +d "label" +d "in" +d "record pattern:" label
   *)
  DuplicateRecordLabelInPat of string

  and
  (**
   * <pre>
   *  val {a, a} = {a = 1, a = 2}
   * </pre>
   *)
  (*%
   * @format(label) "duplicate" +d "label" +d "in" +d "a record type:" label
   *)
  DuplicateRecordLabelInRawType of string

  and
  (**
   * <pre>
   *   type t1 = int and t1 = string
   * </pre>
   *)
  (*%
   * @format(name) "Duplicate" +d  "type" +d "name" +d "in" +d "type:" + name
   *)
  DuplicateTypeNameInType of string

  and
  (**
   * <pre>
   *   datatype t1 = D and t1 = E
   * </pre>
   *)
  (*%
   * @format(name) "Duplicate" +d  "type" +d "name" +d "in" +d
   *             "datatype:" + name
   *)
  DuplicateTypeNameInDatatype of string

  and 
  (**
   * <pre>
   *    val x : int and x : bool
   * </pre>
   *)
  (*%
   * @format(name) "Duplicate" +d  "value" +d "identifier:" + name
   *)
  DuplicateValDesc of string

  and
  (**
   * <pre>
   *  val rec f = exp and f = exp
   * </pre>
   *)
  (*%
   * @format(var)
   *   "duplicate" +d "name" +d "in" +d "val rec:" +d var
   *)
  DuplicateVarNameInValRec of string

  and
  (*%
   * @format(id) "expression" +d "or" +d "pattern" +d "ends" +d
   *            "with" +d "infix" +d "identifier" +d ":" +d id
   *)
  EndWithInfixID of string

  and
  (*%
   * @format "can't" +d "find" +d "function" +d "arguments" +d "in" +d "clause"
   *)
  FunctionParameterNotFound

  and
  (*%
   * @format "illegal" +d "function" +d "symbol" +d "in" +d "clause"
   *)
  IllegalFunctionSymbol

  and
  (*%
   * @format(id) "infix" +d "operator" +d id +d "used" +d "without" +d
   *            "\"op\"" +d "in" +d "fun" +d "dec"
   *)
  InfixUsedWithoutOP of string

  and
  (*%
   * @format "infix" +d "operator" +d "required," +d "or" +d "delete" +d
   *        "parentheses"
   *)
  InfixRequired

  and
  (*%
   * @format "pattern" +d "to" +d "left" +d "of" +d "AS" +d "must" +d "be"
   *        +d "variable"
   *)
  LeftOfASMustBeVariable

  and
  (*%
   * @format(id) "infix" +d "symbol" +d id +d "used" +d "where" +d "a" +d
   *            "nonfix" +d "identifier" +d "was" +d "expected"
   *)
  NonfixExpected of string

  and
  (* Only variable pattern optionally typed is accepted in elaboration.
   *)
  (*%
   * @format
   * "only" +d "variable" +d "or" +d "typed" +d "variable" +d "pattern" +d
   * "is" +d "allowed" +d "in" +d "val" +d "rec"
   *)
  NonVariablePatternInValRec

  and
  (*%
   * @format "clauses" +d "don't" +d "all" +d "have" +d "function" +d "name"
   *)
  NotAllHaveFunctionName

  and
  (*%
   * @format "clauses" +d "don't" +d "all" +d "have" +d "same" +d "number"
   *        +d "of" +d "patterns"
   *)
  NotAllHaveSameNumberPatterns

  and
  (**
   * <pre>
   * datatype t = D of 'a
   * val x = y : 'a   (top level)
   * </pre>
   *)
  (*%
   * @format({tyvar}) "free" +d "type" +d "variable:" +d {tyvar}
   *)
  NotBoundTyvar of {tyvar : string}

  and
  (*%
   * @format
   * "bound" +d "expression" +d "in" +d "val" +d "rec" +d "must" +d "be" +d
   * "fn"
   *)
  NotFnBoundInValRec

  and
  (*
   *)
  (*%
   * @format
   * "no" +d "real" +d "constant" +d "may" +d "occur" +d "in" +d "a" +d
   * "pattern."
   *)
  RealConstantInPattern

  and
  (*
   *)
  (*%
   * @format({ty})
   * "not" +d "a" +d "foreign" +d "function" +d "type:" +d ty
   *)
  NotForeignFunctionType of {ty: Absyn.ty}

  and
  (*
   *)
  (*%
   * @format({attr})
   * "undefined" +d "foreign" +d "attribute:" +d attr
   *)
  UndefinedFFIAttribute of {attr:string}

end
