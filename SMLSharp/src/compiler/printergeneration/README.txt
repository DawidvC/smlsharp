Formatter code generation

 Interactive SML system responds to user input by printing its evaluated value.

  - 1 + 1;
  val it = 2 : int;

 The IML system should implement this feature.
 The strategy described in this document is that the compiler generates an additional code which will be executed after the user code when user inputs a code:

   1, For a type or datatype declaratioin, the compiler add a binding of a function which translates a value of a type which is constructed from the declared type constructor into its string representation (or other intermediate data structure which is transtalted into string finally.
   2, For a global variable declaration, the compiler generates a code that prints the value of bound expression. It may invoke formatters which the compiler generated for type constructors occurring in the type expression of the variable.

Example. Assume user inputs an global binding declaration of the int type:

  - val x = 1 + 1;

The compiler appends additional codes as follows.
(These are internal representations in the compiler, not proper SML code.)

  setGlobal x = 1 + 1;
  print ("val x = ");
  printFormat format_int it;
  print (" : int;");

When user inputs a datatype declaration,

  - datatype 'a tree = Leaf of 'a | Node of ('a tree * 'a tree)

the compiler generates a formatter function which translate a tree value into a text (or an intermediate representation annotated with formatting information).

  setGlobal fun format_tree print_'a x = 
                case x of 
                  Leaf x => (["Leaf "] @ format_'a x)
                | Node x => 
                    (["Node"] @
                     (format_tuple
                      (print_tree print_'a)
                      (print_tree print_'a)
                      x))

This formatter takes as its parameter another formatter, which is used to format values of type which is bound to the type variable 'a.

 And this formatter function is used in codes generated by the compiler for global declarations of the tree type (and types which contain the tree type as their sub type expression).

  - val t = Leaf 1

  setGlobal t = Leaf 1
  print "val t = ";
  printFormat format_tree format_int t;
  print " : int tree";

========================================
Make formatters available to user

 It might be useful to make the compiler generated formatters available to user. 

 However, it is not user-friendly to let user specify formatter to be used.
 One option is to provide a general formatter function to user, and treat it internally as a restricted overloaded function, like other overloaded functions, such as '+'.
The compiler translates its invocation into an expression specialized to the type of its argument.

 The general formatter is:

  format : 'a -> string

Example. User can use it as follows:

  - format 1

The compiler translates this expression into the following:

  setGlobal it = Compiler.formatValue format_int 1

This 'Compiler.formatValue' is assumed to be an predefined utility function which applies the formatter to the value with appropriate parameters, such as column width.

  Compiler.formatValue : 'a formatter -> 'a -> string

========================================
visibility of type constructors

 Assume user inputs the following code:

    local datatype t = D in val x = D end

The type constructor 't' is not visible outside the local declaration. It is hidden.
Hidden type constructors are:

  * type constructor declared in let expression
  * type constructor declared in local expression
  * type constructor declared in abstype declaration
  * type constructor declared in a structure opaque constrainted by a signature
  * type constructor hidden by another constructor defined with the same name

What should formatter print as textual representation of the value of 'x' ?

 The SML/NJ compiler prints the internal structure of the value of 'x'.

  - local datatype t = D in val x = D end;
  val x = D : ?.t

But, does this behavior conform to user's intention ?
The compiler should hide entities which user intends to hide. 
In fact, the SML/NJ does not expose the internal structure of values of other types hidden by 'abstype' and signature constraint.

  - abstype t = D with val x = D end;
  type t
  val x = - : t

  - signature S = sig type t val x : t end;
  signature S =
    sig
      type t
      val x : t
    end
  - structure S :> S = struct datatype t = D val x = D end;
  structure S : S
  - S.x;
  val it = - : S.t

 The IML compiler treats all these hidden types uniformly in formatter generation (constructors hidden by opaque constraint are treated in slightly different way). That is, values of hidden types are not printed.
For example,

  datatype t = D1
  datatype t = D2
  val x = D1

The IML compiler prints in response to the last declaration as follows.

  val x = - : -

 For hidden type constructors, the predefined formatter 'format_hidden' is selected.

  fun format_hidden x = "-"

Formatter functions are generated at each datatype declaration.

  datatype t = D1
  fun format_t x = case x of D1 => "D1"
  datatype t = D2
  fun format_t x = case x of D2 => "D2"

At generating print code for a global binding, if a hidden type constructor is used, 'format_hidden' is used, instead of the formatter generated for the type constructor.

  val x = D1 : t
  print "val x = "
  printFormat format_hidden x
  print ": -"

(IMPLEMENTATION NOTE: if a type constructor 't' is not included in tcenv, it is hidden.)

 Types declared in structure are treated in slightly different way.
First, the generator inserts a specification of formatters into signature which user inputs.
The generator modifies a signature input by user

  signature S = sig type t val x : t end;

into the following.

  signature S =
    sig
      type t
      val format_t : t -> string
      val x : t
    end

And, the generator inserts formatter function into structures.
From:

  structure S = struct datatype t = D val x = D end;

to:

  structure S = 
  struct datatype t = D fun format_t x = case x of D => "D" val x = D end;

 To format values of a type which is a member of a structure, 'format_opaque' is used if the structure is constrainted by a signature opaquely and the definition of the type is hidden by the signature. Otherwise, the generated formatter is used.
For example, 

  structure S1 : S = S
  val x = S1.x

  structure S2 :> S = S
  val x = S2.x

is translated into:

  structure S1 : S = S
  val x = S1.x
  print "val x = "
  printFormat S1.format_t x
  print " : S1.t"

  structure S2 :> S = S
  val x = S2.x
  print "val x = "
  printFormat format_opaque x
  print " : S2.t"

========================================
Formatter for polymorphic type

 In SML, global variables of polymorphic type can be declared.
For example, assume the following datatype is declared,

  - datatype 'a list = Nil | Cons of 'a * 'a list

User can declare a global variable of polymorphic type as follows:

  - val null = Nil

This "null" has a type "'X list" for a type variable 'X.

 What to do to format this "polymorphic" value ?
First, a formatter for the "list" is generated as described above:

  setGlobal fun format_list format_'a x =
                case x of Nil => "Nil" | Cons y => ...

Then, for the binding of "null", the compiler generates the following code:

  setGlobal null = Nil
  printFormat (format_list format_unknown null)

The "format_unknown" function is a predefined formatter, and it raises an exception always when called.
Normally, this format_unknown is never called in the "format_list".

 But, there is an rare case as an exception.

  fun loop x = loop x
  val y = loop 1

The following code is generated to print the value of 'y'.

  print "val y = "
  printFormat format_unknown y
  print " : 'b"

The 'loop' has the type 'a -> 'b, and 'loop 1' has a type 'b. 
The format_unknown will be called when the value of 'y' is printed. In this case, 'format_unknown' should not raise exception because the source code does not contain any error, but what to be printed ?
The answer is that the formatter is not invoked because evaluation of 'loop 1' will not stop.

===============================================================================
formatter generation for exceptions

 When an raised exception is not caught by any handler, the SML/NJ prints the constructor name of it, but does not print the whole inner structure. This is inconvenient in order to determine the reason of the error.

  - exception Error of string;
  exception Error of string
  - val x = raise Error "foo";
  uncaught exception Error
  raised at: stdIn:20.15-20.26

The argument "foo" of Error is not printed.
And the implementation of 'exnMessage' in SML/NJ does not print helpful message.

 It would be useful to apply the formatter generation to this exception printing.
But there are two issues.

====================
Incremental extension of formatter function

 Because 'exn' is extensible, it is impossible to define a single formatter function which can process every exception.
So, the formatter should be extended at each time when new exception constructors are declared.

 First, define the initial formatter. This aborts anytime if called. It will not be invoked unless compiler has a bug.
In order to handle exception constructor declared in structure, declare a reference to a formatter as a global variable.

  val format_exnRef = ref (fn x : exn => "compiler bug!")

and updates it at each exception declaration to handle the new exception constructor.

  (* user code *)
  exception Error of string;

  (* generated code *)
  local
    val prev_formatter = !format_exnRef
    fun format_exn x =
        case x of
          Error message => "Error " ^ message
        | other => prev_formatter other
    val _ = format_exnRef := format_exn
  in
  end

 The strategy can handle exceptions declared in structures, such as:

  structure S =
  struct
    exception Error of string
  end

And this makes it to be able to handle hidden exception constructors, such as:

  local exception Error of string
  in val x = raise Error "error" end

NOTE: The format_exn must be defined recursively to handle exceptions such as the following,

  exception of CapsuledException of exn

and also must be able to call previously defined format_exn.

====================
Handler for declaration

 The compiler regards the program as a sequence of declarations.
Assume a global declaration:

 val x = raise Error "error"

 When the runtime executes this declaration, the valid behavior is not only that the evaluation of bound expression aborts, but also that any global binding 'x' should not be created.

 The exception printing should not distort this behavior.
So, the above declaration is translated into:

  val x = (raise Error "error")
          handle
            e =>
              (
                print "uncaught exception ";
                printFormat format_exn e;
                raise e
              )

The raised exception is caught by the generated catch all handler and re-raised, which aborts global binding of 'x'.

 If it is explicit that the exception will not raise any user exception, some optimization is possible so that catch all handler is not generated.
We call those exceptions "safe" exception.
 Safe exceptions include
  * constant
  * variable reference
  * function abstraction
and other expressions whose sub-expression are all safe.

===============================================================================
Implementation

 The frontend passes source program from phase to phase in the following order:

       user program
  1,parse
       Absyn (parser/absyn.ppg)
  2,elaborate
       PatternExpr (patterncalc/patterncalc.ppg)
  3,type inference
       TypedPL (typedcalc/typedcalc.ppg)
  4,pattern match compile
         :

 The FormatterGenerator generates formatter code in TypedPL form and passes it to the pattern match compiler.
It would be easier to generate the Absyn code, not the TypedPL code, and pass it to the elaborator. 


========================================
Specification

signature FORMATTER_GENERATOR =
sig

  (**
   * table of type constructor maintained by type inferencer.
   * The type inferencer extends a table with declared type constructors.
   * By using tcenv, the generator determines whether a type is visible or not.
   *)
  type tcenv = Types.tycon SEnv.map

  (**
   * generates formatter function binding.
   *  This function traverses whole declarations and their bound
   * expressions one time, generates formatter function declrations
   * for each type/datatype declaration, and insert those formatter
   * declarations just after the type/datatype declaration.
   *  It returns modified declarations.
   *)
  val generate
      : tcenv * TypedPL.tpdecl list -> TypedPL.tpdecl list

end

========================================
Implementation

The generator generates the two types of SML codes:

  * definition of a formatter function for a type constructor
  * expressions to print values bound to global variables

 For a type constructor defined by datatype declaration, it is necessary to define a formatter function which can traverse recursive data structure of the type,because the type constructor can be declared recursively like list.


====================
generating formatter function declaration

 E is a formatter environment which maps a type constructor ID to a formatter ID. And B is another formatter table which maps index of bound type variable to an argument variable.

The algorithm 'F' generates formatter function code.

F E B (TYVARty(ref SUBSTITUTED ty)) = F E B ty
F E B (TYVARty(ref TVAR tvkind)) = [fn x => raise Fail]
F E B (BOUNDVARty(index)) =
    [fn x => raise Fail] in printer code
    let val f = B(index) in [f] end in formatter definition
F E B (FUNty(ty1, ty2)) = [fn x => "fn"]
F E B (IABSty(_, ty)) = error
F E B (RECORDty {l1:ty1, ..., ln:tyn}) =
    let val f1 = F E t1 ... val fn = F E B tn
    in
      if isTupleTy {l1, ..., ln}
      then [fn x => "(" ^ (f1 (#1 x)) ^ "," ^ ... ^ "," ^ (fn (#n x)) ^ ")"]
      else
        [fn x =>
         "{" ^
            l1 ^ " = " ^ (f1 (#l1 x)) ^ "," ^ 
            ... ^ "," ^
            ln ^ " = " ^ (fn (#ln x)) ^
         "}"]
    end
F E B (CONty{tycon, {ty1, ..., tyn}}) =
      let
        val f = E tycon
        val {f1, ..., fn} = {F E B ty1, ..., F E B tyn} 
      in [f f1 ... fn] end
F E B (POLYty{{btv1, ..., btvn}, body}) = F E B body
F E B (DUMMYty) = error
F E B (BOXEDty) = error
F E B (ATOMty) = error
F E B (INDEXty _) = error
F E B (BMABSty (_, ty)) = error
F E B (BITMAPty _) = error

Beacuse IABSty and from BOXEDty to BITMAPty is generated by the record compile which follows the typeinference, 'F' does not expect IASBty.
The body of POLYty must be FUNty.

Algorithm 'D' generates formatter definition for datatype delcaration.

D E [datatype ('a1,...'an) t = CON1 ... CONm] =
    let
      val {f1, ..., fn} = fresh ID
      val B = {'a1 => f1, ..., 'an => fn}
      val b1 = 

The D uses another algorithm 'V' to generate case branches for data constructors.

V E B [CON] = [CON => "CON"]
V E B [CON ty] =
      let
        val f = F E B ty
        val v = fresh ID
      in [CON v => "CON" ^ f v]
      end


Algorithm 'P' generates printing code for global binding.

P E [x] ty = let val f = F E empty ty in [print f x] end

NOTE: pattern has been compiled
For example, a declaration
  val (x, y) = (1, 2)
has been translated into
  local val z = (1, 2) in val x = #1 z val y = #2 z end

