(**
 This module generates printer code.

<h3>Printer code generation</h3>
<p>
 Interactive SML system responds to user input by printing its evaluated value.
<pre>
  - 1 + 1;
  val it = 2 : int;
</pre>
 The IML system should implement this feature.
 The strategy described in this document is that the compiler generates an
additional code which will be executed after the user code when user inputs a
code:
<ol>
   <li> For a type or datatype declaratioin, the compiler add a binding of a 
     function which translates a value of a type which is constructed from the
     declared type constructor into its string representation.</li>
   <li> For a global variable declaration, the compiler generates a code that
     may invoke printers which the compiler generated for type constructors 
     occurred in the type of the variable.</li>
</ol>
</p>
<h4>Example</h4>
<p>
Assume user inputs an expression of the int type:
<pre>
  - 1 + 1;
</pre>
The compiler appends additional codes as follows.
(These are internal representations in the compiler, not proper SML code.)
<pre>
  setGlobal it = 1 + 1;
  print ("val it = ");
  printFormat format_int it;
  print (" : int;");
</pre>
When user inputs a datatype declaration,
<pre>
  - datatype 'a tree = Leaf of 'a | Node of ('a tree * 'a tree)
</pre>
the compiler generates a formatter function which translates a tree value into
 a text (or an intermediate representation for formatting).
<pre>
  setGlobal fun format_tree print_'a x = 
                case x of 
                  Leaf x => (["Leaf "] @ format_'a x)
                | Node x => 
                    (["Node"] @
                     (format_tuple
                      (print_tree print_'a)
                      (print_tree print_'a)
                      x))
</pre>
This formatter takes as its parameter another formatter, which is used to 
format values of types which is bound to the type variable 'a.
</p>
<p>
 And this formatter function is used in codes generated by the compiler for 
global declarations of the tree type (and the types which contain the tree
 type as its sub type expression).
<pre>
  - val t = Leaf 1

  setGlobal t = Leaf 1
  print "val t = ";
  printFormat format_tree format_int t;
  print " : int tree";
</pre>
</p>

<h4>
visibility of type constructors
</h4>
<p>
 Assume user inputs the following code:
<pre>
    local datatype t = D in val x = D end
</pre>
The type constructor 't' is not visible outside the local declaration. It is
 hidden.
Hidden type constructors are:
<ul>
  <li>type constructor declared in let expression</li>
  <li>type constructor declared in local expression</li>
  <li>type constructor declared in abstype declaration</li>
  <li>type constructor declared in a structure opaque constrainted by a
    signature</li>
  <li>type constructor hidden by another constructor defined with the same 
    name</li>
</ul>
What should formatter print as textual representation of the value of 'x' ?
</p>
<p>
 The SML/NJ compiler prints the internal structure of the value of 'x'.
<pre>
  - local datatype t = D in val x = D end;
  val x = D : ?.t
</pre>
But, does this behavior conform to user's intention ?
The compiler should hide entities which user intends to hide. 
In fact, the SML/NJ does not expose the internal structure of values of other
types hidden by 'abstype' and signature constraint.
<pre>
  - abstype t = D with val x = D end;
  type t
  val x = - : t

  - signature S = sig type t val x : t end;
  signature S =
    sig
      type t
      val x : t
    end
  - structure S :> S = struct datatype t = D val x = D end;
  structure S : S
  - S.x;
  val it = - : S.t
</pre>
 The IML compiler treats all these hidden types uniformly in formatting 
(constructors hidden by opaque constraint are treated in slightly different 
way.)
Values of hidden types are not printed.
For example,
<pre>
  datatype t = D1
  datatype t = D2
  val x = D1
</pre>
The IML compiler prints in response to the last declaration as follows.
<pre>
  val x = - : -
</pre>
For hidden type constructors, the predefined formatter 'format_hidden' is 
selected.
<pre>
  fun format_hidden x = "-"
</pre>
Formatter functions are generated at each datatype declaration.
<pre>
  datatype t = D1
  fun format_t x = case x of D1 => "D1"
  datatype t = D2
  fun format_t x = case x of D2 => "D2"
</pre>
At generating formatting expression for a global binding, if a hidden type 
constructor is used, 'format_hidden' is used, instead of the formatter 
generated for the type constructor.
<pre>
  val x = D1 : t
  print "val x = "
  printFormat format_hidden x
  print ": -"
</pre>
(IMPLEMENTATION NOTE:if a type constructor 't' is not included in tyConEnv, 
it is hidden.)
</p>
<p>
And, types declared in a structure which is opaque constrainted by a signature.
The generator inserts a specification of formatters into signature which user 
inputs.
</p>
<p>
 The generator modifies a signature input by user
<pre>
  signature S = sig type t val x : t end;
</pre>
into the following.
<pre>
  signature S =
    sig
      type t
      val format_t : t -> string
      val x : t
    end
</pre>
And, the generator inserts formatter function into structures.
From:
<pre>
  structure S = struct datatype t = D val x = D end;
</pre>
to:
<pre>
  structure S = 
  struct datatype t = D fun format_t x = case x of D => "D" val x = D end;
</pre>
When structure is constrainted by signature opaquely, 'format_opaque' is used.
Otherwise, the generated formatter is used.
For example,
<pre>
  structure S1 : S = S
  val x = S1.x

  structure S2 :> S = S
  val x = S2.x
</pre>
is translated into:
<pre>
  structure S1 : S = S
  val x = S1.x
  print "val x = "
  printFormat S1.format_t x
  print " : S1.t"

  structure S2 :> S = S
  val x = S2.x
  print "val x = "
  printFormat format_opaque x
  print " : S2.t"
</pre>
</p>

<h4>
Formatter for polymorphic type
</h4>
<p>
 In SML, global variables of polymorphic type can be declared.
For example, assume the following datatype is declared,
<pre>
  - datatype 'a list = Nil | Cons of 'a * 'a list
</pre>
and its formatter is generated.
<pre>
  setGlobal fun format_list format_'a = ..
</pre>
Then, user can declare a global variable of polymorphic type as follows:
<pre>
  - val null = Nil
</pre>
This "null" has a type "'X list" for a type variable 'X.
For this declaration, the compiler generates the following code:
<pre>
  setGlobal null = Nil
  printFormat (format_list format_unknown null)
</pre>
The format_unknown function raises an exception always when called.
Normally, this format_unknown is never called in the format_list.
</p>
<p>
There is an rare case 
<pre>
  fun loop x = loop x
  val y = loop 1
</pre>
The following code is generated to print the value of 'y'.
<pre>
  print "val y = "
  printFormat format_unknown y
  print " : 'b"
</pre>
The 'loop' has the type 'a -> 'b, and 'loop 1' has a type 'b. 
The format_unknown will be called when the value of 'y' is printed. In this 
case, 'format_unknown' should not raise exception because the source code 
does not contain any error, but what to be printed ?
The answer is that the formatter is not invoked because evaluation of 'loop 1'
 will not stop.
</p>

<hr>
<h3>
formatter generation for exceptions
</h3>
<p>
 When an raised exception is not caught by any handler, the SML/NJ prints the
 constructor name of it, but does not print the whole inner structure. This is
 inconvenient in order to determine the reason of the error.
<pre>
  - exception Error of string;
  exception Error of string
  - val x = raise Error "foo";
  uncaught exception Error
  raised at: stdIn:20.15-20.26
</pre>
The argument "foo" of Error is not printed.
And the implementation of 'exnMessage' in SML/NJ does not print helpful 
message.
(Does the SML/NJ provide any way to customize this behavior ?)
</p>
<p>
 It would be useful to apply the formatter generation to this exception 
printing.
But there are two issues.
</p>

<h4>
Incremental extension of formatter function
</h4>
<p>
 Because 'exn' is extensible, it is impossible to define a single formatter
function which processes every exception.
So, the formatter should be extended, accompanying extension of exception 
constructor.
</p>
<p>
 First, define the initial formatter. This aborts anytime if called. It will 
not be invoked unless compiler has a bug.
In order to handle exception constructor declared in structure, declare a 
reference to a formatter as a global variable.
<pre>
  val format_exnRef = ref (fn x : exn => "compiler bug!")
</pre>
and updates it at each exception declaration to handle the new exception 
constructor.
<pre>
  (* user code *)
  exception Error of string;

  (* generated code *)
  let
    val prev_formatter = !format_exnRef
    fun format_exn x =
        case x of
          Error message => "Error " ^ message
        | other => prev_formatter other
  in
    format_exnRef := format_exn
  end
</pre>
</p>
<p>
 The strategy can handle exceptions declared in structures, such as:
<pre>
  structure S =
  struct
    exception Error of string
  end
</pre>
And this makes it to be able to handle hidden exception constructors, such as:
<pre>
  local exception Error of string
  in val x = raise Error "error" end
</pre>
NOTE: The format_exn must be defined recursively to handle exceptions such as 
the following,
<pre>
  exception of CapsuledException of exn
</pre>
and also must be able to call previously defined format_exn.
</p>

<h4>
Handler for declaration
</h4>
<p>
 The compiler regards the program as a sequence of declarations.
Assume a declaration:
<pre>
 val x = raise Error "error"
</pre>
 When the runtime executes this declaration, the valid behavior is not only 
that the evaluation of bound expression aborts, but also that any global 
binding 'x' should not be created.
</p>
<p>
 The exception printing should not distort this behavior.
So, the above declaration is translated into:
<pre>
  val x = (raise Error "error")
          handle
            e =>
              (
                print "uncaught exception ";
                printFormat format_exn e;
                raise e
              )
</pre>
The raised exception is re-raised, which aborts global binding of 'x'.
</p>

<hr>
<h3>
Implementation
</h3>
<p>
 The frontend passes source program from phase to phase in the following order:
<pre>
       user program
  1,parse
       Absyn (parser/absyn.ppg)
  2,elaborate
       PatternExpr (patterncalc/patterncalc.ppg)
  3,type inference
       TypedPL (typedcalc/typedcalc.ppg)
  4,pattern match compile
         :
</pre>
 The FormatterGenerator generates formatter code in TypedPL form and passes 
it to the pattern match compiler.
It would be easier to generate the Absyn code, not the TypedPL code, and pass 
it to the elaborator. 
</p>

<p>
The generator generates the two types of SML codes:
<ul>
  <li>definition of a formatter function for a type constructor</li>
  <li>expressions to print values bound to global variables</li>
</ul>
</p>
<p>
 For a type constructor defined by datatype declaration, it is necessary to 
define a formatter function which can traverse recursive data structure of the 
type,because the type constructor can be declared recursively like list.
</p>

<h4>
generating formatter function declaration
</h4>

<p>
The algorithm '<code>F E (e : ty)</code>' generates formatting code for an
 expression <code>e</code> of type <code>ty</code>.
<code>E</code> is a formatter environment which maps a type constructor ID or
a type variable to a formatter ID.
</p>
<pre>
F E (e : TYVARty(ref SUBSTITUTED ty)) = F E (e : ty)
F E (e : TYVARty(ref TVAR tvKind)) = let val f = E tvKind in [f e] end
F E (e : BOUNDVARty(index)) = [raise Fail]
F E (e : FUNty(ty1, ty2)) = ["fn"]
F E (e : RECORDty {l1:ty1, ..., ln:tyn}) =
    let val e1 = F E ([#l1 e] : t1) ... val en = F E ([#ln e] : tn)
    in
      if isTupleTy {l1, ..., ln}
      then ["(" ^ e1 ^ "," ^ ... ^ "," ^ en ^ ")"] end
      else ["{" ^ l1 ^ " = " ^ e1 ^ "," ^ ... ^ ln ^ " = " ^ en ^ "}"]
    end
F E (e : CONty{tyCon, {ty1, ..., tyn}}) =
    let
      val f = E tyCon
      val f1 = let val e1 = F E (x : ty1) in [fn x => e1] end
           :
      val fn = let val en = F E (x : tyn) in [fn x => en] end
    in [f f1 ... fn e] end
F E (e : POLYty{{btv1, ..., btvn}, body}) = F E (e : body)
F E (e : DUMMYty) = [raise Fail]
</pre>
</p>
<p>
Algorithm '<code>G</code>' generates printing code for global binding.
<pre>
G E [x] ty = let val f = F E ty in [print f x] end
</pre>
</p>
<p>
Algorithm '<code>D</code>' generates a formatter function for a datatype.
<pre>
D E [datatype ('a1,...,'ak) dt = D1 of t1 | ... | Dn of tn] =
let
  val E' = E{'a1 <= format_a1,...,'ak <= format_ak}
  val e1 = F E' (x : t1)
       :
  val en = F E' (x : tn)
in
   [fun format_dt format_a1 ... format_ak x =
        case x of
           D1 x1 => "D1" ^ e1
            :
         | Dn xn => "Dn" ^ en]
end
</pre>
</p>

 * @author YAMATODANI Kiyoshi
 * @author UENO Katsuhiro
 * @version $Id: PrinterGenerator.sml,v 1.204 2008/08/04 13:25:37 bochao Exp $
 *)
structure PrinterGenerator : PRINTER_GENERATOR =
struct
local
  (***************************************************************************)

  structure A = Absyn
  structure BF = SMLFormat.BasicFormatters
  structure CT = ConstantTerm
  structure FE = SMLFormat.FormatExpression
  structure FG = FormatterGenerator
  structure NPEnv = NameMap.NPEnv
  structure OC = ObjectCode
  structure P = Path
  structure PG = PrintCodeGenerator
  structure PT = PredefinedTypes
  structure TC = TypeContext
  structure TCU = TypeContextUtils
  structure TP = TypedCalc
  structure TPU = TypedCalcUtils
  structure TY = Types
  structure U = Utility

in
  (**
   * This context stores information to judge whether generation of cathc-all
   * handler and generation of printer code of binding information are
   * required or not.
   * <p>
   * A val binding cab be declared at global top level, at top level in
   * a structure, or other.
   * As shown in the following table, whether the printer generator should
   * generate additional code for a val binding or not is decided according
   * to position of the val binding.
   * <pre>
   *                     |local|catch all handler| print bind |
   * --------------------+-----+-----------------+------------+
   *      top level      |  n  |     yes         | printBinds |
   *                     |  y  |     yes         |    no      |
   * --------------------+-----+-----------------+------------+
   * structure top level |  n  |     yes         |    no      |
   *                     |  y  |     yes         |    no      |
   * --------------------+-----+-----------------+------------+
   *    non top level    |     |     no          |    no      |
   * --------------------+-----+-----------------+------------+
   * </pre>
   * Here, <code>printBinds</code> is a boolean parameter passed to the
   * generate function of the PrinterGenerator.
   * </p>
   * <p>
   * Example.
   * <pre>
   *   local
   *     val glt = exp
   *     structure LS = struct val st = exp end
   *   in
   *   val gt = let
   *               val nt = exp
   *            in exp end
   *   end;
   *   structure S =
   *   struct
   *     val st = exp
   *   end
   * </pre>
   * In this code, <code>gt</code> is at global top level, <code>st</code> is
   * structure top level, and <code>nt</code> is at non top level.
   * Into this code, the printer generator inserts additional code as follows.
   * <pre>
   *   local
   *     val glt = exp handle exn => (printExn exn; ...)
   *     structure LS =
   *     struct val st = exp handle exn => (printExn exn; ...) end
   *   in
   *   val gt = let
   *               val nt = exp
   *            in exp end
   *            handle exn => (printExn exn; ...)
   *   val _ = print "val g = " ^ format_t gt ^ " : t"
   *   end;
   *   structure S =
   *   struct
   *     val st = exp
   *              handle exn => (printExn exn; ...);
   *   end
   * </pre>
   *)
  structure PositionContext =
  struct
  
    datatype position = Top | StructureTop | NonTop

    type context = {printBind : bool, position : position, isLocal : bool}

    fun create printBind =
        {printBind = printBind, position = Top, isLocal = false}

    fun enterStructure {printBind, position = NonTop, isLocal} =
        raise Control.Bug "PositionContext.enterStructure"
      | enterStructure {printBind, position, isLocal} =
        {printBind = printBind, position = StructureTop, isLocal = isLocal}

    fun enterLocal {printBind, position, isLocal} =
        {printBind = printBind, position = position, isLocal = true}

    fun enterNonTop {printBind, position, isLocal} =
        {printBind = printBind, position = NonTop, isLocal = isLocal}

    fun isPrintBinds {printBind, position = Top, isLocal = false} = printBind
      | isPrintBinds {printBind, position, isLocal} = false

    fun isCatchAllHandlerGenerate {printBind, position = NonTop, isLocal} =
        false
      | isCatchAllHandlerGenerate {printBind, position, isLocal} = true

    fun getPosition ({position, ...} : context) = position

  end
  structure PC = PositionContext

  (***************************************************************************)

  type context = TC.context

  (***************************************************************************)

  fun formatterVarInfoOfTyBindInfo tyBindInfo =
      let
        val (namePath, monoFormatterTy) =
            case tyBindInfo of
                TY.TYCON {tyCon as {name, strpath, ...}, ...} => 
                ((name,strpath), OC.tyOfFormatterOfDefinedTyCon tyCon)
              | TY.TYFUN (tyFun as {name, strpath, ...}) => 
                ((name, strpath), OC.tyOfFormatterOfTyFun tyFun)
              | TY.TYOPAQUE {spec = tyCon as {name, strpath, ...},...} => 
                ((name, strpath), OC.tyOfFormatterOfTySpec tyCon)
              | TY.TYSPEC (tyCon as {name, strpath, ...}) => 
                ((name, strpath), OC.tyOfFormatterOfTySpec tyCon)
        val formatterNamePath = U.formatterNameOfTyNamePath namePath
        val formatterTy = U.generalize monoFormatterTy
        val formatterVarInfo = {namePath = formatterNamePath, ty = formatterTy}
      in
        formatterVarInfo
      end

  fun insertFormatterIntoEnv ((tyConEnv, varEnv) : TY.Env) =
      let
        fun bindFormatterOfBindInfo (namePath, tyBindInfo, newVarEnv) =
            let
              val varInfo = formatterVarInfoOfTyBindInfo tyBindInfo
              (* val varPathInfo = (*U.varInfoToVarPathInfo*) varInfo*)
            in
              NPEnv.insert (newVarEnv, #namePath varInfo, TY.VARID(varInfo))
            end
        val newVarEnv = NPEnv.foldli bindFormatterOfBindInfo varEnv tyConEnv
      in
        (tyConEnv, newVarEnv)
      end

  fun insertFormatterIntoTopEnv ((tyConEnv, varEnv) : TY.topEnv) =
      let
          fun bindFormatterOfBindInfo (tyBindInfo, newVarEnv) =
              let
                  val varInfo = formatterVarInfoOfTyBindInfo tyBindInfo
              in
                  SEnv.insert (newVarEnv, NameMap.namePathToString(#namePath varInfo), TY.VARID(varInfo))
              end
          val newVarEnv = SEnv.foldl bindFormatterOfBindInfo varEnv tyConEnv
      in
          (tyConEnv, newVarEnv)
      end

  local
    fun formatterNamePathOfTyState tyState =
        case tyState of
          NameMap.DATATY ((name, path), _) =>
          (U.formatterNameOfTyName name, path)
        | NameMap.NONDATATY (name, path) => (U.formatterNameOfTyName name, path)
  in
  
  fun insertFormatterIntoNamePathEnv
          ((tyNameMap, varNameMap) : NameMap.basicNameNPEnv) =
      let
        fun bindFormatterOfTyState
                ((srcName, srcPath), tyState, newVarNameMap) =
            let
              val namePath = formatterNamePathOfTyState tyState
            in
              NPEnv.insert
                  (
                    newVarNameMap, 
                    (U.formatterNameOfTyName srcName, srcPath),
                    NameMap.VARID(namePath)
                  )
            end
        
        val newVarNameMap =
            NPEnv.foldli bindFormatterOfTyState varNameMap tyNameMap
      in
        (tyNameMap, newVarNameMap)
      end
  end

  fun replaceTySpecToTyConInEnv
          ((tyConEnv, varEnv) : TY.Env) =
      let
          fun replaceTyBindInfo (TY.TYOPAQUE {spec = tyCon,...}) =
              TY.TYCON {tyCon = tyCon, datacon = SEnv.empty}
            | replaceTyBindInfo (TY.TYSPEC tyCon) =
              TY.TYCON {tyCon = tyCon, datacon = SEnv.empty}
            | replaceTyBindInfo tyBindInfo = tyBindInfo
        val newTyConEnv = NPEnv.map replaceTyBindInfo tyConEnv
        fun replaceInStructure {name, env} =
            let val newEnv = replaceTySpecToTyConInEnv env
            in
              {name = name, (*id = id, strpath = strpath, *)env = newEnv}
            end
      in (newTyConEnv, varEnv)
      end

  (**
   * indicates whether evaluation of an expression can raise any exception.
   * If an expression "e" is safe, it is unnecessary to wrap it in catch all
   * handler.
   *)
  fun isSafeExpression exp =
      case exp of
        TP.TPFFIIMPORT {ptrExp, ffiTy, stubTy, loc} => isSafeExpression ptrExp
      | TP.TPSIZEOF _ => true
      | TP.TPERROR => raise Control.Bug "isSafeExpression: TPERROR"
      | TP.TPCONSTANT _ => true
      | TP.TPGLOBALSYMBOL _ => true
      | TP.TPVAR _ => true
      | TP.TPRECFUNVAR _ => true
      | TP.TPPRIMAPPLY _ => false
      | TP.TPOPRIMAPPLY _ => false
      | TP.TPDATACONSTRUCT {argExpOpt=NONE, ...} => true
      | TP.TPDATACONSTRUCT {argExpOpt=SOME exp, ...} => isSafeExpression exp
      | TP.TPEXNCONSTRUCT {argExpOpt=NONE, ...} => true
      | TP.TPEXNCONSTRUCT {argExpOpt=SOME exp, ...} => isSafeExpression exp
      | TP.TPAPPM _ => false
      | TP.TPMONOLET {binds=binds, bodyExp=body, loc=loc} =>
        (List.all (fn (_, exp) => isSafeExpression exp) binds)
        andalso (isSafeExpression body)
      | TP.TPLET (decs, exps, _, _) =>
        (List.all isSafeDeclaration decs)
        andalso (List.all isSafeExpression exps)
      | TP.TPRECORD {fields, ...} =>
        List.all isSafeExpression (SEnv.listItems fields)
      | TP.TPSELECT {exp=recordExp, ...} => isSafeExpression recordExp
      | TP.TPMODIFY {recordExp = exp1, elementExp = exp2, ...} =>
        isSafeExpression exp1 andalso isSafeExpression exp2
      | TP.TPRAISE _ => false
      | TP.TPHANDLE {exp=bodyExp, handler=handlerExp, ...} =>
        (isSafeExpression bodyExp) andalso (isSafeExpression handlerExp)
      | TP.TPCASEM {expList, expTyList, ruleList, ruleBodyTy, caseKind, loc} =>
        List.all isSafeExpression expList
        andalso List.all isSafeExpression (map #2 ruleList)
      | TP.TPFNM _ => true
      | TP.TPPOLYFNM _ => true
      | TP.TPPOLY {exp, ...} => isSafeExpression exp
      | TP.TPTAPP {exp, ...} => isSafeExpression exp
      | TP.TPSEQ {expList=exps, ...} => List.all isSafeExpression exps
      | TP.TPLIST {expList=exps, ...} => List.all isSafeExpression exps
      | TP.TPCAST (exp,_,_) => isSafeExpression exp
      | TP.TPSQLSERVER _ => true

  and isSafeDeclaration dec =
      case dec of
        TP.TPVAL (binds, _) =>
        List.all (fn (_, exp) => isSafeExpression exp) binds
      | TP.TPVALREC (binds, _) =>
        List.all (fn {exp,...} => isSafeExpression exp) binds
      | TP.TPVALPOLYREC (_, binds, _) =>
        List.all (fn {exp,...} => isSafeExpression exp) binds
      | TP.TPVALRECGROUP (_, decls, _) => List.all isSafeDeclaration decls
      | TP.TPLOCALDEC (locals, globals, _) =>
        (List.all isSafeDeclaration locals)
        andalso (List.all isSafeDeclaration globals)
      | _ => true

  fun generateCatchAllHandler (basis:U.basis) path (exp, ty) =
      if isSafeExpression exp
      then exp
      else
        (* exp
         * handle e => (print (format_exn e); print "\n"; raise e)
         *)
        let
          val loc = TPU.getLocOfExp exp
          val exnVarName = U.makeVarName ()
          val exnVarInfo =
              {namePath = (exnVarName, Path.NilPath), ty = PT.exnty}
          val exnVarPathInfo = (*U.varInfoToVarPathInfo*) exnVarInfo
          val exnFormatterExp =
              FG.generateFormatterOfTy basis path NONE [] [] loc PT.exnty
          val exnFormatterTy = OC.tyOfFormatterOfTy PT.exnty
          val handlerBodyExp =
              TP.TPSEQ
              {
                expList =
                [
                  OC.printFormat
                      (TP.TPAPPM
                           {
                             funExp = exnFormatterExp,
                             funTy = exnFormatterTy,
                             argExpList = [TP.TPVAR (exnVarPathInfo, loc)],
                             loc = loc
                           }),
                  OC.printString ("\n", loc),
                  TP.TPRAISE(TP.TPVAR (exnVarPathInfo, loc), ty, loc)
                ],
                expTyList = [PT.unitty, PT.unitty, ty],
                loc = loc
              }
        in
          TP.TPHANDLE
              {
                exp = exp,
                exnVar = exnVarPathInfo,
                handler = handlerBodyExp,
                loc = loc
              }
        end

  (***************************************************************************)

  fun visitSequential
          visitElement (basis:U.basis) path positionCTX declarations =
      let
        (* modifiedDeclarations is in reverse order. *)
        val (newContext, modifiedDeclarationsLists) = 
            foldl
                (fn (declaration, (context, extendedDeclarationsLists)) =>
                    let
                      val newBasis = 
                          {global = #global basis,
                           current = U.unionContexts [#current basis, context]}
                      (*val newBaseContext =
                          U.unionContexts [baseContext, context]*)
                      val (newContext, newDeclarations) =
                          visitElement
                              newBasis path positionCTX declaration
                    in
                      (
                        U.unionContexts [context, newContext],
                        newDeclarations :: extendedDeclarationsLists
                      )
                    end)
                (TC.emptyContext, [])
                declarations
      in
        (newContext, List.concat(List.rev modifiedDeclarationsLists))
      end

  fun visitExp (basis:U.basis) path positionCTX exp =
      let fun visit exp = visitExp basis path positionCTX exp
      in
        case exp of
          TP.TPPRIMAPPLY {primOp, instTyList, argExpOpt = SOME argExp, loc} =>
          TP.TPPRIMAPPLY
              {
                primOp = primOp,
                instTyList = instTyList,
                argExpOpt = SOME(visit argExp),
                loc = loc
              }
        | TP.TPDATACONSTRUCT {con, instTyList, argExpOpt = SOME argExp, loc} =>
          TP.TPDATACONSTRUCT
              {
                con = con,
                instTyList = instTyList,
                argExpOpt = SOME(visit argExp),
                loc = loc
              }
        | TP.TPEXNCONSTRUCT {exn, instTyList, argExpOpt = SOME argExp, loc} =>
          TP.TPEXNCONSTRUCT
              {
                exn = exn,
                instTyList = instTyList,
                argExpOpt = SOME(visit argExp),
                loc = loc
              }
        | TP.TPAPPM {funExp, funTy, argExpList, loc} =>
          TP.TPAPPM
              {
                funExp = visit funExp,
                funTy = funTy, 
                argExpList = map visit argExpList, 
                loc = loc
              }
        | TP.TPMONOLET {binds, bodyExp, loc} =>
          let
            fun visitBind (varInfo, exp) = (varInfo, visit exp)
            val newBinds = map visitBind binds
            val newBodyExp = visit bodyExp
          in
            TP.TPMONOLET {binds = newBinds, bodyExp = newBodyExp, loc = loc}
          end
        | TP.TPLET(decs, exps, tys, loc) =>
          let val newDecs = #2(visitDecs basis path positionCTX decs)
          in TP.TPLET(newDecs, map visit exps, tys, loc)
          end
        | TP.TPRECORD {fields, recordTy, loc} =>
          TP.TPRECORD
              {fields = SEnv.map visit fields, recordTy = recordTy, loc=loc}
        | TP.TPSELECT {label, exp, expTy, resultTy, loc} =>
          TP.TPSELECT
              {
                label = label,
                exp = visit exp,
                expTy =  expTy,
                resultTy = resultTy,
                loc = loc
              }
        | TP.TPMODIFY
              {label, recordExp, recordTy, elementExp, elementTy, loc} =>
          TP.TPMODIFY
              {
                label = label, 
                recordExp = visit recordExp, 
                recordTy = recordTy, 
                elementExp = visit elementExp,
                elementTy = elementTy,
                loc = loc
              }
        | TP.TPRAISE (exp, ty, loc) => TP.TPRAISE(visit exp, ty, loc)
        | TP.TPHANDLE {exp, exnVar, handler, loc} =>
          let
            val newExp = visit exp
            val newHandler = visit handler
          in
            TP.TPHANDLE
               {exp = newExp, exnVar = exnVar, handler = newHandler, loc = loc}
          end
        | TP.TPCASEM
              {expList, expTyList, ruleList, ruleBodyTy, caseKind, loc} =>
          TP.TPCASEM
              {
                expList = map visit expList,
                expTyList = expTyList,
                ruleList =
                map (fn (patList, exp) => (patList, visit exp)) ruleList,
                ruleBodyTy = ruleBodyTy,
                caseKind = caseKind,
                loc = loc
              }
        | TP.TPFNM {argVarList, bodyTy, bodyExp, loc} =>
          TP.TPFNM
              {
                argVarList = argVarList,
                bodyTy = bodyTy,
                bodyExp = visit bodyExp,
                loc = loc
              }
        | TP.TPPOLYFNM {btvEnv, argVarList, bodyTy, bodyExp, loc} =>
          TP.TPPOLYFNM
              {
                btvEnv = btvEnv, 
                argVarList = argVarList,
                bodyTy = bodyTy,
                bodyExp = visit bodyExp, 
                loc = loc
              }
        | TP.TPPOLY {btvEnv, expTyWithoutTAbs, exp, loc} =>
          TP.TPPOLY
              {
                btvEnv = btvEnv,
                expTyWithoutTAbs = expTyWithoutTAbs,
                exp = visit exp,
                loc = loc
              } 
        | TP.TPTAPP {exp, expTy, instTyList, loc} => 
          TP.TPTAPP
              {
                exp = visit exp,
                expTy = expTy,
                instTyList = instTyList,
                loc = loc
              }
        | TP.TPLIST {expList, listTy, loc} => 
          TP.TPLIST
              {expList = map visit expList, listTy = listTy, loc = loc}
        | TP.TPSEQ {expList, expTyList, loc} => 
          TP.TPSEQ
              {expList = map visit expList, expTyList = expTyList, loc = loc}
        | exp => exp
      end
      
  and visitDecs (basis:U.basis) path positionCTX declarations =
      visitSequential visitDec basis  path positionCTX declarations

  and visitValBinds basis path positionCTX loc binds =
      let
        fun isNamedBind (TY.VALIDVAR _, _) = true
          | isNamedBind (TY.VALIDWILD _, _) = false
        val namedBinds = List.filter isNamedBind binds

        val newBinds = 
            map
                (fn (valID, exp) =>
                    (
                      valID,
                      visitExp basis path (PC.enterNonTop positionCTX) exp
                    ))
                binds
        fun getTyOfValID (TY.VALIDVAR varInfo) = #ty varInfo
          | getTyOfValID (TY.VALIDWILD ty) = ty
        fun makeHandledBind(valID, exp) =
            (
              valID,
              generateCatchAllHandler basis path (exp, getTyOfValID valID)
            )
        val handledBinds =
            if PC.isCatchAllHandlerGenerate positionCTX
            then map makeHandledBind newBinds
            else newBinds

        fun bindVarBind ((TY.VALIDVAR varInfo, _), newContext) =
            let
              val varNamePath = #namePath varInfo
              val idState = TY.VARID((*U.varInfoToVarPathInfo*) varInfo)
              (*
               Changed by Ohori, Dec 6, 2006.
                  in TC.bindVarInContext (newContext, varName, idState)
               *)
            in
              TC.bindVarInContext
                  (TY.toplevelDepth, newContext, varNamePath, idState)
            end
          | bindVarBind _ =
            raise 
              Control.Bug
              "non VALIDVAR to bindVarBind \
              \(printergeneration/main/PrinterGenerator.sml)" 
            
        val bindContext = foldl bindVarBind TC.emptyContext namedBinds

        fun getVarInfoOfValID (TY.VALIDVAR varInfo, _) = varInfo
          | getVarInfoOfValID _ = 
            raise 
              Control.Bug 
                  "non VALIDVAR to getVarInfoOfValID \
                  \(printergeneration/main/PrinterGenerator.sml)"
        val printCodesMap =
            if PC.isPrintBinds positionCTX
            then
              let val varInfos = map getVarInfoOfValID namedBinds
              in PG.generatePrintCodeForVals basis path loc varInfos
              end
            else SEnv.empty
      in
        (bindContext, handledBinds, printCodesMap)
      end

  and visitFunBinds basis path positionCTX loc btvMapOpt binds =
      let
        fun visitRule position (pats, exp) =
            (pats, visitExp basis path position exp)
        val newBinds = 
            map
                (fn {funVar, argTyList, bodyTy, ruleList} =>
                    {
                      funVar = funVar,
                      argTyList = argTyList,
                      bodyTy = bodyTy,
                      ruleList =
                      map (visitRule (PC.enterNonTop positionCTX)) ruleList
                    })
                binds

        val bindContext =
            foldl
                (fn ({funVar, ...}, newContext) =>
                    let
                      val varNamePath = #namePath funVar
                      val idState = TY.VARID((*U.varInfoToVarPathInfo*) funVar)
                    (*
                     Changed by Ohori, Dec 6, 2006.
                    in TC.bindVarInContext (newContext, varName, idState)
                     *)
                    in
                      TC.bindVarInContext
                          (TY.toplevelDepth, newContext, varNamePath, idState)
                    end)
                TC.emptyContext
                newBinds

        val printCodesMap =
            if PC.isPrintBinds positionCTX
            then
              let
                val transVarInfo =
                    case btvMapOpt
                     of NONE => (fn v => v)
                      | SOME btvMap =>
                        (fn v =>
                            {
                              ty = TY.POLYty{boundtvars = btvMap,body = #ty v},
                              namePath = #namePath v
                            })
                val varInfos = map (transVarInfo o #funVar) newBinds
              in PG.generatePrintCodeForVals basis path loc varInfos
              end
            else SEnv.empty
      in
        (bindContext, newBinds, printCodesMap)
      end

  and isValDec (TP.TPVAL _) = true
    | isValDec (TP.TPVALREC _) = true
    | isValDec (TP.TPVALPOLYREC _) = true
    | isValDec (TP.TPLOCALDEC _) = true
    | isValDec (TP.TPFUNDECL _) = true
    | isValDec (TP.TPPOLYFUNDECL _) = true
    | isValDec _ = false

  (** This function is defined to share code for val/fun declarations.
   * This function returns printCodesMap which maps each bound name to a print
   * code for it.
   *)
  and visitValDec (basis:U.basis) path positionCTX valDeclaration =
      case valDeclaration of
        TP.TPVAL (binds, loc) =>
        let
          val (context, handledBinds, printCodesMap) =
              visitValBinds basis path positionCTX loc binds
        in
          (context, [TP.TPVAL(handledBinds, loc)], printCodesMap)
        end
      | TP.TPVALREC (binds, loc) =>
        let
          val valIDBinds =
              map (fn {var, expTy, exp} => (TY.VALIDVAR var, exp)) binds
          val (context, handledValIDBinds, printCodesMap) =
              visitValBinds basis path positionCTX loc valIDBinds
          val handledBinds =
              map
                  (fn (TY.VALIDVAR varInfo, exp) =>
                      {var = varInfo, expTy = #ty varInfo, exp = exp}
                    | _ => 
                        raise 
                          Control.Bug
                          "non VALIDVAR in handledValIDBinds \
                          \(printergeneration/main/PrinterGenerator.sml)" )
              handledValIDBinds
        in
          (context, [TP.TPVALREC(handledBinds, loc)], printCodesMap)
        end
      | TP.TPVALPOLYREC(btvMap, binds, loc) =>
        let
          (* each ty in varInfo in binds should be wraped in POLY when
           * generating printer codes. *)
          fun toPoly {namePath, ty} =
              {
                namePath = namePath,
                ty = TY.POLYty{boundtvars = btvMap, body = ty}
              }
          fun toMono {namePath, ty = TY.POLYty{body = ty, ...}} =
              {namePath = namePath, ty = ty}
            | toMono _ = 
              raise 
                Control.Bug 
                    "non POLYty to toMono \
                    \(printergeneration/main/PrinterGenerator.sml)" 
          val valIDBinds =
              map
                  (fn {var, expTy, exp} => (TY.VALIDVAR(toPoly var), exp))
                  binds
          val (context, handledValIDBinds, printCodesMap) =
              visitValBinds basis path positionCTX loc valIDBinds
          val handledBinds =
              map
                  (fn (TY.VALIDVAR varInfo, exp) =>
                      let val newVarInfo = toMono varInfo
                      in {var = newVarInfo, expTy = #ty newVarInfo, exp = exp}
                      end
                    | _ => 
                        raise 
                          Control.Bug
                              "non VALIDVAR in handledValIDBinds \
                              \(printergeneration/main/PrinterGenerator.sml)")
                  handledValIDBinds
        in
          (
            context,
            [TP.TPVALPOLYREC(btvMap, handledBinds, loc)],
            printCodesMap
          )
        end
      | TP.TPLOCALDEC(localDecs, globalDecs, loc) =>
        (* For optimization, the type inferencer generates 'local' declaration
         * in VALRECGROUP.
         *)
        let
          val (localContext, newLocalDecs) = 
              visitDecs basis path (PC.enterLocal positionCTX) localDecs
          val newBasis =
              {
                global = #global basis,
                current = U.unionContexts [#current basis, localContext]
              }
          (*val newLocalContext = U.unionContexts [context, localContext]*)
          fun visit context path position dec =
              if isValDec dec
              then
                let
                  val (newContext, newDec, printCodesMap) =
                      visitValDec context path position dec
                in (newContext, ([(newDec, printCodesMap)]))
                end
              else
                let
                  val (newContext, newDec) = visitDec context path position dec
                in (newContext, ([(newDec, SEnv.empty)]))
                end
          val (newContext, newGlobalDecAndMaps) =
              visitSequential visit newBasis path positionCTX globalDecs
          val (newGlobalDecs, printCodesMap) =
              List.foldl
                  (fn ((decs, map), (globalDecs, printCodesMap)) =>
                      (
                        globalDecs @ decs,
                        SEnv.unionWith #1 (map, printCodesMap)
                      ))
                  ([], SEnv.empty)
                  newGlobalDecAndMaps
          val newDec = TP.TPLOCALDEC(newLocalDecs, newGlobalDecs, loc)
        in
          (newContext, [newDec], printCodesMap)
        end
      | TP.TPFUNDECL (funBinds, loc) =>
        let
          val (newContext, newFunBinds, printCodesMap) =
              visitFunBinds basis path positionCTX loc NONE funBinds
        in
          (newContext, [TP.TPFUNDECL(newFunBinds, loc)], printCodesMap)
        end
      | TP.TPPOLYFUNDECL(btvMap, funBinds, loc) =>
        let
          val (newContext, newFunBinds, printCodesMap) =
              visitFunBinds basis path positionCTX loc (SOME btvMap) funBinds
        in
          (
            newContext,
            [TP.TPPOLYFUNDECL(btvMap, newFunBinds, loc)],
            printCodesMap
          )
        end

      | _ => raise Control.Bug ("unknown declaration is passed to visitValDec")

  (**
   *)
  and visitDec (basis:U.basis) path positionCTX declaration =
      case declaration of
        (* NOTE: The following cases for val declrarations are some tricky.
         * This is in order to share codes with the case for VALRECGROUP.
         *)
        TP.TPVAL (binds, loc) =>
        let
          val (newContext, handledDecs, printCodesMap) =
              visitValDec basis path positionCTX declaration
        in (newContext, handledDecs @ SEnv.listItems printCodesMap)
        end
      | TP.TPFUNDECL _ =>
        let
          val (newContext, handledDecs, printCodesMap) =
              visitValDec basis path positionCTX declaration
        in (newContext, handledDecs @ SEnv.listItems printCodesMap)
        end
      | TP.TPPOLYFUNDECL _ => 
        let
          val (newContext, handledDecs, printCodesMap) =
              visitValDec basis path positionCTX declaration
        in (newContext, handledDecs @ SEnv.listItems printCodesMap)
        end
      | TP.TPVALREC (binds, loc) =>
        let
          val (newContext, handledDecs, printCodesMap) =
              visitValDec basis path positionCTX declaration
        in (newContext, handledDecs @ SEnv.listItems printCodesMap)
        end
      | TP.TPVALPOLYREC(btvMap, binds, loc) =>
        let
          val (newContext, handledDecs, printCodesMap) =
              visitValDec basis path positionCTX declaration
        in (newContext, handledDecs @ SEnv.listItems printCodesMap)
        end
      | TP.TPVALRECGROUP (ids, decs, loc) =>
        if PC.Top = PC.getPosition positionCTX
        then
          let
            fun visit (dec, (bindContext, handledDecs, printCodeMap)) =
                let
                  val newBasis =
                      {
                        global = #global basis,
                        current = U.unionContexts [#current basis, bindContext]
                      }
                  val (newContext, newHandledDecs, newPrintCodeMap) =
                      visitValDec newBasis path positionCTX dec
                  val resultHandledDecs = newHandledDecs :: handledDecs
                  val resultPrintCodeMap =
                      SEnv.unionWith #1 (newPrintCodeMap, printCodeMap)
                  val extendedBindContext =
                      U.unionContexts [bindContext, newContext]
                in (extendedBindContext, resultHandledDecs, resultPrintCodeMap)
                end
            (* NOTE: handledDecs is in reverse order. *)
            val (newContext, handledDecs, printCodesMap) =
                foldl visit (TC.emptyContext, [], SEnv.empty) decs
            fun findPrintCode id =
                case SEnv.find (printCodesMap, id) of
                  SOME code => code
                | NONE =>
                  raise Control.Bug("printCode for " ^ id ^ " not found")
            val printCodes =
                if PC.isPrintBinds positionCTX
                then map findPrintCode ids
                else []
          in
            (newContext, List.concat(List.rev handledDecs) @ printCodes)
          end
        else
          (* VALRECGROUP has no effect except at the top level. *)
          visitDecs basis path positionCTX decs
      | TP.TPLOCALDEC(localDeclarations, globalDeclarations, loc) =>
        let
          val (localContext, newLocalDeclarations) = 
              visitDecs
                  basis path (PC.enterLocal positionCTX) localDeclarations
          val newBasis =
              {global = #global basis,
               current = U.unionContexts [#current basis, localContext]}
          val (newContext, newGlobalDeclarations) =
              visitDecs newBasis path positionCTX globalDeclarations
        in
          (
            newContext,
            [TP.TPLOCALDEC(newLocalDeclarations, newGlobalDeclarations, loc)]
          )
        end
(*
      | TP.TPOPEN (strPathInfos, loc) =>
        let
          fun extendContext ({env, ...} : TY.strPathInfo, newContext) =
              TC.extendContextWithEnv(newContext, env)
          val newContext = foldl extendContext TC.emptyContext strPathInfos
          val printCodes =
              if PC.isPrintBinds positionCTX
              then [PG.generatePrintCodeForOpen basis path loc strPathInfos]
              else []
        in
          (newContext, [declaration] @ printCodes)
        end
*)
      | TP.TPINTRO (basicNamePathEnv, typeEnv, strPathPair, loc) =>
        let
          val newTypeEnv = insertFormatterIntoEnv typeEnv
          val newBasicNamePathEnv =
              insertFormatterIntoNamePathEnv basicNamePathEnv
          val newContext = TC.extendContextWithEnv(TC.emptyContext, typeEnv)
          val printCodes =
              if PC.isPrintBinds positionCTX
              then [PG.generatePrintCodeForIntro loc (#original strPathPair)]
              else []
        in
          (
            newContext,
            [TP.TPINTRO (newBasicNamePathEnv, newTypeEnv, strPathPair, loc)]
            @ printCodes
          )
        end
      | TP.TPDATADEC (dataTyInfoList, loc) =>
        let
          val tyConBindContext = foldl U.bindTyCon TC.emptyContext dataTyInfoList
          (*val newTyConBindContext = U.unionContexts [basis, tyConBindContext]*)
          val newBasis =
              {
                global = #global basis,
                current = U.unionContexts [#current basis, tyConBindContext]
              }
          val (formatterBindContext, formatterDeclarations) =
              FG.generateFormatterForDatatypes
                  newBasis path positionCTX loc dataTyInfoList
          val printCodes =
              if PC.isPrintBinds positionCTX
              then [PG.generatePrintCodeForDatatypes basis path loc dataTyInfoList]
              else []
          val resultContext =
              U.unionContexts [tyConBindContext, formatterBindContext]
        in
          (resultContext, [declaration] @ printCodes @ formatterDeclarations)
        end
      | TP.TPABSDEC ({absDataTyInfos, rawDataTyInfos, decls}, loc) => 
        let
          (* rawTyCons are representation of tyCons visible in decls.
           * absTyCons are representation visible global.
           * For example,
           *   abstype dt = D in val x = D end
           * for this declaration, absTyCons and rawTyCons are as follows.
           *   absTyCons = [{name = "dt", id = i, datacon = []}]
           *   rawTyCons = [{name = "dt", id = i, datacon = ["D"]}]
           *)
            val (formatterBindContext, formatterDeclarations) =
                FG.generateFormatterForAbstypes
                    basis path positionCTX loc absDataTyInfos
            val tyConPrintCodes =
                if PC.isPrintBinds positionCTX
                then [PG.generatePrintCodeForAbstypes basis path loc absDataTyInfos]
                else []

          val absTyConBindContext = foldl U.bindTyCon TC.emptyContext absDataTyInfos
          val rawTyConBindContext = foldl U.bindTyCon TC.emptyContext rawDataTyInfos
          val innerBasis =
              {
                global = #global basis,
                current =
                U.unionContexts
                    [#current basis, rawTyConBindContext, formatterBindContext]
              }
          (*val innerContext =
              U.unionContexts
                  [basis, rawTyConBindContext, formatterBindContext]*)
          val (newContext, newDeclarations) =
              visitDecs innerBasis path positionCTX decls
          val codes = tyConPrintCodes @ formatterDeclarations @ newDeclarations
          val absInfo =
              {absDataTyInfos = absDataTyInfos, rawDataTyInfos = rawDataTyInfos, decls = codes}
          val newDeclaration = TP.TPABSDEC (absInfo, loc)

          val unionedContext = 
              U.unionContexts
                  [absTyConBindContext, formatterBindContext, newContext]
          (* substitute original tycon with abstracted tycon *)
          fun extendTyConSubst
                  ({tyCon ={id = rawTyConID, ...},...} : TY.dataTyInfo, absDataTyInfo, substMap) =
              TyConID.Map.insert (substMap, rawTyConID, TY.TYCON absDataTyInfo)
          val tyConSubst =
              ListPair.foldl
                  extendTyConSubst TyConID.Map.empty (rawDataTyInfos, absDataTyInfos)
          val substitutedContext =
              TCU.substTyConInContextPartially tyConSubst unionedContext
        in
          (substitutedContext, [newDeclaration])
        end
      | TP.TPDATAREPDEC
            (
             {left = leftDataTyInfo, 
              right = {name, dataTyInfo = rightDataTyInfo}},
              loc
            ) =>
        let
          val tyConBindContext = 
              TC.extendContextWithVarEnv
                  (
                    TC.bindTyConInContext
                        (
                          TC.emptyContext, 
                          (#name (#tyCon leftDataTyInfo), #strpath (#tyCon leftDataTyInfo)), 
                          TY.TYCON leftDataTyInfo
                        ),
                    TC.injectDataConToVarEnv ((#datacon leftDataTyInfo))
                  )
          val newBasis =
              {
                global = #global basis,
                current = U.unionContexts [#current basis, tyConBindContext]
              }
          val (formatterBindContext, formatterDeclarations) =
              FG.generateFormatterForDatatypeReplication
                  newBasis
                  path
                  positionCTX
                  loc
                  (leftDataTyInfo, name, rightDataTyInfo)
          val printCodes =
              if PC.isPrintBinds positionCTX
              then
                [
                  PG.generatePrintCodeForDatatypeReplication
                      basis
                      path
                      loc
                      (leftDataTyInfo, (Path.NilPath, name), rightDataTyInfo)
                ]
              else []
          val newContext =
              U.unionContexts [tyConBindContext, formatterBindContext]
        in
          (newContext, [declaration] @ printCodes @ formatterDeclarations)
        end
      | TP.TPEXNDEC (exnBinds, loc) =>
        let
          fun bindExn (exnBind, localContext) =
              case exnBind of
                TP.TPEXNBINDDEF (conInfo as {namePath = conNamePath, ...}) =>
                (*
                 Changed by Ohori, Dec 6, 2006.
                  TC.bindVarInContext (localContext, conName, TY.CONID(conInfo))
                *)
                TC.bindVarInContext
                    (
                      TY.toplevelDepth,
                      localContext,
                      conNamePath,
                      TY.EXNID(conInfo)
                    )
              | TP.TPEXNBINDREP(leftNamePath, ((*strPath, *)rightNamePath)) =>
                (* search global CTX *)
                case U.lookupVarInBasis(basis, rightNamePath) of
                  SOME idState => (* bind in local CTX *)
                   (*
                    Changed by Ohori, Dec 6, 2006.
                    TC.bindVarInContext(localContext, name, idState)
                    *)
                  TC.bindVarInContext
                      (TY.toplevelDepth, localContext, leftNamePath, idState)
                | NONE =>
                  raise
                    Control.BugWithLoc
                        ("unbound constructor : "
                         ^ ((*U.pathNameToString (strPath, *)NameMap.namePathToString rightNamePath ),
                         loc)
          val exnBindContext =
              foldl bindExn TC.emptyContext exnBinds
          val newBasis =
              {
                global = #global basis,
                current = U.unionContexts [#current basis, exnBindContext]
              }
          (*val newExnBindContext = U.unionContexts [context, exnBindContext]*)
          val (formatterBindContext, formatterDeclarations) =
              FG.generateFormatterForExnBinds
                  newBasis(*newExnBindContext*) path positionCTX loc exnBinds
          val newContext =
              U.unionContexts [exnBindContext, formatterBindContext]
          val printCodes =
              if PC.isPrintBinds positionCTX
              then [PG.generatePrintCodeForExnBinds basis path loc exnBinds]
              else []
        in
          (newContext, [declaration] @ printCodes @ formatterDeclarations)
        end
      | TP.TPTYPE (binds, loc) =>
        let
          fun bindTyFun (TY.TYFUN tyFun, newContext) =
              TC.bindTyConInContext
                  (newContext, (#name tyFun, #strpath tyFun), TY.TYFUN tyFun)
            | bindTyFun _ =
              raise 
                Control.Bug
                    "non TYFUN to bindTyFun \
                    \(printergeneration/main/PrinterGenerator.sml)" 
          val tyBindContext = foldr bindTyFun TC.emptyContext binds
          val newBasis =
              {
                global = #global basis,
                current = U.unionContexts [#current basis, tyBindContext]
              }
          (*val newTyBindContext = U.unionContexts [context, tyBindContext]*)

          val formatterBindContext = TC.emptyContext
          val formatterDeclarations =
              map
                  (FG.generateFormatterForTyFun newBasis path loc)
                  binds

          val newContext =
              U.unionContexts [formatterBindContext, tyBindContext]
          val printCodes =
              if PC.isPrintBinds positionCTX
              then [PG.generatePrintCodeForTypes basis path loc binds]
              else []
        in
          (newContext, [declaration] @ printCodes @ formatterDeclarations)
        end
      | TP.TPINFIXDEC(n, names, loc) =>
        if PC.isPrintBinds positionCTX
        then
          let
            val printCode =
                PG.generatePrintCodeForInfix
                    basis path loc (Fixity.INFIX n, names)
          in (TC.emptyContext, [printCode]) end
        else (TC.emptyContext, [])
      | TP.TPINFIXRDEC(n, names, loc) =>
        if PC.isPrintBinds positionCTX
        then
          let
            val printCode =
                PG.generatePrintCodeForInfix
                    basis path loc (Fixity.INFIXR n, names)
          in (TC.emptyContext, [printCode]) end
        else (TC.emptyContext, [])
      | TP.TPNONFIXDEC(names, loc) =>
        if PC.isPrintBinds positionCTX
        then
          let
            val printCode =
                PG.generatePrintCodeForInfix
                    basis path loc (Fixity.NONFIX, names)
          in (TC.emptyContext, [printCode]) end
        else (TC.emptyContext, [])
      | TP.TPREPLICATETYPE ((leftNamePath, tyBindInfo), rightNamePath, loc) =>
        (* Liu: 
         * This term is only generated by module compiler when the latter
         * compiles "open" declaration and structure replications. Thus no 
         * need to generate print code here.
         *)
        let
          val tyBindContext = 
              TC.bindTyConInEmptyContext (leftNamePath, tyBindInfo)
          (* val newTyBindContext = U.unionContexts [context, tyBindContext] *)
          val formatterBindContext = TC.emptyContext
          val formatterDeclaration =
              let
                  val leftVarInfo as {namePath, ty} = 
                      formatterVarInfoOfTyBindInfo tyBindInfo
                  val rightVarInfo =
                      {
                        namePath = U.formatterNameOfTyNamePath rightNamePath,
                        ty = ty
                      }
              in
                TP.TPVAL
                    (
                      [(TY.VALIDVAR leftVarInfo, TP.TPVAR(rightVarInfo, loc))],
                      loc
                    )
              end
          val newContext =
              U.unionContexts [formatterBindContext, tyBindContext]
        in
          (newContext,
           [declaration] @ 
           [formatterDeclaration])
        end

  and visitStrDecs basis path positionCTX declarations =
      visitSequential visitStrDec basis path positionCTX declarations

  and visitStrDec (basis:U.basis) path positionCTX declaration =
      case declaration of
        TP.TPCOREDEC (decs, loc) =>
        let
          val (newContext, newDecs) = visitDecs basis path positionCTX decs
        in
          (newContext, [TP.TPCOREDEC(newDecs, loc)])
        end
      | TP.TPCONSTRAINT (decs, basicNameNPEnv, loc) =>
        let
          val (newContext, newDecs) = 
              visitStrDecs basis path (PC.enterStructure positionCTX) decs
          val newBasicNameNPEnv = 
              insertFormatterIntoNamePathEnv basicNameNPEnv
        in
          (newContext, [TP.TPCONSTRAINT (newDecs, newBasicNameNPEnv, loc)])
        end
      | TP.TPFUNCTORAPP
            {
              prefix = prefix,
              funBindInfo = funBindInfo, 
              argNameMapInfo = {argNamePath, env}, 
              exnTagResolutionTable, 
              refreshedExceptionTagTable,
              typeResolutionTable,
              loc
            } =>
        let
          val newEnv1:Types.Env = 
              #2((#body(#functorSig funBindInfo)))
          val newEnv2 = TypeInferenceUtils.addPrefixEnv(newEnv1, prefix)
          val newContext = TC.injectEnvToContext newEnv2
          val newEnv3 = insertFormatterIntoNamePathEnv env
        in
          (
            newContext, 
            [
              TP.TPFUNCTORAPP
                  {
                    prefix = prefix,
                    funBindInfo = funBindInfo,
                    argNameMapInfo =
                    {argNamePath = argNamePath, env = newEnv3},
                    exnTagResolutionTable = exnTagResolutionTable, 
                    refreshedExceptionTagTable = refreshedExceptionTagTable,
                    typeResolutionTable = typeResolutionTable,
                    loc = loc
                  }
            ]
          )
        end 
      | TP.TPANDFLATTENED(decUnits, loc) =>
        let
          val (newContext, newDecUnits) =
              foldl
                  (fn ((printSigInfo, decUnit), (newContext, newDecUnits)) =>
                      let
                        val (context1, newDecUnit) =
                            visitStrDecs
                                basis
                                path
                                (PC.enterStructure positionCTX)
                                decUnit
                        val printCodes = 
                            if PC.isPrintBinds positionCTX
                            then
                              PG.generatePrintCodeForStrDec (printSigInfo, loc)
                            else nil
                      in
                        (
                          U.unionContexts [newContext, context1],
                          newDecUnits
                          @ [(printSigInfo , newDecUnit @ printCodes)]
                        )
                      end)
                  (TC.emptyContext, nil)
                  decUnits
        in
          (newContext, [TP.TPANDFLATTENED(newDecUnits, loc)])
        end
      | TP.TPSTRLOCAL(localDeclarations, globalDeclarations, loc) =>
        let
          val (localContext, newLocalDeclarations) = 
              visitStrDecs
                  basis path (PC.enterLocal positionCTX) localDeclarations
          val newBasis = 
              {
                global = #global basis,
                current = U.unionContexts [#current basis, localContext]
              }
          val (newContext, newGlobalDeclarations) =
              visitStrDecs newBasis path positionCTX globalDeclarations
          val newDeclaration =
              [TP.TPSTRLOCAL(newLocalDeclarations, newGlobalDeclarations, loc)]
        in
          (newContext, newDeclaration)
        end
      
  fun visitSigBind
          basis
          path
          positionCTX
          (sigBindInfo as TY.SIGNATURE(_, {name, ...}), sigExp) =
      let val newContext = TC.bindSigInEmptyContext(name, sigBindInfo)
      in (newContext, [(sigBindInfo, sigExp)]) end

  fun visitFunBind
          (basis:U.basis)
          path
          positionCTX
          {
            funBindInfo = funBindInfo : TP.funBindInfo, 
            argName = argName, 
            argSpec = argSpec, 
            bodyDec = (bodyDecs, bodyNameMap, bodySigExpOpt)
          } =
      let
        val functorName = #funName funBindInfo
        val functorSig = #functorSig funBindInfo
        val innerPath = Path.appendUsrPath(path, functorName)

        (* add tycons specified in arg into the context. *)
        val argStrEnv = #argStrPrefixedEnv functorSig
        val innerArgEnv = replaceTySpecToTyConInEnv argStrEnv
        val newbasis =
            {
              global = #global basis,
              current = TC.extendContextWithEnv (#current basis, innerArgEnv)
            }
        (* insert formatters for tyCons declared in the body *)
        val (_, newBodyDecls) =
            visitStrDecs
                newbasis
                innerPath
                (PC.enterStructure positionCTX)
                bodyDecs 
(*
        val _ = print ("\nvisitFunBind: " ^ functorName ^ "\n")
        val _ = print (TypedCalcFormatter.tpmstrexpToString [] newStrExp)
        val _ = print ("\n")
*)

        val newArgStrEnv = insertFormatterIntoEnv argStrEnv
        val newArgSigEnv = insertFormatterIntoEnv (#argSigEnv (functorSig))
        val newFunctorSig = 
            {
              generativeExnTagSet = #generativeExnTagSet functorSig,
              argTyConIdSet = #argTyConIdSet functorSig,
              argStrPrefixedEnv = newArgStrEnv, 
              argSigEnv = newArgSigEnv,
              body = #body functorSig
            }
        val newFunBindInfo =
            {
              funName = #funName funBindInfo,
              argName = #argName funBindInfo,
              functorSig = newFunctorSig
            } : TY.funBindInfo
                
        val newContext = TC.bindFunInEmptyContext(functorName, funBindInfo)
      in
        (
          newContext, 
          [
            {
              funBindInfo = newFunBindInfo, 
              argName = argName, 
              argSpec = argSpec, 
              bodyDec = (newBodyDecls, bodyNameMap, bodySigExpOpt)
            }
          ]
        )
      end

  fun visitTopDec basis path positionCTX (TP.TPDECSTR (tpDecls, loc)) =
      let
        val (newContext, newTpDecls) =
            visitStrDecs basis path positionCTX tpDecls
      in
        (newContext, [TP.TPDECSTR(newTpDecls, loc)]) 
      end
    | visitTopDec basis path positionCTX (TP.TPDECSIG (sigDecls, loc)) =
      let
        val printCode =
            if PC.isPrintBinds positionCTX
            then
              let
                val printExp =
                    PG.generatePrintCodeForSigDecls basis path loc sigDecls
                val printDec =
                    TP.TPVAL([(TY.VALIDWILD PT.unitty, printExp)], loc)
              in
                  [TP.TPDECSTR([TP.TPCOREDEC([printDec], loc)], loc)]
              end
            else []
        val (newContext, _) = 
            visitSequential visitSigBind basis path positionCTX sigDecls
      in
        (newContext, [TP.TPDECSIG (sigDecls, loc)] @ printCode)
      end
    | visitTopDec basis path positionCTX (TP.TPDECFUN (funDecls, loc)) =
      let
        val printCode =
            if PC.isPrintBinds positionCTX
            then
              let
                val printExp =
                    PG.generatePrintCodeForFunDecls basis path loc funDecls
                val printDec =
                    TP.TPVAL([(TY.VALIDWILD PT.unitty, printExp)], loc)
              in
                [TP.TPDECSTR([TP.TPCOREDEC([printDec], loc)], loc)]
              end
            else []
        val (newContext, newFunDecls) = 
            visitSequential visitFunBind basis path positionCTX funDecls
      in
        (newContext, [TP.TPDECFUN (newFunDecls, loc)] @ printCode)
      end
(*
    | visitTopDec basis path positionCTX (TP.TPDECIMPORT(spec, env, loc)) =
      let
        val printCode =
            if PC.isPrintBinds positionCTX
            then
              let
                val printExp =
                    PG.generatePrintCodeForImport basis path loc spec
                val printDec =
                    TP.TPVAL([(TY.VALIDWILD PT.unitty, printExp)], loc)
              in
                  [TP.TPDECSTR([TP.TPCOREDEC([printDec], loc)], loc)]
              end
            else []
        val newEnv = (* insertFormatterIntoEnv env *)
                     env
        (* ToDo : *)
        val newContext = TC.emptyContext
      in
          (newContext, [TP.TPDECIMPORT (spec, newEnv, loc)] @ printCode)
      end
*)

  fun visitTopDecs basis path positionCTX declarations =
      visitSequential visitTopDec basis path positionCTX declarations

  fun generate
          {
            context =  topContext : InitialTypeContext.topTypeContext,
            newContext : TypeContext.context,
            flattenedNamePathEnv,
            printBinds,
            declarations
          } =
      let
        val _ = TY.kindedTyvarList := nil

        (*
         * The PrinterGenerator builds a context from declarations, as the
         * TypeInferencer does.
         * This is necessary to judge the visibility of type constructors.
         * But this new context is not used as the return value.
         *)
        val basis = {global = topContext, current = TC.emptyContext}
        val positionCTX = PC.create printBinds
        val (_, newDeclarations) =
            visitTopDecs basis P.NilPath positionCTX declarations
        val _ = TypeInferenceUtils.eliminateVacuousTyvars()
        val nweFlattendNamePathEnv = 
            insertFormatterIntoNamePathEnv flattenedNamePathEnv
      in
        (* return newContext which is passed as the argument without change. *)
          (newContext, nweFlattendNamePathEnv, newDeclarations)
      end
      handle exn => raise exn
end
end
