(* -*- sml -*- *)
(**
 * Assembly code.
 * @copyright (c) 2007, Tohoku University.
 * @author UENO Katsuhiro
 * @version $Id: AssemblyCode.ppg,v 1.1 2007/11/19 06:00:02 katsu Exp $
 *)
structure AssemblyCode =
struct

  local
    val term = SMLFormat.BasicFormatters.format_string
    fun format_asInt x = term (Word32.fmt (StringCvt.DEC) x)

    fun formatSEnv (formatter,prefix,sep,suffix) map =
        SEnv.foldli
            (fn (k,v,z) =>
                z @ prefix @ term k @ sep @ formatter v @ suffix)
            nil map
  in

  (*% @formatter(Word32.word) SmlppgUtil.format_word32 *)
  type offset =
       (*% @format(x) "0x" x *)
       Word32.word            (* offset in an section *)

  (*%
   * @formatter(asInt) format_asInt
   *)
  type 'target section =
      (*%
       * @format({code, alignment})
       * "alignment=" alignment:asInt
       * +1 "code:" 2[ +1 code ]
       *)
      {
        code: 'target,
        alignment: offset
      }

  (*%
   * @formatter(SEnv.map) formatSEnv
   * @formatter(asInt) format_asInt
   *)
  type nobitsSection =
      (*%
       * @format({size, symbols: sym syms, alignment})
       * "size=" size:asInt "," + "align=" alignment:asInt
       * +1 "symbols:" 2[ syms(sym)(1, + ":" +,) ]
       *)
      {
        size: offset,
        symbols: offset SEnv.map,
        alignment: offset
      }

  (*%
   * @formatter(SEnv.map) formatSEnv
   * @formatter(choice) SmlppgUtil.formatBinaryChoice
   *)
  type labelBinding =
      (*%
       * @format(bind labels)
       * labels(bind:choice()("GLOBAL","LOCAL"))(1, + ":" +,)
       *)
      (* true = GLOBAL, false = LOCAL, not found = don't export *)
      bool SEnv.map

  (*% *)
  type 'target program =
      (*%
       * @format({exportLabels,
       *          init: it init,
       *          text: tt text,
       *          data: dt data,
       *          bss, bbss})
       * "exportLabels:" 2[ exportLabels ]
       * +1 "init:" 2[ +1 init(it) ]
       * +1 "text:" 2[ +1 text(tt) ]
       * +1 "data:" 2[ +1 data(dt) ]
       * +1 "bss:" 2[ +1 bss ]
       * +1 "bbss:" 2[ +1 bbss ]
       *)
      {
        exportLabels: labelBinding,
        init: 'target section,
        text: 'target section,
        data: 'target section,
        bss: nobitsSection,
        bbss: nobitsSection
      }

  (* assembler output *)

  (*% *)
  datatype relocationKind =
      UNDEF             (* by undefined symbol in this object file *)
    | LOCAL             (* by symbol in this object file *)

  (*% @formatter(ObjectFile.relocationType)
   *  ObjectFile.format_relocationType *)
  datatype relocationType = datatype ObjectFile.relocationType

  (*% *)
  type relocation =
      (*%
       * @format({offset, symbolName, relocType, relocKind})
       * offset ":" + symbolName "," + relocKind "," + relocType
       *)
      {
        offset: offset,
        symbolName: string,
        relocType: relocationType,
        relocKind: relocationKind
      }

  (*%
   * @formatter(hexdump) Hexdump.hexdump
   * @formatter(SEnv.map) formatSEnv
   * @formatter(asInt) format_asInt
   *)
  type assembledSection =
      (*%
       * @format({content,
       *          symbols: sym syms,
       *          relocation: rel rels,
       *          alignment,
       *          locs})
       * "alignment=" alignment
       * +1 "content:" 2[ +1 content:hexdump ]
       * +1 "symbols:" 2[ syms(sym)(1, + ":" +,) ]
       * +1 "relocation:" 2[ +1 rels(rel)(+1) ]
       *)
      {
        content: Word8Array.array,
        symbols: offset SEnv.map,
        relocation: relocation list,
        alignment: offset,
        locs: (int * string) list
      }

  end

end
