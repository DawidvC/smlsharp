(** -*- sml -*-
 * @copyright (c) 2008, Tohoku University.
 * @author UENO Katsuhiro
 * @version $Id: EffectCalc.ppg,v 1.4 2008/05/08 09:06:03 katsu Exp $
 *)
structure EffectCalc =
struct

  local
    fun formatRecord (elementFormatter, bindsep, itemsepRecord) smap =
        let
          val L = SEnv.listItemsi smap
        in
          SmlppgUtil.format_record(elementFormatter, bindsep, itemsepRecord) L
        end

    fun formatMap foldli formatKey (formatter,prefix,sep,suffix) map =
        foldli (fn (k,v,z) =>
                   z @ prefix @ formatKey k @ sep @ formatter v @ suffix)
               nil map
               
    fun formatNPEnv x y =
        formatMap NameMap.NPEnv.foldli NameMap.format_namePath x y

  in

  (*% @formatter(NameMap.namePath) NameMap.format_namePath *)
  type varId =
       NameMap.namePath

  (*% *)
  datatype idstate =
      CONID
    | VARID

 (*
  * formatter precedence:
  * L8 { x y }      application
  * L7 { x # y }    modify
  * N3 { }          let
  * R2 { x | y }    parallel, union
  * R1 { x => y }   abstraction
  *
  * Precedence 0 is reserved for cut.
  * Use +1 for separating declarations.
  * Be careful of usage of guard so that the above +1 works fine.
  *)



  (*%
   * @formatter(formatRecord) formatRecord
   * @formatter(listWithEnclosureOne) SmlppgUtil.formatListWithEnclosureOne
   * @formatter(NameMap.NPEnv.map) formatNPEnv
   *)
  datatype ecvalue =
      (*%
       * @format(env * arg args:listWithEnclosureOne * bodyExp)
       * "Cls(" !N0{ env "," +1
       *  "fn"
       *  +d args(arg)("," +2, "{", "}")
       *  +d "=>"
       *  2[ +1 bodyExp ]
       * } ")"
       *)
      CLOSURE of effectVarEnv * varId list * ecexp
    | (*% @format(label) "#" label *)
      SELECTOR of string    (* selector function; lambda x. #f x *)
    | (*% @format(n) "_BOTTOMFUN("n")" *)
      BOTTOMFUN of int      (* bottom function; lambda x1...xn. BOTTOM *)
    | (*% @format(n) "_ATOMFUN("n")" *)
      ATOMFUN of int        (* atom function; lambda x1...xn. ATOM *)
    | (*% @format "_IDENTFUN" *)
      IDENTFUN              (* identity function; labmda x. x *)
    | (*% @format "_REFFUN" *)
      REFFUN                (* ref cell creation; lambda x. ref x *)
    | (*% @format "_ASSIGNFUN" *)
      ASSIGNFUN             (* := *)
    | (*% @format "_BOTTOM" *)
      BOTTOM
    | (*% @format "_ATOM" *)
      ATOM                  (* atomic value *)
    | (*%
       * @format(elem smap:formatRecord)
       * smap(elem)("=", "," +1)
       *)
      RECORD of ecvalue SEnv.map
    | (*%
       * @format(v1 * v2)
       * R2{ v1 +1 "|" +d v2 }
       *)
      UNION of ecvalue * ecvalue  (* union *)
    | (*% @format "_RAISE" *)
      RAISE                 (* dummy value returned by raise *)
    | (*% @format "_WRONG" *)
      WRONG                 (* wrong *)

  and ecexp =
      (*% @format(v) v *)
      ECVALUE of ecvalue
    | (*% @format(v) v *)
      ECVAR of varId
    | (*%
       * @format(arg args:listWithEnclosureOne * bodyExp)
       * R1{
       *  "fn"
       *  +d args(arg)("," +2, "{", "}")
       *  +d "=>"
       *  2[ +1 bodyExp ]
       * }
       *)
      ECFN of varId list * ecexp
    | (*%
       * @format(funExp * arg args:listWithEnclosureOne)
       * L8{ funExp 2[ +1 args(arg)("," +2, "{", "}") ] }
       *)
      ECAPP of ecexp * ecexp list
    | (*%
       * @format(dec decs * mainExp)
       * N3{ !N0{
       *   "let"
       *   2[ +1 decs(dec)(+1) ]
       *   +1 "in"
       *   2[ +1 mainExp ]
       *   +1 "end"
       * } }
       *)
      ECLET of ecdecl list * ecexp
    | (*%
       * @format(exp1 * exp2)
       * R2{ exp1 +1 "||" +d exp2 }
       *)
      ECPARALLEL of ecexp * ecexp
    | (*%
       * @format(field fields)
       * !N0{ "{" 2[ 1 fields(field)("," +1) ] "}" }
       * @format:field(label * exp) { label +d "=" 2[ +1 exp ] }
       *)
      ECRECORD of (string * ecexp) list
    | (*%
       * @format(label * exp)
       * L8{ "#" label 2[ +1 exp ] }
       *)
      ECSELECT of string * ecexp
    | (*%
       * @format(exp * field fields)
       * L7{ exp +1 "#" +d !N0{ "{" 2[ 1 fields(field)("," +1) ] "}" } }
       * @format:field(label * exp) { label +d "=" 2[ +1 exp ] }
       *)
      ECMODIFY of ecexp * (string * ecexp) list
    | (*%
       * @format(exp)
       * L8{ "!" 1[ exp ] }
       *)
      ECDEREF of ecexp

  and ecdecl =
      (*%
       * @format(var * exp)
       * !N0{ "val" +d { var +d "=" } 2[ +1 exp ] }
       *)
      ECVAL of varId * ecexp
    | (*%
       * @format(dec1 decs1 * dec2 decs2)
       * !N0{
       *   "local"
       *   2[ +1 decs1(dec1)(+1) ]
       *   +1 "in"
       *   2[ +1 decs2(dec2)(+1) ]
       *   +1 "end"
       * }
       *)
      ECLOCAL of ecdecl list * ecdecl list
    | (*%
       * @format(decs anddecs)
       * !N0{
       *   "bind"
       *   anddecs(decs)(+1 "and")
       *   +1 "end"
       * }
       *
       * @format:decs(dec ds) 2[ +1 ds(dec)(+1) ]
       *)
      ECANDVAL of ecdecl list list
    | (*%
       * @format(exp)
       * !N0{ "val" +d { "_" +d "=" } 2[ +1 exp ] }
       *)
      ECIGNORE of ecexp       (* evaluate ecexp and ignore the result *)
    | (*% @format "_EFFECT" *)
      ECEFFECT                (* raise effect forcely *)

  withtype effectVarEnv =
      (*%
       * @format(state map)
       * !N0{
       *   "{"
       *   2[ map(state)(+1 ,+ "=" +,",") ]
       *   +1 "}"
       * }
       * @format:state(idstate * value)
       * "(" !N0{ idstate "," +1 value } ")"
       *)
      (idstate * ecvalue) NameMap.NPEnv.map

  end

end
