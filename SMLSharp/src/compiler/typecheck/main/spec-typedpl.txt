Copyright (c) 2006, Tohoku University.

+---------------------------------------+
|A Typechecker Specification for TypedPL|
+---------------------------------------+


===================
Typing environments
===================

(environement)
env : tyckenv

  where
    tyckenv = {tcenv:tcenv,   genv:varenv,
               btvenv:btvenv, varenv:varenv }

    tcenv  ::= {..., con |-> tybindinfo, ... }
    genv   ::= {..., id  |-> idstate, ... }
    btvenv ::= {..., i   |-> btvkind, ... }
    varenv ::= {..., id  |-> idstate, ... }

    con = string
    id  = string
    i   = int

    tybindinfo ::= TYCON tycon 
                 | TYFUN {tyargs:btvenv,body:ty}

    tycon = { name : string, 
              arity : int, 
              id : int, 
              eqkind : eqkind ref, 
              datacon : varEnv ref}

    idstate ::= VARID varinfo    
              | CONID coninfo    
              | PRIM  priminfo

    varinfo ={name : string, ty : ty}
    priminfo={name : string, ty : ty}
    coninfo ={name : string, ty : ty, 
              funtycon : bool, exntag : int, 
              tycon : tycon}

    btvkind ={reckind : reckind, eqkind : eqkind, 
              rank : bool, index : int}

    eqkind = NONEQ | EQ

    reckind = UNIV | REC {..., labeli |-> tyi, ...}

    label = string

(environment extension)

env @ varenv   (implemented by extendVarEnv env varenv)
env @ btvenv   (implemented by extendBtvEnv env btvenv)
env @ tcenv    (implemented by extendTcEnv env tcenv)


=============
Kinding rules
=============

* env |- ty : (eqkind,reckind)

N. (IMPL.) (eqkind,reckind)= calcEqRecKind env ty


(tyvarty-tvar)

tvkind={id=_,reckind=reckind,
        eqkind=eqkind,tyvarname=_}
-----------------------------------------------------
env |- TYVARty (ref (TVAR tvkind)) : (eqkind,reckind)

N. We do not check well-formedness of types. 

(tyvar-subst)

env |- ty : (eqkind,reckind)
-------------------------------------------------------- 
env |- TYVARty (ref (SUBSTITUTED ty)) : (eqkind,reckind)

(boundvarty)

env = {btvenv=btvenv,...}
btvenv (i) = {reckind=reckind,eqkind=eqkind,rank=_,index=_}
----------------------------------------------------------- 
env |- BOUNDVARty i : (EQ,reckind)

(boundvarty)

env |- ty1 : (eqkind1,reckind1)
env |- ty2 : (eqkind2,reckind2)
-------------------------------------
env |- FUNty (ty1,ty2) : {NONEQ,UNIV}

(iabsty)

env |- tylist : [...,(eqkindi,reckindi),...]
env |- ty : (eqkind,reckind)
--------------------------------------------
env |- IABSty (tylist,ty) : (NONEQ,UNIV)

(recordty)

btvenv |- tyi : (eqki,recki)
eqk = EQ    if for all i. eqk_i=EQ
    = NONEQ otherwise
rek = REC{...,li|->tyi,...}
------------------------------------------------
env |- RECORDty {..., li|->tyi, ...} : (eqk,rek)

(conty)

tycon={arity=arity,eqkind=eqkind,...}
arity = #tylist
env |- tylist : [...,(eqkind_i,reckind_i),...]
eqk = eqkind if all i. eqkind_i=EQ
      NONEQ  otherwise
---------------------------------------------------
env |- CONty {tycon=tycon,args=tylist} : (eqk,UNIV)

(polyty)

env @ btvenv |- ty : (eqkind,reckind)
----------------------------------------------------------
env |- POLYty {boundtvars=btvenv, body=ty} : (NONEQ,UNIV)

(dummyty)

-----------------------------
env |- DUMMYty : (NONEQ,UNIV)

(boxedty)

-----------------------------
env |- BOXEDty : (NONEQ,UNIV)

(atomty)

----------------------------
env |- ATOMty : (NONEQ,UNIV)

(indexty)

env |- ty : {eqkind=eqkind,reckind=REC fieldtys}
(label|->ty') is included in fieldtys
env |- ty' : (eqkind',reckind')
------------------------------------------------
env |- INDEXty (ty,label): (eqkind',reckind')

(bmsabsty)

env |- tylist : tykindlist
env |- ty : tykind
----------------------------------------
env |- BMABSty (tylist,ty): (NONEQ,UNIV)

(bitmapty)

true                          if bittyi=DC
env |- tyi : (eqkind,reckind) if bittyi=TRACE tyi
-------------------------------------------------
env |- BITMAPty [..., bittyi,... ] : (NONEQ,UNIV)


================
Well-formed type
================

* env |- ty    
* env |- tys  

N. (IMPL.)  _ = checkType env ty
N. (IMPL.)  _ = checkTypes env tys


(types-[])

---------
env |- []

(types-::)

env |- ty
env |- tys
--------------
env |- ty::tys

(tyvarty-substituted)

env |- ty
-------------------------------------
env |- TYVARty (ref (SUBSTITUTED ty)) 

(tyvarty-tvar)

tvkind={id=id,reckind=reckind,
        eqkind=eqkind, tyvarname=stringopt}
true                 if reckind=UNIV
forall i. env |- tyi if reckind=REC {...,li|->tyi ...}
------------------------------------------------------
env |- TYVARty (ref (TVAR tvkind)) 

N. It is not clear why we do need this rule.

(boundvarty)

env = {btvenv=btvenv,...}
btvenv (i) = {reckind=reckind,
              eqkind=eqkind,rank=bool,index=int}
true                 if reckind=UNIV
forall i. env |- tyi if reckind=REC {...,li|->tyi ...}
------------------------------------------------------
env |- BOUNDVARTY i

(funty)

env |- ty1
env |- ty2
----------------------
env |- FUNty (ty1,ty2)

(iabsty)

env |- ty1
env |- ty2
----------------------
env |- IABSty (tys,ty2)

(recordty)

env |- tyi
----------------------------------
env |- RECORDty {...,li|->tyi,...}

N. Unique labels.

(conty)

env |- tys
-----------------------------------
env |- CONty {tycon=tycon,args=tys}

Q. We leave tycon unchecked. Do we need to maintain a list of
   "varEnv ref"-typed values? We can check well-formedness of
    tycon by looking for "#datacon tycon" in the list if we
    have such a list.

(polyty)

env @ btvenv |- ty
-----------------------------------------
env |- POLYty {boundtvars=btvenv,body=ty}

(dummyty)

--------------
env |- DUMMYty

(boxedty)

--------------
env |- BOXEDty

(atomty)

--------------
env |- ATOMty

(indexty)

env |- ty
-------------------------
env |- INDEXty (ty,label)

(bmabsty)

env |- ty
env |- tys
-----------------------
env |- BMABSty (tys,ty)

(bitmapty)

true      if bittyi=DC
env |- ty if bittyi=TRACE ty
----------------------------------
env |- BITMAPty [..., bittyi, ...]


=============
Instantiation
=============

* env |- INST (ty,tylist) = ty'

(inst-poly)

env |- POLYty (btvenv,ty)
env |- tylist
tylist=[ty1,      ..., tyn]
btvenv=[1|->btv1, ..., n|->btvn]
env |- tyi : (eqkindi,reckindi)
for all i. #eqkind  btvi <= eqkindi 
           #reckind btvi <= reckindi
----------------------------------------
env |- INST (POLYty (btvenv,ty), tylist) 
    =  ty [ty1/btv1,...,tyn/btvn]

N. ty [tylist/btvenv] is implemented by 
   "TypesUtils.substBTvar subst ty" where
   "subst" is [ty1/btv1,...,tyn/btvn].

(inst-mono)

env |- ty
ty <> POLYty (_,_)
------------------------- 
env |- INST (ty, []) = ty

===============
Kind Inequality
===============

(eqkind)

EQ    <= EQ
EQ    <= NONEQ
NONEQ <= EQ
NONEQ <= NONEQ

N. (IMPL.) leqEqKind eqkind1 eqkind2

(reckind)

UNIV <= UNIV
UNIV <= REC fieldtys

fieldtys1={l1|->ty1,...,ln|->tyn}
fieldtys2={l1|->ty1,...,ln|->tyn,ln+1|->tyn+1,...}
--------------------------------------------------
REC fieldtys1 <= REC fieldtys2

N. (IMPL.) leqRecKind reckind1 reckind2

============
Typing rules
============

@(CONST) 
* env |- const : ty


------------------------- (int)  
env |- INTCONST i : intty

-------------------------- (string) 
env |- STRING s : stringty

---------------------- (real)
env |- REAL f : realty




@(EXPR) 
* env |- exp : ty

(constant)

env |- c : ty
---------------------- 
env |- CONSTANT c : ty

(var)

env = {varenv=varenv, ...}
varenv (id) = VARID {name=id, ty=ty}
------------------------------------
env |- VAR {name=id, ty=ty} : ty

N. The implementation didn't check the equality of ids. 

(global)

env = {genv=genv, ...}
genv (id) = VARID {name=id, ty=ty}
----------------------------------- 
env |- GLOBAL {name=id, ty=ty} : ty

(primapply)

env |- polyty
env |- tylist
env |- INST (polyty, tylist) = ty
env |- expopt : ty ==> ty'
---------------------------------------------------------- 
env |- PRIMAPPLY ({name=id,ty=polyty},tylist,expopt) : ty'

N. expopt ::= NONE | SOME exp

(construct)

env |- polyty
env |- tylist
env |- INST (polyty, tylist) = ty
env |- expopt : ty ==> ty'
env={tcenv=tcenv,...}

coninfo={name=id,funtycon=funtycon,ty=polyty,
         exntag=exntag,tycon=tycon}
tycon  ={name=tyname,arity=arity,id=id,
         eqkind=eqkind_ref,datacon=datacon_ref}
tcenv (tyname) = TYCON tycon
datacon_ref (id) = CONID coninfo

# of bound type vars (polyty) = arity
funtycon=true  if expopt=SOME exp
        =false if expopt=NONE
------------------------------------------------
env |- TPCONSTRUCT (coninfo,tylist,expopt) : ty'

N. This rule compares tycon with tcenv(tyname) implicitly.
N. This rule compares tycon with datacon_ref (id) implicitly.

Q. #tylist is not necessarily the same as #(boundtvars polyty)?
   The typechecker assumes either #(boundtvars polyty)=#tylist or 
   #tylist=0. That is, no polymorphic type is partially applied.

(app)

env |- ty1->ty2
env |- exp1 : ty1->ty2
env |- exp2 : ty1
--------------------------------------- 
env |- TPAPP (exp1,ty1->ty2,exp2) : ty2

(monolet)

env |- valbindlist : varenv
env @ varenv |- exp : ty 
--------------------------------------- 
env |- TPMONOLET (valbindlist,exp) : ty

(let)

env |- tylist
env |- decl : (tcenv, varenv)
env @ tcenv @ varenv |- explist : tylist
------------------------------------------------ 
env |- TPLET (decl,explist,tylist) : last tylist

N. explist ::= [] | exp :: explist.

(record)

env |- ty
env |- fields : ty
ty = RECORDTy (_)
-------------------------------- 
env |- TPRECORD (fields,ty) : ty

(select)

env |- exp : ty
env |- ty : REC { label |-> ty' }
-------------------------------------- 
env |- TPSELECT (label, exp, ty) : ty'

N. env |- ty is implied by env |- ty : REC {label|->ty'}. Right?
N. ty is either a record type or a type variable that has a record kind.

(raise)

env |- exp : exn
---------------------------- 
env |- TPRAISE (exp,ty) : ty

N. The type of TPRAISE exp is arbitrary, but it must be determined
   in a predictable way for the implementation of typechecker. 
   The functions checkExp, and etc have an extra parameter TY, which
   we will decide to assign the raise expression.

(handle)

env |- exp : ty
varenv = {id|->VARID {name=id,ty=exnty}}
env @ varenv |- exp' : ty
-------------------------------------------------- 
env |- TPHANDLE (exp,{name=id,ty=exnty},exp') : ty

N. exnty=CONty {tycon=exnTycon args=nil}

(case)

env |- ty
env |- ty'
env |- exp : tye
env |- patexplist : ty ==> ty'
----------------------------------------------------
env |- TPCASE (exp,ty,patexplist,ty',casekind) : ty'

Q. casekind = BIND | MATCH | HANDLE
   What do we do with casekind in this rule?

(fn)

env |- ty'
varenv = {id|->VARID{name=id,ty=ty}}
env @ varenv |- exp : ty'
-----------------------------------------------------
env |- TPFN ({name=id,ty=ty},ty',exp) : ty'

(polyfn)

env @ btvenv |- ty
varenv = {id |-> VARID {name=id,ty=ty}}
env @ btvenv @ varenv |- exp : ty'
polyty = POLYty{boundtvars=btvenv,body=FUNty(ty,ty')}
--------------------------------------------------------- 
env |- TPPOLYFN (btvenv,{name=id,ty=ty},ty',exp) : polyty 

N. "btvenv" has the same type as "btvenv'" so that we can merge them.

(poly)

env @ btvenv |- ty
env @ btvenv |- exp : ty
polyty = POLYty {boundtvars=btvenv,body=ty'}
-------------------------------------------- 
env |- TPPOLY (btvenv,ty,exp) : polyty

(tapp)

env |- ty
env |- tylist
env |- exp : ty
env |- INST (ty, tylist) = ty'
----------------------------------- 
env |- TPTAPP (exp,ty,tylist) : ty'

(seq)

env |- expi : tyi
-------------------------------------------------- 
env |- TPSEQ ([exp1,...,expn],[ty1,...,tyn]) : tyn




@(PATTERN) 
* env |- pat : ty, varenv

(patwild)

btvenv |- ty
---------------------------- 
env |- TPPATWILD ty : ty, {}

(patvar)

env |- ty
varenv = {id|->VARID varinfo}
--------------------------------------------------
env |- TPPATVAR ({name=id,ty=ty},loc) : ty, varenv

(patconstant)

env |- c : ty
------------------------------------ 
env |- TPPATCONSTANT (c,ty) : ty, {}

(patconstruct)

env |- ty
env |- polyty
env |- tylist
env |- INST (polyty, tylist) = ty
env |- patopt : ty' ==> ty, varenv'
env = {tcenv=tcenv,...}

coninfo={name=id,funtycon=funtycon,ty=polyty,
         exntag=exntag,tycon=tycon}
tycon  ={name=tyname,arity=arity,id=id,
         eqkind=eqkind_ref,datacon=datacon_ref}
tcenv (tyname) = TYCON tycon
datacon_ref (id) = CONID coninfo

# of bound type vars (polyty) = arity
funtycon=true  if patopt=SOME exp
        =false if patopt=NONE
---------------------------------------------------------------
env |- TPPATCONSTRUCT (coninfo,tylist,patopt,ty) : ty, varenv'

(patrecord)

env |- ty
env |- patfields : fieldenv, varenv
env |- ty : REC fieldenv
----------------------------------------------- 
env |- TPPATRECORD (patfields,ty) : ty, varenv

N. fieldenv is the same type as varenv. 
N. Note that ty is either a record type or a type variable whose
   record kind is REC {...}. 
N. ty may have more fields than varenv'. There is a serious bug here.

(patlayered)

dom (varenv1) intersection dom (varenv2) = {}
env |- pat : ty, varenv1
env |- pat' : ty, varenv2
------------------------------------------------------- 
env |- TPPATLAYERED (pat,pat') : ty, varenv1 @ varenv2

N. pat=TPPATVAR (TPPATVAR (varinfo,loc),...).


(PatOption)

(pat-none)

-------------------------------------------------- 
env |- NONE : ty ==> ty, {}

(pat-some)

env |- pat : ty, varenv'
-------------------------------------------- 
env |- SOME pat : ty-> ty'  ==> ty', varenv'




@(PatFields)
* env |- patfields : fieldtys, varenv

(patfields)

dom (varenvi) intersection dom (varenvj) = {} for all pairs (i,j)
env |- pati : tyi, varenvi
--------------------------------------------------------------------
env |- {..., li=pati, ...} : {..., li:tyi, ...}, ... U varenvi U ...




@(PatExp)
* env |- pat : ty => ty'

(patexp)

env |- pat : ty, varenv
env @ varenv |- exp : ty'
------------------------------ 
env |- (pat, exp) : ty ==> ty'




@(PatExpList)
* env |- patexps : ty => ty'

(patexplist)

env |- patexpi : ty => ty'
---------------------------------------
env |- [..., patexpi, ...] : ty ==> ty'




@(ExpList)
* env |- exps : tys

(explist)

env |- expi : tyi
-----------------------------------------
env |- [..., expi, ...] : [..., tyi, ...]



@(ExpOption)
* env |- expopt : ty ==> ty'

(none)

-----------------------
env |- NONE : ty ==> ty

(some-exp)

env |- exp : ty
-----------------------------------
env |- SOME exp : ty -> ty' ==> ty'




@(Fields)
* env |- fields : fieldtys

(fields)

env |- expi : tyi
--------------------------------------------------------- 
env |- {..., idi |-> expi, ...} : {..., idi |-> tyi, ...}




@(DECL)
* env |- decl : tcenv,varenv

(val)

varinfoi={name=idi,ty=tyi}
env |- expi : tyi
---------------------------------------
env |- VAL [...,(varinfoi,expi),...] 
    : {},{...,idi|->VARID varinfoi,...}

(valrec)

varinfoi={name=idi,ty=tyi}
env |- tyi
env @ [..., (idi,VARID varinfoi), ...] |- expi : tyi
----------------------------------------------------
env |- VALREC [...,(varinfoi,tyi,expi),...] 
    : {},{...,idi|->varinfoi,...}

(valpolyrec)

varinfoi={name=idi,ty=tyi}
env @ btvenv |- tyi
env @ btvenv @ [..., (idi,VARID varinfoi), ...] |- expi : tyi
-------------------------------------------------------------
env |- VALPOLYREC (btvenv,[...,(varinfoi,tyi,expi),...]) 
    : {},{...,idi|->varinfoi,...}

(localdec)

env |- decllist1 : tcenv1, varenv1
env @ btvenv1 @ varenv1 |- decllist2 : tcenv2, varenv2
-------------------------------------------------------
env |- LOCALDEC (decllist1,decllist2) : tcenv2, varenv2

(datadec)

tycon_i = {name=tyname_i, arity=arity_i, id=id_i, 
          eqkind=eqkindref_i, datacon=dataconref_i}
env={tcenv=tcenv,...}
dataconref_i=[..., CONID coninfo_j, ...]
eqkindref_i = EQ    if for all j. polyty_j admits equality
            = NONEQ otherwise
coninfo_j = {name=id_j, ty=polyty_j, funtycon=funtycon_j, 
             exntag=exntag_j, tycon=tycon_j}

# of bound type vars (polyty_j) = arity
funtycon_j=true  if polyty_j is a (polymorphic) function type
          =false otherwise
exntag_j=???
tycon_i=tycon_j for all j.
-------------------------------------------------------------
env |- DATADEC [..., tycon_i, ...] 
    : {...,id_i|->CONID tycon_i,...}, {}

Q. How do we check the well-formedness of each tyconi?
Q. What is exntag_j in datatype declaration?
Q. There is a problem on the part of eqkindref_i.
   We may need a different interpretation on the eqkind of 
   a datatype. NONEQ means that we do not allow to use = on
   all values of this datatype, and EQ means that we allow 
   to use = on all values of this datatype. 

(datarepdec)

---------------------------------
env |- DATAREPDEC (s,s') : {}, {}

(exndec)

coninfos = [..., coninfoi, ...]
coninfoi = {name=idi,funtycon=_,ty=tyi,exntag=_,tycon=_}
varenv = {..., idi|->VARID{name=idi,ty=tyi}, ...}
--------------------------------------------------------
env |- EXNDEC coninfos : {}, varenv

Q. 

(exnrepdec)

--------------------------------
env |- EXNREPDEC (s,s') : {}, {}

(type)

env={tcenv=tcenv,...}
tysyns={...,(tvars,id),...}
tcenv (id)=TYFUN {tyargs=_,body=_}
----------------------------------
env |- TYPE tysyns : {}, {}

Q. Do we have to add something to tcenv?

@(DECLLIST)
* env |- decls : tcenv,varenv

(decllist)

env |- decl : tcenv1, varenv1
env @ tcenv1 @ varenv1 |- decllist : tcenv2, varenv2
---------------------------------------------------------- 
env |- decl::decllist : tcenv1 @ tcenv2, varenv1 @ varenv2

