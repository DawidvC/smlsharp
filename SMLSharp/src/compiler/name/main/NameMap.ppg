(**
 * Name Map
 * @copyright (c) 2006, Tohoku University.
 * @author Liu Bochao
 * @version $Id: NameMap.ppg,v 1.3 2008/08/06 02:08:01 ohori Exp $
 *)
structure NameMap =
struct
   
  (*%                
   * @formatter(format_pathdot) Path.format_pathWithDotend
   *)
  type namePath = 
     (*% 
      * @format(name * strpath)
      * strpath:format_pathdot name 
      *)
       string * Path.path 

 (*
  * Necessity of distinguishment between VARID, CONID, EXNID:
  * For the following code fragment,
  *      val foo = 1
  *      structure A = 
  *         struct
  *             val foo = foo
  *         end
  * for the declared "foo" inside structure, we need to know its idstate
  * to prefix structure name. If it is a variable as above, then it is 
  * compiled into 
  *      val foo = 1
  *      val A.foo = foo
  * if it is a data constructor as below,
  *      datatype t = foo
  *      structure A = 
  *         struct
  *             val foo = foo
  *         end
  * then it is compiled into
  *      datatype t = foo
  *      val foo = foo 
  *)


 local
     fun formatpath p = 
         case p of
             Path.NilPath => [SMLFormat.FormatExpression.Term(0, "")]
           | _ => Path.format_pathWithDotend p
 in
     (*%
      * @params(bindsep,itemsep)
      * @formatter(Path.path)  formatpath
      *)
     type 'a namepathenv =
          (*%
           * @format(field fields)
           *           !N0{ fields(field)(itemsep)}
           * @format:field(label * ty) {label} +d bindsep +d {ty}
           * @format:label(name * path) path name
           *)
          ((string * Path.path) * 'a) list
          
     (*%
      * @params(bindsep, itemsep, prefixIfNotNull, suffixIfNotNull)
      * @formatter(listWithEncousure)  SmlppgUtil.formatListWithEnclosure
      * @formatter(Path.path)  formatpath
      *)
     type 'a namepathenvWithEnclosure =
          (*%
           * @format(field fields:listWithEncousure)
           *           fields(field)(itemsep, prefixIfNotNull, suffixIfNotNull)
           * @format:field(label * ty) label +d bindsep +d ty
           * @format:label(name * path) path name
           *)
          ((string * Path.path) * 'a) list
 end

 (*%
  * @formatter(namePath) format_namePath
  *)
  datatype idstate = 
            (*%
             * @format(name) "VARID(" name ")"
             *)
            VARID of namePath
          | (*%
             * @format(name) "CONID(" name ")"
             *)
            CONID of namePath
          | (*%
             * @format(name) "EXNID(" name ")"
             *)
            EXNID of namePath

   (*%
    * @formatter(smap) SmlppgUtil.formatSmap
    *)
   type varNameMap =
        (*%
         * @format(varItem smap:smap)
         * "{" 2[ +1 smap(varItem)(":", "," +1) ] +1 "}"
         *)
        idstate SEnv.map

        
   (*%
    *)
   datatype tyState = 
            (*%
             * @format(name * varNameMap) 
             *   "dataty:" name
             *)
            DATATY of namePath * varNameMap
          | (*%
             * @format(name) 
             *   "funty:" name
             *)
            NONDATATY of namePath

   (*%
    * @formatter(smap) SmlppgUtil.formatSmap
    *)
   type tyNameMap =
        (*%
         * @format(tyState smap:smap)
         * "{" 2[ +1 smap(tyState)(":", "," +1) ] +1 "}"
         *)
        tyState SEnv.map

   (*%
    * @formatter(smap) SmlppgUtil.formatSmap
    *)
   datatype strNameMapEntry = 
     (*%
      * @format({name, wrapperSysStructure, parentPath, basicNameMap})
      * basicNameMap
      * @format:basicNameMap(tyNameMap * varNameMap * strNameMapEntry smap:smap)
      * "{" 2[ +1 "varNameMap = " varNameMap ","
      *	       +1 "tyNameMap = " tyNameMap ","
      *	       +1 "strNameMap = "
      *           "{" 2[ +1 smap(strNameMapEntry)(":", "," +1) ] +1 "}"
      *      ] +1 "}"
      *)
     NAMEAUX of 
      {name :string,
       wrapperSysStructure : string option,
       parentPath : Path.path,
       basicNameMap:tyNameMap * varNameMap * (strNameMapEntry SEnv.map)}
                       
   (*%
    * @formatter(smap) SmlppgUtil.formatSmap
    *)
   type strNameMap =
        (*%
         * @format(strNameMap smap:smap)
         * "{" 2[ +1 smap(strNameMap)(":", "," +1) ] +1 "}"
         *)
        strNameMapEntry SEnv.map

   (*%
    * @formatter(smap) SmlppgUtil.formatSmap
    *)
   type sigNameMap = 
        (*%
         * @format(strNameMap smap:smap)
         * "{" 2[ +1 smap(strNameMap)(":", "," +1) ] +1 "}"
         *)
        strNameMapEntry SEnv.map
        
    (*% 
     * @formatter(varNameMap) format_varNameMap
     * @formatter(tyNameMap) format_tyNameMap
     * @formatter(strNameMap) format_strNameMap
     *)
   type basicNameMap = 
        (*%
         * @format(tyNameMap * varNameMap * strNameMap)
         * "{" 2[ +1 "varNameMap = " varNameMap ","
         *        +1 "tyNameMap = " tyNameMap ","
         *        +1 "strNameMap = " strNameMap ","
         *      ] +1 "}"
         *)
        tyNameMap * varNameMap * strNameMap

   (*%
    * @formatter(strNameMap) format_strNameMap
    * @formatter(smap) SmlppgUtil.formatSmap
    *)
   type funNameMap = 
        (*%
         * @format(strNameMap smap:smap)         
         * "{" 2[ +1 smap(strNameMap)(":", "," +1) ] +1 "}"
         * @format:strNameMap({arg, body})
         * body
         *)
        {arg : basicNameMap, body : strNameMapEntry}  SEnv.map


   (*% 
    *)
   type basicInterfaceNameMap = 
        (*%
         * @format(basicNameMap * funNameMap)
         * basicNameMap +d
         * "funNameMap : " +d funNameMap
         *)
        basicNameMap * funNameMap

    (*% 
     * @formatter(funNameMap) format_funNameMap
     * @formatter(varNameMap) format_varNameMap
     * @formatter(sigNameMap) format_sigNameMap
     * @formatter(tyNameMap) format_tyNameMap
     * @formatter(strNameMap) format_strNameMap
     *)
   type topNameMap = 
        (*%
         * @format({funNameMap, varNameMap, tyNameMap, strNameMap, sigNameMap})
         * "{" 2[ +1 "varNameMap = " varNameMap ","
         *        +1 "tyNameMap = " tyNameMap ","
         *        +1 "strNameMap = " strNameMap ","
         *        +1 "sigNameMap = " sigNameMap ","
         *        +1 "funNameMap = " funNameMap ","
         *      ] +1 "}"
         *)
        {
         varNameMap : varNameMap, 
         tyNameMap : tyNameMap, 
         funNameMap : funNameMap, 
         sigNameMap : sigNameMap, 
         strNameMap :strNameMap}
        
    (*% 
     * @formatter(funNameMap) format_funNameMap
     * @formatter(varNameMap) format_varNameMap
     * @formatter(sigNameMap) format_sigNameMap
     * @formatter(tyNameMap) format_tyNameMap
     * @formatter(strNameMap) format_strNameMap
     *)
   type currentNameMap = 
        (*%
         * @format({funNameMap, varNameMap, tyNameMap, strNameMap, sigNameMap})
         * "funNameMap:" +1 2[funNameMap] + "\n"
         * "tyNameMap:" +1 2[tyNameMap] + "\n"
         * "varNameMap:" +1 2[varNameMap] + "\n"
         * "strNameMap:" +1 2[strNameMap] + "\n"
         * "sigNameMap:" +1 2[sigNameMap] + "\n"
         *)
        {funNameMap : funNameMap,
         varNameMap : varNameMap, 
         tyNameMap : tyNameMap, 
         strNameMap : strNameMap, 
         sigNameMap : sigNameMap}



   val emptyBasicNameMap = (SEnv.empty, SEnv.empty, SEnv.empty) : basicNameMap
   val emptyBasicInterfaceNameMap = 
     (emptyBasicNameMap, SEnv.empty) : basicInterfaceNameMap

   type nameContext = 
        {
         topNameMap : topNameMap, 
         currentNameMap : currentNameMap, 
         strLevel : Path.path
        }
        
   (*************************************************************)
   (* default values *)
   val emptyTopNameMap : topNameMap = 
       {
        varNameMap = SEnv.empty,
        tyNameMap = SEnv.empty,
        funNameMap = SEnv.empty, 
        strNameMap = SEnv.empty, 
        sigNameMap = SEnv.empty}
       
   val emptyCurrentNameMap : currentNameMap = 
       let
           val eM = SEnv.empty
       in
           {funNameMap = eM,
            varNameMap = eM,
            tyNameMap = eM,
            strNameMap = eM,
            sigNameMap = eM}
       end
   val emptyNameContext : nameContext = 
       {
        topNameMap = emptyTopNameMap, 
        currentNameMap = emptyCurrentNameMap,
        strLevel = Path.NilPath
        }

   (************* auxiliary functions ******************)
   fun lookupVar (nameContext : nameContext, longNames) = 
     case lookupVarInCurrentNameMap (#currentNameMap nameContext, longNames) of
       (_, NONE) => lookupVarInTopNameMap (#topNameMap nameContext, longNames) 
     | (strpath, SOME x) => (strpath, SOME x)
                     
   and lookupVarInTopNameMap (topNameMap : topNameMap, longNames) =
       lookupVarInBasicNameMap ((#tyNameMap topNameMap,
                                 #varNameMap topNameMap,
                                 #strNameMap topNameMap), 
                                longNames)
           
   and lookupVarInCurrentNameMap  (currentNameMap:currentNameMap, longNames) =
       lookupVarInBasicNameMap ((#tyNameMap currentNameMap,
                                 #varNameMap currentNameMap, 
                                 #strNameMap currentNameMap),
                                longNames)

   and lookupVarInBasicNameMap (basicNameMap, longNames) =
     let
       fun lookup ((tyNameMap, varNameMap, strNameMap), longNames, strPath) =
         case longNames of
           nil => raise Control.Bug "Variables cannot be nil"
         | [varName] => (strPath, SEnv.find (varNameMap, varName))
         | strName :: tailNames => 
             (case SEnv.find(strNameMap, strName) of
                NONE => (strPath, NONE)
              | SOME (NAMEAUX {basicNameMap, name, ...}) => 
                  lookup (
                          basicNameMap, 
                          tailNames, 
                          Path.appendUsrPath(strPath, strName)
                          )
             )

       in
           lookup (basicNameMap, longNames, Path.NilPath)
       end

   (*****************************************)
   fun lookupTy (nameContext : nameContext, longNames) = 
     case lookupTyInCurrentNameMap (#currentNameMap nameContext, longNames) of
       (_, NONE) => lookupTyInTopNameMap (#topNameMap nameContext, longNames) 
     | (strpath, SOME x) => (strpath, SOME x)

   and lookupTyInTopNameMap (topNameMap : topNameMap, longNames) =
       lookupTyInBasicNameMap ((#tyNameMap topNameMap,
                                #varNameMap topNameMap,
                                #strNameMap topNameMap),
                               longNames)
           
   and lookupTyInCurrentNameMap  (currentNameMap:currentNameMap, longNames) =
       lookupTyInBasicNameMap ((#tyNameMap currentNameMap,
                                #varNameMap currentNameMap, 
                                #strNameMap currentNameMap),
                               longNames)

   and lookupTyInBasicNameMap (basicNameMap, longNames) =
     let
       fun lookup ((tyNameMap, varNameMap, strNameMap), longNames, strPath) =
         case longNames of
           nil => raise Control.Bug "Type name cannot be nil"
         | [tyName] => (strPath, SEnv.find (tyNameMap, tyName))
         | strName :: tailNames => 
             (case SEnv.find(strNameMap, strName) of
                NONE => (strPath, NONE)
              | SOME (NAMEAUX {basicNameMap, name,  ...}) => 
                  lookup (basicNameMap, 
                          tailNames, 
                          Path.appendUsrPath(strPath, 
                                             strName)
                          )
             )
       in
           lookup (basicNameMap, longNames, Path.NilPath)
       end


   (**********************************************)
   fun joinPathWithWrapper path wrapperPathOpt =
       case wrapperPathOpt of
           NONE => path
         | SOME string => Path.appendSysPath(path, string)

   fun lookupStr (nameContext : nameContext, longNames) = 
     case lookupStrInCurrentNameMap (#currentNameMap nameContext, longNames) of
       (_, NONE) => lookupStrInTopNameMap (#topNameMap nameContext, longNames) 
     | (strPath, SOME x) => (strPath, SOME x)

   and lookupStrInTopNameMap (topNameMap : topNameMap, longNames) =
       lookupStrInBasicNameMap ((#tyNameMap topNameMap,
                                 #varNameMap topNameMap,
                                 #strNameMap topNameMap), 
                                longNames)
           
   and lookupStrInCurrentNameMap  (currentNameMap:currentNameMap, longNames) =
       lookupStrInBasicNameMap ((#tyNameMap currentNameMap,
                                 #varNameMap currentNameMap, 
                                 #strNameMap currentNameMap),
                                longNames)

   and lookupStrInBasicNameMap (basicNameMap, longNames) =
     let
       fun lookup ((tyNameMap, varNameMap, strNameMap), longNames, strPath) =
         case longNames of
           nil => raise Control.Bug "Structure name cannot be nil"
         | [strName] => (strPath, SEnv.find (strNameMap, strName))
         | strName :: tailNames => 
             (case SEnv.find(strNameMap, strName) of
                NONE => (strPath, NONE)
              | SOME (NAMEAUX {basicNameMap, name, wrapperSysStructure, ...}) => 
                  lookup (basicNameMap, 
                          tailNames, 
                          Path.appendUsrPath
                          (joinPathWithWrapper strPath wrapperSysStructure,
                           name)
                          )
             )
       in
           lookup (basicNameMap, longNames, Path.NilPath)
       end

   (**********************************************)
   fun lookupSig (nameContext : nameContext, sigName) = 
       case lookupSigInCurrentNameMap (#currentNameMap nameContext, sigName) of
           NONE => lookupSigInTopNameMap (#topNameMap nameContext, sigName) 
         | SOME x => SOME x

   and lookupSigInTopNameMap (topNameMap : topNameMap, sigName) =
       case SEnv.find(#sigNameMap topNameMap, sigName) of
           NONE => NONE
         | SOME (NAMEAUX basicNameMap) => SOME basicNameMap
           
   and lookupSigInCurrentNameMap  (currentNameMap : currentNameMap, sigName) =
       case SEnv.find(#sigNameMap currentNameMap, sigName) of
           NONE => NONE
         | SOME (NAMEAUX basicNameMap) => SOME basicNameMap

   (**********************************************)
   fun lookupFunctor (nameContext : nameContext, funName) = 
     case lookupFunctorInCurrentNameMap (#currentNameMap nameContext, funName) of
       NONE => lookupFunctorInTopNameMap (#topNameMap nameContext, funName) 
     | SOME x => SOME x

   and lookupFunctorInTopNameMap (topNameMap : topNameMap, funName) =
       SEnv.find(#funNameMap topNameMap, funName) 
           
   and lookupFunctorInCurrentNameMap (currentNameMap : currentNameMap, funName) =
       SEnv.find(#funNameMap currentNameMap, funName) 

   (*********************************)
   fun injectVarNameMapInNameMap varNameMap =
       {funNameMap = SEnv.empty,
        varNameMap = varNameMap,
        tyNameMap = SEnv.empty,
        strNameMap = SEnv.empty,
        sigNameMap = SEnv.empty} : currentNameMap
       
   fun injectFunNameMapInNameMap funNameMap =
       {funNameMap = funNameMap,
        varNameMap = SEnv.empty,
        tyNameMap = SEnv.empty,
        strNameMap = SEnv.empty,
        sigNameMap = SEnv.empty} : currentNameMap

   fun injectTyNameMapInNameMap tyNameMap =
       {funNameMap = SEnv.empty,
        varNameMap = SEnv.empty,
        tyNameMap = tyNameMap,
        strNameMap = SEnv.empty,
        sigNameMap = SEnv.empty
        } : currentNameMap

   fun injectStrNameMapInNameMap strNameMap =
       {funNameMap = SEnv.empty,
        varNameMap = SEnv.empty,
        tyNameMap = SEnv.empty,
        strNameMap = strNameMap,
        sigNameMap = SEnv.empty
        } : currentNameMap

   fun injectSigNameMapInNameMap sigNameMap =
       {funNameMap = SEnv.empty,
        varNameMap = SEnv.empty,
        tyNameMap = SEnv.empty,
        strNameMap = SEnv.empty,
        sigNameMap = sigNameMap} : currentNameMap

   fun injectBasicNameMapInNameMap (tyNameMap, varNameMap, strNameMap) =
       {
        funNameMap = SEnv.empty,
        varNameMap = varNameMap,
        tyNameMap = tyNameMap,
        strNameMap = strNameMap,
        sigNameMap = SEnv.empty} : currentNameMap

   (*************************************************)

   fun mergeVarNameMap {old, new} =
       SEnv.unionWith #1 (new, old)

   fun mergeTyNameMap {old, new} =
       SEnv.unionWith #1 (new, old)

   fun mergeSigNameMap {old, new} =
       SEnv.unionWith #1 (new, old)

   fun mergeBasicNameMap {old = old : basicNameMap , new = new : basicNameMap} =
       (SEnv.unionWith #1 (#1 new, #1 old),
        SEnv.unionWith #1 (#2 new, #2 old),
        SEnv.unionWith #1 (#3 new, #3 old))

   fun mergeBasicInterfaceNameMap {old = old : basicInterfaceNameMap , new = new : basicInterfaceNameMap} =
       (
        (
         SEnv.unionWith #1 (#1 (#1 new), #1 (#1 old)),
         SEnv.unionWith #1 (#2 (#1 new), #2 (#1 old)),
         SEnv.unionWith #1 (#3 (#1 new), #3 (#1 old))
        ),
        SEnv.unionWith #1 (#2 new, #2 old)
       )

   fun mergeCurrentNameMap 
     {old = old : currentNameMap , new = new : currentNameMap} 
     =
       {
        funNameMap = SEnv.unionWith #1 (#funNameMap new, #funNameMap old),
        varNameMap = SEnv.unionWith #1 (#varNameMap new, #varNameMap old),
        tyNameMap = SEnv.unionWith #1 (#tyNameMap new, #tyNameMap old),
        strNameMap = SEnv.unionWith #1 (#strNameMap new, #strNameMap old),
        sigNameMap = SEnv.unionWith #1 (#sigNameMap new, #sigNameMap old)
        }:currentNameMap

   fun extendNameContextWithCurrentNameMap
     {nameContext = nCt:nameContext, nameMap = nM : currentNameMap} =
       {
        topNameMap = #topNameMap nCt,
        currentNameMap = mergeCurrentNameMap {old = #currentNameMap nCt,
                                              new = nM},
        strLevel = #strLevel nCt
        }:nameContext

   fun extendNameContextWithSigNameMap 
     {nameContext = nCt : nameContext, sigNameMap = sNM} 
     =
       {
        topNameMap = #topNameMap nCt,
        currentNameMap = 
        mergeCurrentNameMap {old = #currentNameMap nCt,
                             new = injectSigNameMapInNameMap sNM},
        strLevel = #strLevel nCt
        }:nameContext


   (***********************************************)
   datatype strKind = SYS | USR
                            
   fun appendStrLevel  (strLevel, (strName, kind)) =
       case kind of
           SYS => Path.appendSysPath (strLevel, strName) 
         | USR => Path.appendUsrPath (strLevel, strName) 

   fun updateStrLevel (nameContext : nameContext, strLevel) = 
       {
        topNameMap = #topNameMap nameContext,
        currentNameMap = #currentNameMap nameContext,
        strLevel = strLevel
        }

   (***********************************************)
   fun getNamePathFromIdstate idstate =
       case idstate of
           VARID x => x
         | CONID x => x
         | EXNID x => x

   fun getNamePathFromTyState tystate =
       case tystate of
           DATATY (x, _) => x
         | NONDATATY x => x

   fun extractBasicNameMapFromNameMap (nameMap : currentNameMap) =
       (#tyNameMap nameMap, #varNameMap nameMap, #strNameMap nameMap)

   fun namePathToString (name, strpath) = 
       case strpath of
           Path.NilPath => name
         | _ => Path.pathToString(strpath)^"."^name

   fun namePathToList (name, path) = Path.pathToList(path) @ [name]

   fun namePathToUsrNamePath (namePath : namePath) =
       (#1 namePath, Path.pathToUsrPath (#2 namePath))

   fun usrNamePathToString namePath = 
       namePathToString (namePathToUsrNamePath namePath)

   fun getTailNamePath (namePath : namePath) = 
       (#1 namePath, Path.getTailPath (#2 namePath))
       
   fun constructNamePath (nameContext : nameContext) name = 
       (name, (#strLevel nameContext))

   fun prefixNamePath (namePath:namePath, path) =
       (#1 namePath, Path.joinPath (path, #2 namePath))

   (***************************************************************************)
     
   fun injectPathToExternPath path =
       Path.PSysStructure(Path.externStrName, Path.pathToUsrPath path)
       
   fun injectNamePathToExternNamePath (name, path) =
       (name, injectPathToExternPath path)
       
   fun injectVarNameMapToExternVarNameMap (varNameMap : varNameMap) = 
     SEnv.map 
     (fn idstate =>
      case idstate of
        VARID namePath => VARID (injectNamePathToExternNamePath namePath)
      | CONID namePath => CONID (injectNamePathToExternNamePath namePath)
      | EXNID namePath => EXNID (injectNamePathToExternNamePath namePath))
     varNameMap

   fun injectTyNameMapToExternTyNameMap (tyNameMap : tyNameMap) =
       SEnv.map (fn tyState =>
                    case tyState of
                        DATATY (namePath, varNameMap) =>
                        DATATY (injectNamePathToExternNamePath namePath, 
                                injectVarNameMapToExternVarNameMap varNameMap)
                      | NONDATATY namePath => 
                        NONDATATY (injectNamePathToExternNamePath namePath))
                tyNameMap

   fun injectStrNameMapToExternStrNameMap (strNameMap : strNameMap) =
     SEnv.map 
     (fn NAMEAUX {name, wrapperSysStructure, parentPath, basicNameMap} =>
      NAMEAUX 
        {
         name = name, 
         wrapperSysStructure = NONE, 
         parentPath = 
           injectPathToExternPath (Path.pathToUsrPath parentPath) , 
         basicNameMap = (injectTyNameMapToExternTyNameMap (#1 basicNameMap),
                         injectVarNameMapToExternVarNameMap (#2 basicNameMap),
                         injectStrNameMapToExternStrNameMap (#3 basicNameMap))
        }
     )
     strNameMap

   fun injectFunctorTyNameMap tyNameMap = 
       SEnv.map (fn tyState =>
                    case tyState of
                        DATATY (namePath, varNameMap) =>
                        DATATY (namePathToUsrNamePath namePath, 
                                injectFunctorVarNameMap varNameMap)
                      | NONDATATY namePath => 
                        NONDATATY (namePathToUsrNamePath namePath))
                tyNameMap

   and injectFunctorVarNameMap varNameMap = 
       SEnv.map (fn idstate =>
                    case idstate of
                        VARID namePath => VARID (namePathToUsrNamePath namePath)
                      | CONID namePath => CONID (namePathToUsrNamePath namePath)
                      | EXNID namePath => EXNID (namePathToUsrNamePath namePath)
                )
                varNameMap

   and injectFunctorStrNameMap strNameMap = 
     SEnv.map 
     (fn NAMEAUX {name, wrapperSysStructure, parentPath, basicNameMap} =>
      NAMEAUX {name = name, 
               wrapperSysStructure = NONE, 
               parentPath = Path.pathToUsrPath (Path.pathToUsrPath parentPath) , 
               basicNameMap = injectFunctorBasicNameMap basicNameMap
               }
      )
     strNameMap

   and injectFunctorBasicNameMap (tyNameMap, varNameMap, strNameMap) =
       (injectFunctorTyNameMap tyNameMap, 
        injectFunctorVarNameMap varNameMap,
        injectFunctorStrNameMap strNameMap)
       
   fun injectFunctorStrNameMapEntry 
           (NAMEAUX {name, wrapperSysStructure, parentPath, basicNameMap}) =
       NAMEAUX {name = name, 
                wrapperSysStructure = NONE, 
                parentPath = Path.pathToUsrPath parentPath, 
                basicNameMap = injectFunctorBasicNameMap basicNameMap
               }
       
   fun injectFunNameMapToExternNameMap funNameMap = 
       SEnv.map (fn {arg, body} =>
                    {arg = arg,
                     body = injectFunctorStrNameMapEntry body
                    })
                funNameMap
                
   fun injectCurrentNameMapToExternNameMap (currentNameMap : currentNameMap) = 
     {funNameMap = 
        injectFunNameMapToExternNameMap (#funNameMap currentNameMap),
      varNameMap = 
        injectVarNameMapToExternVarNameMap (#varNameMap currentNameMap),
      tyNameMap = 
        injectTyNameMapToExternTyNameMap (#tyNameMap currentNameMap),
      strNameMap = 
        injectStrNameMapToExternStrNameMap (#strNameMap currentNameMap),
      sigNameMap = #sigNameMap currentNameMap}

   fun extendTopNameMapWithCurrentNameMap
     {topNameMap:topNameMap, currentNameMap:currentNameMap} 
     =
     let
       val externNameMap = injectCurrentNameMapToExternNameMap currentNameMap
     in
       {varNameMap = 
          SEnv.unionWith #1 (#varNameMap externNameMap, #varNameMap topNameMap), 
        tyNameMap = 
          SEnv.unionWith #1 (#tyNameMap externNameMap, #tyNameMap topNameMap), 
        funNameMap = 
          SEnv.unionWith #1 (#funNameMap externNameMap, #funNameMap topNameMap), 
        sigNameMap = 
          SEnv.unionWith #1 (#sigNameMap externNameMap, #sigNameMap topNameMap), 
        strNameMap = 
          SEnv.unionWith #1 (#strNameMap externNameMap, #strNameMap topNameMap)}
     end
   (***************************************************************************)

   (***************************************************************************)
   local 
     open Path 
     fun pathToInt path =
       case path of
         NilPath => 0 
       | PSysStructure _ => 1
       | PUsrStructure _ => 3
   in
     fun comparePathByName (path1, path2) =
       case Int.compare(pathToInt path1, pathToInt path2) of
         EQUAL => 
           (case (path1, path2) of
              (NilPath, NilPath) => EQUAL
              | (PSysStructure (name1, tail1),
                 PSysStructure (name2, tail2)) =>
                (case String.compare(name1, name2) of
                   EQUAL => comparePathByName (tail1, tail2)
                 | other => other)
                 | (PUsrStructure (name1, tail1),
                    PUsrStructure (name2, tail2)) =>
                   (case String.compare(name1,name2) of
                      EQUAL => comparePathByName (tail1, tail2)
                    | other => other)
                 | _ => raise 
                        Control.Bug 
                        "non equivalent path in comparePathByName"
                      )
       | other => other
   end

   local 
     structure NamePathOrd = 
       struct 
             type ord_key = namePath
             fun compare ((name1, path1), (name2, path2)) = 
                 case comparePathByName (path1, path2) of
                     EQUAL => String.compare(name1,name2)
                   | other => other
       end
   in
      structure NPEnv = BinaryMapMaker(NamePathOrd)
      structure NPSet = BinarySetFn(NamePathOrd)

      fun formatNPmap (elementFormatter,bindsep,itemsep) npmap =
        format_namepathenv
        (elementFormatter,bindsep,itemsep) 
        (NPEnv.listItemsi npmap)

      fun formatNPmapWithEnclosure
        (
         elementFormatter,
         bindsep,
         itemsep,
         prefixIfNotNull,
         suffixIfNotNull
         )
        npmap
        =
        format_namepathenvWithEnclosure
        (elementFormatter, bindsep, itemsep, prefixIfNotNull, suffixIfNotNull)
        (NPEnv.listItemsi npmap)

      fun NPEnvToSEnv NPEnv =
        NPEnv.foldli 
          (fn (namePath, item, SEnv) =>
             SEnv.insert(SEnv, 
                         namePathToString (namePathToUsrNamePath namePath), 
                         item))
          SEnv.empty
          NPEnv
      fun SEnvToNPEnv SEnv =   
          SEnv.foldli (fn (name, item, NPEnv) =>
                          NPEnv.insert(NPEnv, (name, Path.NilPath), item))
                      NPEnv.empty
                      SEnv
   end (* end local *)
   (***************************************************************************)
   (*%                
    * @formatter(npmap) formatNPmap
    *)
   type tyNameNPEnv = 
        (*%
         * @format(tyState npmap:npmap) 
                  npmap(tyState)(":", +1)	
         *)
        tyState NPEnv.map

   (*%                
    * @formatter(npmap) formatNPmap
    *)
   type varNameNPEnv = 
        (*%
         * @format(idstate npmap:npmap) 
                  npmap(idstate)(":", +1)	
         *)
        idstate NPEnv.map

    (*% 
     * @formatter(varNameNPEnv) format_varNameNPEnv
     * @formatter(tyNameNPEnv) format_tyNameNPEnv
     *)
   type basicNameNPEnv = 
        (*%
         * @format(tyNameNPEnv * varNameNPEnv)
         * "tyNameNPEnv:" +1 2[tyNameNPEnv] +1 
         * "varNameNPEnv:" +1 2[varNameNPEnv]
         *)
        tyNameNPEnv * varNameNPEnv

   val emptyBasisNameNPEnv = (NPEnv.empty, NPEnv.empty) : basicNameNPEnv

   type functorInfo =
       {funName : string, 
        argName : string, 
        argNamePathEnv : basicNameNPEnv, 
        bodyNamePathEnv : basicNameNPEnv,
        bodyNameMap : basicNameMap }


   fun mergeNamePathEnvs nps =
       foldl (fn (namePathEnv, newNamePathEnv) =>
                 NPEnv.unionWith #1 (namePathEnv, newNamePathEnv))
             NPEnv.empty
             nps

   fun basicNameMapToFlattenedNamePathEnv (basicNameMap:basicNameMap) =
       basicNameMapToFlattenedNamePathEnvImpl Path.NilPath basicNameMap

   and basicNameMapToFlattenedNamePathEnvImpl 
           prefix (tyNameMap, varNameMap, strNameMap) =
       let
           val varNamePathEnv1 = 
               varNameMapToFlattenedVarNamePathEnv Path.NilPath varNameMap
           val tyNamePathEnv1 = 
               tyNameMapToFlattenedTyNamePathEnv Path.NilPath tyNameMap
           val (tyNamePathEnv2, varNamePathEnv2) =
               strNameMapToFlattenedNamePathEnv prefix strNameMap
       in
           (mergeNamePathEnvs [tyNamePathEnv2, tyNamePathEnv1],
            mergeNamePathEnvs [varNamePathEnv2, varNamePathEnv1])
       end

   and varNameMapToFlattenedVarNamePathEnv prefix varNameMap =
       SEnv.foldli (fn (varName, entry, newVarNamePathEnv) =>
                       NPEnv.insert(newVarNamePathEnv,
                                    (varName, prefix),
                                    entry))
                   NPEnv.empty
                   varNameMap
                   
   and tyNameMapToFlattenedTyNamePathEnv prefix tyNameMap =
       SEnv.foldli (fn (tyName, entry, newTyNamePathEnv) =>
                       NPEnv.insert(newTyNamePathEnv,
                                   (tyName, prefix),
                                   entry))
                   NPEnv.empty
                   tyNameMap
                   
   and strNameMapToFlattenedNamePathEnv prefix strNameMap =
     SEnv.foldli 
     (fn (strName, 
          NAMEAUX {basicNameMap, ...}, 
          (tyNamePathEnv, varNamePathEnv)) =>
      let
        val newPrefix = 
          Path.joinPath 
          (prefix, Path.PUsrStructure(strName, Path.NilPath))
        val subTyNamePathEnv1 = 
          tyNameMapToFlattenedTyNamePathEnv newPrefix (#1 basicNameMap)
        val subVarNamePathEnv1 =
          varNameMapToFlattenedVarNamePathEnv newPrefix (#2 basicNameMap)
        val (subTyNamePathEnv2, subVarNamePathEnv2) =
          strNameMapToFlattenedNamePathEnv newPrefix (#3 basicNameMap)
      in
        (mergeNamePathEnvs 
            [tyNamePathEnv, subTyNamePathEnv1, subTyNamePathEnv2],
         mergeNamePathEnvs 
            [varNamePathEnv, subVarNamePathEnv1, subVarNamePathEnv2])
      end)
     (NPEnv.empty, NPEnv.empty)
     strNameMap

end
