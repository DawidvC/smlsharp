(* a grammar for the raw symtax of IML.
 * @copyright (c) 2006, Tohoku University.
 * @author Liu Bochao
 * @version $Id: interface.grm,v 1.9 2008/03/11 08:53:55 katsu Exp $

 * Ohori: 2007/11/11
 * WARNING: This file and also interface.lex needs refactoring.
 * Large part of this file is copied from iml.grm.
 * I indicates those positons that are from iml.grm.
 * iml.grm is the original. If one change something there, he/she 
 * must propagate the change here. 
 * This is unsatisfactory situation. We will consider a better
 * organization later.
*)
%%
%eop EOF 

(* %pos declares the type of positions for terminals.
   Each symbol has an associated left and right position. *)

%pos Loc.pos

(* Ohori:
   We must examine the set of keyword for interface langauge.
   The following definition is rather sloppy. 
   Some keyword in iml.grm are here and some aren't.
   Moreover, some of those listed here are not used such
   as ANDALSO, AT, CHAR etc.
*)
%term EOF
    | ABSNAMESPACE
    | AND
    | ANDALSO 
    | ARROW
    | AS
    | ASTERISK
    | AT
    | ATOM
    | BAR
    | BOXED
    | CHAR of string
    | COLON
    | COMMA
    | DARROW
    | DATATYPE
    | DOUBLE
    | END
    | EQ
    | EQTYPE
    | EQTYVAR of string 
    | EXCEPTION
    | FUNCTOR
    | HASH
    | ID of string
    | IMPORT
    | INCLUDE
    | IN
    | INT of BigInt.int
    | LBRACE
    | LBRACKET
    | LPAREN
    | NONFIX
    | OF 
    | OP 
    | NAMESPACE 
    | PERIOD
    | PERIODS
    | REC
    | REQUIRE
    | RBRACE
    | RBRACKET
    | REAL of string
    | RPAREN
    | SHARING
    | SIG
    | SPECIAL of string
    | STRING of string
    | STRUCT
    | STRUCTURE
    | THEN 
    | TYPE
    | TYVAR of string 
    | UNDERBAR
    | VAL
    | WHERE
    | WORD of Word32.word

(* Ohori: done a preliminary refactoring of the following.
  (1) removed some redundant type defs.
  (2) 
*)
(*
  Ohori: from absnamespace to valdesc are copy of
  iml.grm
*)
%nonterm absnamespace of string list
       | atomicspec of Absyn.spec
       | condesc of (string * Absyn.ty option) list
       | datdesc of
         (Absyn.tvar list * string * (string * Absyn.ty option) list) list
       | exdesc of (string * Absyn.ty option) list
       | id of string
       | label of string
       | longid of Absyn.longid
       | longtycon of Absyn.longTyCon
       | longtyconeqrow of Absyn.longTyCon list
       | longideqrow of Absyn.longid list
       | spec of Absyn.spec
       | strdesc of (string * Absyn.sigexp) list
       | fundesc of (string * Absyn.sigexp * Absyn.sigexp) list
       | sigexpbasic of Absyn.sigexp
       | sigexpwhere of Absyn.sigexp
       | sigexp of Absyn.sigexp
       | sigexpand of Absyn.sigexp
       | ty of Absyn.ty
       | ty0 of Absyn.ty
       | tyid of string list
       | ty1 of Absyn.ty
       | tycon of string
       | tyseq_comma of Absyn.ty list
       | tyseq of Absyn.ty list
       | tyrow of (string * Absyn.ty) list
       | tytuple of Absyn.ty list
       | tyvar of Absyn.tvar
       | tyvarseq of Absyn.tvar list
       | tyvarseq_comma of Absyn.tvar list
(*
  Ohori: poly_ty, poly_ty1, poly_tyrow, poly_tytuple are added
  for rank1 type specification.
  2007/11/11
*)
       | poly_ty of Absyn.ty
       | poly_ty1 of Absyn.ty
       | poly_tyrow of (string * Absyn.ty) list
       | poly_tytuple of Absyn.ty list
(*
  Ohori: from kinded_tyvar to kinded_tyvarseq_comma are added
  for kinded type specification.
  2007/11/11
*)
       | kinded_tyvar of Absyn.tvar * Absyn.tvarKind
       | kinded_tyvarseq_without_paren of (Absyn.tvar * Absyn.tvarKind) list

       | namespace of Absyn.namespace
       | typbind of (Absyn.tvar list * string * Absyn.ty) list
       | typdesc of (Absyn.tvar list * string) list
       | valdesc of (string * Absyn.ty) list

(* 
  the following is new to interface.grm
*)
       | interface of Absyn.interfaceparseresult 
       | start of Absyn.interfaceparseresult 

%name Interface

%right ARROW
%right AND
%right DARROW 
%left ANDALSO
%right AS
%left COLON
%noshift EOF
%verbose
%start start
%%

(* 
  Except for interface and star, 
  all the definitions are cpopied form iml.grm
*)
(*
  2008.2.6 newly added by liu: The followings are only in interface.grm
  1. kind specification for abstract types.
  2. abstract namespaces declaration.                                                       
*)
start : interface (interface)


id    : ID (ID)
      | EQ ("=")
      | ASTERISK ("*")

typbind : tycon EQ ty ([(nil,tycon,ty)])
        | tyvarseq tycon EQ ty ([(tyvarseq,tycon,ty)])
        | tycon EQ ty AND typbind ((nil,tycon,ty)::typbind)
        | tyvarseq tycon EQ ty AND typbind ((tyvarseq,tycon,ty)::typbind)

tyvar : TYVAR ({name=TYVAR,eq=Absyn.NONEQ})
      | EQTYVAR ({name=EQTYVAR,eq=Absyn.EQ})

tyvarseq : tyvar ([tyvar])
         | LPAREN tyvar RPAREN ([tyvar])
         | LPAREN tyvarseq_comma RPAREN (tyvarseq_comma)

tyvarseq_comma : tyvar COMMA tyvar ([tyvar1,tyvar2])
            | tyvar COMMA tyvarseq_comma (tyvar::tyvarseq_comma)

(*
   Ohori: kinded tyvar added 2007/11/11 ohori
*)
kinded_tyvar : tyvar ((tyvar, Absyn.UNIV))
             | TYVAR HASH LBRACE tyrow RBRACE (({name=TYVAR,eq=Absyn.NONEQ},Absyn.REC(tyrow)))
             | EQTYVAR HASH LBRACE tyrow RBRACE (({name=EQTYVAR,eq=Absyn.EQ}, Absyn.REC(tyrow)))

kinded_tyvarseq_without_paren : kinded_tyvar ([kinded_tyvar])
                | kinded_tyvar COMMA kinded_tyvarseq_without_paren (kinded_tyvar::kinded_tyvarseq_without_paren)
(* kinded tyvar end *)


tycon : id (id)

tyrow : label COLON ty ([(label,ty)])
      | label COLON ty COMMA tyrow ((label,ty)::tyrow)

ty0 : tyvar (Absyn.TYID(tyvar,(tyvarleft,tyvarright)))
    | LBRACE tyrow RBRACE (Absyn.TYRECORD(tyrow,(LBRACEleft,RBRACEright)))
    | LBRACE RBRACE (Absyn.TYRECORD([],(LBRACEleft,RBRACEright)))
    | LPAREN ty RPAREN (ty)

(* check the following *)
tyseq : ty1 ([ty1]) 
      | LPAREN tyseq_comma RPAREN (tyseq_comma)
      | (nil)

tyseq_comma : ty COMMA ty ([ty1,ty2])
            | ty COMMA tyseq_comma (ty::tyseq_comma)

tyid : ID ([ID])
     | ID PERIOD longid (ID :: longid)

ty1 : ty0 (ty0)
    | tyseq tyid (Absyn.TYCONSTRUCT(tyseq,tyid,(tyseqleft,tyidright)))

tytuple : ty1 ASTERISK tytuple (ty1::tytuple)
        | ty1 ASTERISK ty1 ([ty11,ty12])

ty : ty ARROW ty (Absyn.TYFUN(ty1,ty2,(ty1left,ty2right)))
   | tytuple (Absyn.TYTUPLE(tytuple,(tytupleleft,tytupleright)))
   | ty1 (ty1)

(*
 Ohori; poly_ty and the related definitions are added for rank1 type
  specification
 2007/11/11
*)
poly_tyrow 
      : label COLON poly_ty ([(label,poly_ty)])
      | label COLON poly_ty COMMA poly_tyrow ((label,poly_ty)::poly_tyrow)
      | label COLON poly_ty COMMA tyrow ((label,poly_ty)::tyrow)
      | label COLON ty COMMA poly_tyrow ((label,ty)::poly_tyrow)

poly_ty1 
    : LBRACE poly_tyrow RBRACE (Absyn.TYRECORD(poly_tyrow,(LBRACEleft,RBRACEright)))
    | LPAREN poly_ty RPAREN (poly_ty)
    | LBRACKET kinded_tyvarseq_without_paren PERIOD ty RBRACKET 
         (Absyn.TYPOLY(kinded_tyvarseq_without_paren, ty, (LBRACKETleft,RBRACKETright)))
    | LBRACKET kinded_tyvarseq_without_paren PERIOD poly_ty RBRACKET 
         (Absyn.TYPOLY(kinded_tyvarseq_without_paren, poly_ty, (LBRACKETleft,RBRACKETright)))

poly_tytuple 
    : poly_ty1 ASTERISK poly_tytuple (poly_ty1::poly_tytuple)
    | poly_ty1 ASTERISK tytuple (poly_ty1::tytuple)
    | poly_ty1 ASTERISK poly_ty1 ([poly_ty11,poly_ty12])
    | poly_ty1 ASTERISK ty1 ([poly_ty1, ty1])
    | ty1 ASTERISK poly_tytuple (ty1::poly_tytuple)
    | ty1 ASTERISK poly_ty1 ([ty1,poly_ty1])

poly_ty 
   : ty ARROW poly_ty (Absyn.TYFUN(ty,poly_ty,(tyleft, poly_tyright)))
   | poly_tytuple (Absyn.TYTUPLE(poly_tytuple,(poly_tytupleleft,poly_tytupleright)))
   | poly_ty1 (poly_ty1)

longid : id ([id])
       | longid PERIOD id (longid @ [id])


longtycon : id ([id])
          | id PERIOD longtycon (id::longtycon)

sigexpbasic : SIG spec END (Absyn.SIGEXPBASIC(spec,(SIGleft,ENDright)))
            | id (Absyn.SIGID(id,(idleft,idright)))

sigexpwhere : sigexp WHERE TYPE tyvarseq longtycon EQ ty
                (Absyn.SIGWHERE
                     (sigexp,[(tyvarseq,longtycon,ty)],(sigexpleft,tyright)))
            | sigexp WHERE TYPE longtycon EQ ty
                (Absyn.SIGWHERE
                     (sigexp,[(nil,longtycon,ty)],(sigexpleft,tyright)))
            | sigexpwhere AND TYPE tyvarseq longtycon EQ ty
                (Absyn.SIGWHERE
                     (sigexpwhere,[(tyvarseq,longtycon,ty)],(sigexpwhereleft,tyright)))
            | sigexpwhere AND TYPE longtycon EQ ty
                (Absyn.SIGWHERE
                     (sigexpwhere,[(nil,longtycon,ty)],(sigexpwhereleft,tyright)))


sigexp : sigexpbasic (sigexpbasic)
       | sigexpwhere (sigexpwhere)


longtyconeqrow : longtycon EQ longtycon ([longtycon1,longtycon2])
               | longtycon EQ longtyconeqrow (longtycon::longtyconeqrow)

longideqrow : longid EQ longid ([longid1,longid2])
            | longid EQ longid EQ longid ([longid1,longid2,longid3])
            | longid EQ longid EQ longideqrow (longid1::longid2::longideqrow)

spec : spec atomicspec
                (Absyn.SPECSEQ(spec,atomicspec,(specleft,atomicspecright)))
     | spec SHARING TYPE longtyconeqrow
                (Absyn.SPECSHARE
                     (spec,longtyconeqrow,(SHARINGleft,longtyconeqrowright)))
     | spec SHARING longideqrow
                (Absyn.SPECSHARESTR
                     (spec,longideqrow,(SHARINGleft,longideqrowright)))
     | (Absyn.SPECEMPTY)

atomicspec : VAL valdesc
                (Absyn.SPECVAL(valdesc,(VALleft,valdescright)))
           | TYPE typdesc
                (Absyn.SPECTYPE(typdesc,(TYPEleft,typdescright)))
           | TYPE typbind
                (Absyn.SPECDERIVEDTYPE(typbind,(TYPEleft,typbindright)))
           | EQTYPE typdesc
                (Absyn.SPECEQTYPE(typdesc,(EQTYPEleft,typdescright)))
           | DATATYPE datdesc
                (Absyn.SPECDATATYPE(datdesc,(DATATYPEleft,datdescright)))
           | DATATYPE tycon EQ DATATYPE longtycon
                (Absyn.SPECREPLIC
                     (tycon,longtycon,(DATATYPE1left,longtyconright)))
           | EXCEPTION exdesc
                (Absyn.SPECEXCEPTION(exdesc,(EXCEPTIONleft,exdescright)))
           | STRUCTURE strdesc
                (Absyn.SPECSTRUCT(strdesc,(STRUCTUREleft,strdescright)))
           | INCLUDE sigexp
                (Absyn.SPECINCLUDE(sigexp,(INCLUDEleft,sigexpright)))
(* new specification for functor *)
           | FUNCTOR fundesc
                (Absyn.SPECFUNCTOR(fundesc,(FUNCTORleft, fundescright)))

(*
  Ohori: valdesc now take poly_ty
  2007/11/11

valdesc : id COLON ty ([(id,ty)])
        | id COLON ty AND valdesc ((id,ty)::valdesc)
*)
valdesc : id COLON poly_ty ([(id,poly_ty)])
        | id COLON poly_ty AND valdesc ((id,poly_ty)::valdesc)
        | id COLON ty ([(id,ty)])
        | id COLON ty AND valdesc ((id,ty)::valdesc)

(* 2008.2.6 liu:default kind for unspecified abstraction is boxed *)
typdesc : tyvarseq tycon ([(tyvarseq, tycon)])
        | tycon ([(nil,tycon)])
        | tyvarseq tycon AND typdesc ((tyvarseq,tycon)::typdesc)
	| tycon AND typdesc  ((nil,tycon)::typdesc)


datdesc : tycon EQ condesc ([(nil,tycon,condesc)])
        | tyvarseq tycon EQ condesc ([(tyvarseq,tycon,condesc)])
        | tycon EQ condesc AND datdesc ((nil,tycon,condesc)::datdesc)
        | tyvarseq tycon EQ condesc AND datdesc
                ((tyvarseq,tycon,condesc)::datdesc)

condesc : id ([(id,NONE)])
        | id OF ty ([(id,SOME ty)])
        | id BAR condesc ((id,NONE)::condesc)
        | id OF ty BAR condesc ((id,SOME ty)::condesc)

exdesc : id ([(id,NONE)])
       | id OF ty ([(id,SOME ty)])
       | id AND exdesc ((id,NONE)::exdesc)
       | id OF ty AND exdesc ((id,SOME ty)::exdesc)

sigexpand : sigexpwhere AND (sigexpwhere)
          | sigexpbasic AND (sigexpbasic)

strdesc : id COLON sigexp ([(id,sigexp)])
        | id COLON sigexpand strdesc ((id,sigexpand)::strdesc)       

fundesc : id COLON SIG sigexp DARROW sigexp END ([(id1,sigexp1,sigexp2)])
        | id COLON SIG sigexp DARROW sigexp END AND fundesc ((id1,sigexp1,sigexp2) :: fundesc)


namespace : NAMESPACE longid (Absyn.NAMESPACE (longid, (longidleft, longidright)))
        | (* 2008.2.6 liu: new defintion for interface.grm *)
           ABSNAMESPACE longid (Absyn.ABSNAMESPACE (longid, (longidleft, longidright)))
        | (Absyn.EMPTYNAMESPACE)
(*
  Ohori: 2007/11/11
  new definition for interface.grm
*)
interface : namespace spec (namespace, spec, (namespaceleft, specright))
