	    let
		val (r,lexer') = oneParse (!currentLexer)
		val _ = currentLexer := lexer'
	    in 
		case r of
		    Absyn.USE s => 
			(let 
			    val _ = pushInput()
			    val _ =  useInput s
			in loop (fixenv,tcenv,varenv)
			end
        	     handle IO.Io s=> 
			     (let
				 val s1 = (#function s)
				 val s2 = (#name s)
				 val ex = (#cause s)
				 val mes = case ex of
				     OS.SysErr (s,SOME e) => 
					 "GenLex error: use clause ignored. " ^ OS.errorMsg e ^ " : " ^ s2
				   | _ => "IO error " ^ s1 ^ " " ^ s2
			     in
				  (TextIO.output(TextIO.stdOut,mes ^ "\n");
				   TextIO.flushOut TextIO.stdOut;
				   popInput();
				   loop (fixenv,tcenv,varenv))
			     end))
		  | Absyn.DECS (dec,loc) =>
		     let val _ = if !Control.printSource then
			             (print "Source expr:\n";
				      PrintAbsyn.printDecs r;
				      ())
				 else ()
			 val (pldec,fixenv) = Elab.elabDecs fixenv dec
			 val _ = if !Control.printElab then
			             (print "Elaborated to:\n";
				      map (fn y => print ((PrintPl.pldecToString y) ^ "\n")) pldec;
				      ())
				 else ();
			 val (tcenv1,varenv1,binds) =
			     TypeInf.typeinfTop (tcenv,varenv) pldec
			 val _ = if !Control.printETerm then
			            (print "Statically evaluated to:\n";
				     map (fn x => print (PrintTP.tpdecToString nil x ^ "\n")) binds;
				     print "Generated static bindings:\n";
				     print (PrintType.varenvToString varenv1))
				 else ();

			 val ( binds', warnings ) = ParallelMatchComp.tpdecsToRcdecs binds
			 val _ = if null warnings
			         then ()
				 else app (fn warning => 
                                           (print (SMLPP.prettyPrint {newlineString = "\n", spaceString = " ", columns = !Control.printWidth} 
                                                   (MatchError.format_errorInfo warning)); TextIO.print "\n")) warnings
(*
			 val binds' = map MatchCompile.tpdecToTldec binds
			 val _ = (print "Match Compiled to:\n";
				  map(fn x=> print (PrintRcalc.rcdecToString nil x ^ "\n")) binds')
*)
		     in
                       loop (fixenv,
			     StaticEnv.mergeTcenv (tcenv1,tcenv),
			     StaticEnv.mergeVarenv (varenv1,varenv))
		     end
		 handle CoreMLParser.ParseError => 
		     (flush();loop (fixenv,tcenv,varenv))
		      | Control.Bug s => (print (s^"\n");
					  flush();
					  loop (fixenv,tcenv,varenv))
		      | MatchError.Errors errors =>
		        (
			  app 
			  (fn error => 
			      (
			        print 
				(SMLPP.prettyPrint 
				{
				  newlineString = "\n", 
				  spaceString = " ", 
				  columns = !Control.printWidth
				} 
			        (MatchError.format_errorInfo error)); 
				TextIO.print "\n"
			      )) errors;
			  flush ();
			  loop ( fixenv, tcenv, varenv )
			)


	    end
    in
	(loop  (fixenv,tcenv,varenv))
	handle EndOfInput =>()
	     | Control.Bug s => print s
    end

val initialSource = {fileName="stdIn",stream=TextIO.stdIn,ln = ref 1, linePos= ref 1,
		     promptMode = true,
		     printInput = false,
                     comLevel=ref 0,
                     anyErrors = ref false,
		     stringBuf = ref nil : string list ref,
                     stringStart = ref {fileName="stdIn",line=0,col=0},
		     stringType = ref true
} : lexarg;
fun top () =
    topLevel
    (StaticEnv.initialFixenv,
     StaticEnv.initialTcenv,
     StaticEnv.initialVarenv
     )
    initialSource;

end;
(*
Top.top();
*)
