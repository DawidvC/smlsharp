structure IDTypes =
struct
local
  type loc = Loc.loc
  (*% @formatter(Absyn.eq) Absyn.format_eq *)
  type eq = (*% @format(x) x *) Absyn.eq
  fun bug s = Control.Bug ("IDTypes: " ^ s)
in

  (*% *)
  type path = (*% @format(name names)  names(name)(".") *) string list

  (* the ids (names) used in and after IDCalc *)
  (*% @formatter(TypID.id) TypID.format_id *)
  (* type name *)
  type typId = (*% @format(id) "t" id *) TypID.id

  (*% @formatter(ConID.id) ConID.format_id *)
  (* constructor name *)
  type conId = (*% @format(id) "c" id *) ConID.id

  (*% @formatter(VarID.id) VarID.format_id *)
  (* local variable name *)
  type varId = (*% @format(id) "v" id *) VarID.id

  (*% @formatter(ExnID.id) ExnID.format_id *)
  (* exception name *)
  type exnId = (*% @format(id) "e" id *) ExnID.id

  (*% @formatter(OPrimID.id) OPrimID.format_id *)
  (* overloaded primitve id *)
  type oprimId = (*% @format(id) "o" id *) OPrimID.id

  (*% @formatter(TvarID.id) TvarID.format_id *)
  (* type variable name *)
  type tvarId = (*% @format(id) "tv" id *) TvarID.id

  (*% @formatter(RevealID.id) RevealID.format_id *)
  (* type variable name *)
  type revealKey = (*% @format(id) "rv" id *) RevealID.id

  (*%  *)
  (* type variable; if lifted=ture then this type variable is originally
     a type constructore in a functor argument.
   *)
  type tvar = 
     (*% @format({name, id, eq, lifted})
         eq name "(" id ")" *)
     {name:string, id:tvarId, eq:eq, lifted:bool}

(*
  fun formatEnclosedSet listItems (format, lparen, comma, rparen) map =
      TermFormat.formatOptionalList
        (fn value => format value, lparen, comma, rparen)
        (listItems map)
*)

  fun formatEnclosedTvarSet (lparen, comma, rparen) map =
      TermFormat.formatOptionalList
        (format_tvar, lparen, comma, rparen)
        (TvarSet.listItems map)

  fun formatEnclosedTvarMap (formatter, lparen, mapsto, comma, rparen)  map =
      TermFormat.formatOptionalList
        (fn (tvar, item) => (format_tvar tvar) @ mapsto @ (formatter item),
         lparen,
         comma,
         rparen
        )
        (TvarMap.listItemsi map)
  (*%
     @formatter(TvarSet.set) formatEnclosedTvarSet
   *)
  (* the set of tycons in a functor argument that are lifted to
     type variables *)
  type liftedTys =
       (*%  @format(tvset)  tvset()("<",",","> ")  *)
       TvarSet.set

  val emptyLiftedTys = TvarSet.empty : liftedTys

  (*%  @formatter(enclosedList) TermFormat.formatEnclosedList *)
  type formals
   = (* @format(formal formals) formals:enclosedList(formal)("(",",",")") *)
     tvar list

 (*%
     @formatter(bool) SmlppgUtil.formatBinaryChoice
     @formatter(SEnv.map) TermFormat.formatEnclosedSEnvPlain
     @formatter(enclosedList) TermFormat.formatEnclosedList
     @formatter(option) TermFormat.formatOptionalOption
     @formatter(ifCons) TermFormat.formatIfCons
     @formatter(seqList) TermFormat.formatSeqList
     @formatter(optionalList) TermFormat.formatOptionalList
     @formatter(BuiltinPrimitive.primitive) BuiltinPrimitive.format_primitive
     @formatter(recordTy) TermFormat.formatRecordTy
   *)
  (* types *)
  datatype ty
    = (*% @format "_" *)
      TYWILD
    | (*% @format "?" *)
      TYERROR
    | (*% @format(tvar) tvar *)
      TYVAR of tvar
    | (*%  @format(ty tys) tys:recordTy(ty) *)
      TYRECORD of ty SEnv.map
    | (*%
       * @format({typ, args: argTy argTys})
       *   L8{ 1[ argTys:seqList(argTy)("(",",",")")
       *          argTys:ifCons()(+1) typ ] }
       *)
      TYCONSTRUCT of {typ:typInfo, args:ty list}
    | (*%
       * @format(ty1 tys * ty2) 
       *   R4{ "{" tys(ty1)(",") "}" +1 "->" +d ty2 }
       *)
      TYFUNM of ty list * ty
    | (*%
       * @format(kindedTvar list * ty)
       *   "[" !N0{ list(kindedTvar)(",") "." +1 ty "]" }
       *)
      TYPOLY of kindedTvar list * ty

  and tvarKind
    = (*% @format *)
      UNIV
    | (*%
        @format(ty tys)
        "#" tys:recordTy(ty)
       *)
      REC of ty SEnv.map

  (* type function; there are two varieties.
     TFUN_DEF for a type-level lambda term \'a.ty 
     TFUN_VAR for a type name
   *)
  and tfun
    = (*% @format({iseq, formals, realizerTy})
          1["\\" formals "." +1 realizerTy]
       *)
      (* "type foo = ty"; after name evaluation this will not apper. *)
      TFUN_DEF of {iseq:bool, formals:formals, realizerTy:ty}
    | (*% @format(tfunkind tfunref)
           tfunref(tfunkind)
       *)
      TFUN_VAR of tfunkind ref

  (* actual structures of a type function *)
  and tfunkind 
    = (*% @format({id, iseq, formals, conSpec, liftedTys, dtyKind})
          liftedTys "d" id "(" iseq()("EQ","NONEQ") ")" dtyKind
       *)
      (* datatype name; after name evaluation this is the only entry *)
      TFUN_DTY of {id:typId,
                   iseq:bool,
                   formals:formals,
                   conSpec:conSpec,
                   liftedTys:liftedTys,
                   dtyKind:dtyKind
                  }
    | (*% @format({id, iseq, formals}) "s" id  *)
      (* type constructore name in spec *)
      TFV_SPEC of {id:typId, iseq:bool, formals:formals}
    | (*% @format({id, iseq, formals, conSpec, liftedTys})
          liftedTys "v" id
       *)
      (* datatype name in spec *)
      TFV_DTY of {id:typId,
                  iseq:bool,
                  formals:formals,
                  conSpec:conSpec,
                  liftedTys:liftedTys}
    | (*% @format({id, tfun}) "*r" + tfun *)
      (* a type name that has been substituted for a type realizer.
         This will only appear in spec.
       *)
      REALIZED of {id:typId, tfun:tfun}
    | (*% @format({tfunkind, tfun})
          1[tfun +1 "(i*" tfunkind ")"]
       *)
      (* a type name that has been instantiated by an actual type function 
         This is generated by signature check.
       *)
      INSTANTIATED of {tfunkind:tfunkind, tfun:tfun}
    | (*% @format({tfunkind, tvar})
          1[tvar +1 "(tfun *t" tfunkind ")"]
       *)
      (* a type construtor in a functor argument that has been lifted to
         type variable.
       *)
      FUN_TOTVAR of {tfunkind:tfunkind, tvar:tvar}
    | (*% @format({tfun, varE, formals, conSpec, liftedTys})
          "*d" tfun
       *)
      (* a datatype in a functor argument that has been materialized to
         an actual datatype. varE contains generated conId for datatype
         spec.
       *)
      FUN_DTY of {tfun:tfun,
                  varE:varE,
                  formals:formals,
                  conSpec:conSpec,
                  liftedTys:liftedTys}

  and dtyKind 
    = (*% @format "[FP]" *)
      (* datatype including atomic types *)
      FUNPARAM
    | (*% @format "[DTY]" *)  
      (* datatype including atomic types *)
      DTY
    | (*% @format({tfun, revealKey})
                 "[opaque("revealKey "," tfun ")" "]" *)
      (* opaque types of builtin types; opqaue types of datatypes are DTYs *)
      OPAQUE of {tfun:tfun, revealKey:revealKey}
    | (*% @format(builtin) *)
      (* builtin types *)
      BUILTIN of BuiltinType.ty

   and idstatus
    = (*% @format(id)  "var" + id
       *)
      (* variable name *)
      IDVAR of varId
    | (*% @format({path, ty})  "external var" + path + ":" + ty
       *)
      (* external variable name *)
      IDEXVAR of {path:path, ty:ty}
    | (*% @format({primitive, ty})  "primitive" + primitive
       *)
      (* external variable name *)
      IDBUILTINVAR of {primitive: BuiltinPrimitive.primitive, ty:ty}
    | (*% @format({id, ty})
          "con" + id + ":" + ty
       *)
     (* constructor name *)
      IDCON of {id:conId, ty:ty}
    | (*% @format({id, ty:ty})
          "exn" + id + ":" + ty
       *)
     (* exception name *)
      IDEXN of {id:exnId, ty:ty}
    | (*% @format({id, ty:ty})
          "exn rep" + id + ":" + ty
       *)
     (* exception name *)
      IDEXNREP of {id:exnId, ty:ty}
    | (*% @format({path, ty:ty})
          "external exn" + path + ":" + ty
       *)
     (* external exception name *)
      IDEXEXN of {path:path, ty:ty}
    | (*% @format(id)  "oprim" "(" id ")" *)
      (* overloaded primitive name *)
      IDOPRIM of oprimId
    | (*% @format(ty) 1["SPECVAR" +1 ":" + ty] *)
      (* variable name in spec *)
      IDSPECVAR of ty
    | (*% @format(ty) "SPECEXN" + ty *)
      (* exception name in a functor argument *)
      IDSPECEXN of ty
    | (*% @format "SPECCON" *)
      (* constructor name in a functor argument *)
      IDSPECCON 

  withtype kindedTvar
    = (*% @format(tvar * tvarKind) tvar tvarKind *)
      tvar * tvarKind

  and typInfo
    = (*% @format({path, tfun:tfun}) path "(" tfun ")" *)
      {path: path, tfun: tfun}

  and conInfo
    = (*% @format({path, ty, id}) path "(" id ")" + ":" + ty *)
      (* ty is the type as a function *)
      {path: path, ty:ty, id: conId}

  and exnInfo
    = (*% @format({path, ty, id})  path "(" id ")" *)
      (* ty is the type as a function *)
      {path: path, id: exnId, ty:ty}

  and conSpec
    = (*% @format(conEntry senv) senv(conEntry)(+1"|"+, )
          @format:conEntry(ty opt) opt(ty)(+d "of" +d,)
       *)
       (ty option) SEnv.map

  and varE
    = (*%
        @format(idstatus senv) 
          "{"
           1[
             senv(idstatus)(1, ":"+)
            ]
           1
          "}"
       *)
      idstatus SEnv.map

  (*% *)
  datatype ffiTy =
      (*%
       * @format(attr * dom doms * ret rets * loc)
       *           R1{ "(" doms(dom)("," + ) ")" +d "->"
       *               2[ +1 "(" rets(ret)("," + ) ")" ] }
       *)
      FFIFUNTY of Absyn.ffiAttributes option * ffiTy list * ffiTy list * loc
    | (*%
       * @format(field fields * loc)
       *           !N0{ "{" 2[ 1 fields(field)("," +1) ] 1 "}" }
       * @format:field(label * ty) {label} +d ":" +d {ty}
       *)
      FFIRECORDTY of (string * ffiTy) list * loc
    | (*%
       * @format(ty * loc) ty
       *)
      FFIBASETY of ty * loc

  fun mkTfv (tfvkind:tfunkind) = ref tfvkind 

  fun tfunFormals tfun =
      case tfun of 
        TFUN_DEF {formals,...} => formals
      | TFUN_VAR (ref tfv) =>
        (case tfv of
           TFV_SPEC {formals,...} => formals
         | TFV_DTY {formals,...} => formals
         | TFUN_DTY {formals,...} => formals
         | REALIZED {tfun,...} => tfunFormals tfun
         | INSTANTIATED {tfun,...} => tfunFormals tfun
         | FUN_TOTVAR _ => nil
         | FUN_DTY {tfun,...} => tfunFormals tfun
       )

  fun tfunLiftedTys tfun =
      case tfun of 
        TFUN_DEF _ => emptyLiftedTys
      | TFUN_VAR (ref tfv) =>
        (case tfv of
           TFV_SPEC _ => emptyLiftedTys
         | TFV_DTY {liftedTys,...} => liftedTys
         | TFUN_DTY {liftedTys,...} => liftedTys
         | REALIZED {tfun,...} => tfunLiftedTys tfun
         | INSTANTIATED {tfun,...} => tfunLiftedTys tfun
         | FUN_TOTVAR {tvar,...} => TvarSet.singleton tvar
         | FUN_DTY {tfun,...} => tfunLiftedTys tfun
        )

  fun tvarIseq {name, id, eq, lifted} =
      case eq of
        Absyn.EQ => true
      | Absyn.NONEQ => false
      
  fun tfunIseq tfun =
      case tfun of 
        TFUN_DEF {iseq,...} => iseq
      | TFUN_VAR (ref tfv) =>
        (case tfv of
           TFV_SPEC {iseq,...} => iseq
         | TFUN_DTY {iseq,...} => iseq
         | TFV_DTY {iseq,...} => iseq
         | REALIZED {tfun,...} => tfunIseq tfun
         | INSTANTIATED {tfun, ...} => tfunIseq tfun
         | FUN_TOTVAR {tvar,...} => tvarIseq tvar 
         | FUN_DTY {tfun,...} => tfunIseq tfun
        )

  fun tfunkindId tfunkind = 
      (case tfunkind of
        TFV_SPEC {id,...} => id
      | TFV_DTY {id,...} => id
      | TFUN_DTY {id,...} => id
      | REALIZED {id,...}  => id
      | INSTANTIATED {tfunkind,...} => tfunkindId tfunkind
      | FUN_TOTVAR {tfunkind,...} => tfunkindId tfunkind
      | FUN_DTY {tfun,...} => tfunId tfun
      )
      handle exn => raise  exn

  and tfvId tfv =
      case !tfv of
        TFV_SPEC {id,...} => id
      | TFV_DTY {id,...} => id
      | TFUN_DTY {id,...} => id
      | REALIZED _ => raise bug "tfvid: ReALIZED"
      | INSTANTIATED {tfun,...} => tfunId tfun
      | FUN_TOTVAR {tfunkind,...} => raise bug "FUN_TOTVAR"
      | FUN_DTY {tfun,...} => raise bug "FUN_DTY"

  and tfunId tfun =
      case tfun of 
        TFUN_DEF _ => raise bug "TFUN_DEF to TFUNID"
      | TFUN_VAR tfv => (tfvId tfv handle exn => raise exn)

  fun tfunArity tfun = List.length (tfunFormals tfun)

  fun pruneTfun tfun =
      case tfun of
        TFUN_DEF _ => tfun
      | TFUN_VAR (ref tfunkind) =>
        (case tfunkind of 
           REALIZED {tfun,...} => pruneTfun tfun
         | INSTANTIATED {tfun,...} => pruneTfun tfun
         | _ => tfun
        )

  fun derefTfun tfun =
      case tfun of
        TFUN_DEF _ => tfun
      | TFUN_VAR (ref tfunkind) =>
        (case tfunkind of 
           REALIZED {tfun,...} => derefTfun tfun
         | _ => tfun
        )
  fun liftedTysUnion (map1:liftedTys, map2:liftedTys) =
      TvarSet.union (map1, map2)
  fun liftedTysSingleton tvar = TvarSet.singleton tvar : liftedTys
  fun liftedTysToTyvars (liftedTys:liftedTys) = TvarSet.listItems liftedTys
  fun liftedTysToTy (liftedTys:liftedTys) =
      map (fn tv => TYVAR(tv)) (liftedTysToTyvars liftedTys)

end
end
