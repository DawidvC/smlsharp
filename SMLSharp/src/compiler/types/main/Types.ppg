(**
 * type structures.
 * @copyright (c) 2006, Tohoku University.
 * @author Atsushi Ohori
 * @author Liu Bochao
 * @author YAMATODANI Kiyoshi
 * @version $Id: Types.ppg,v 1.69 2010/02/23 10:17:15 keita44 Exp $
 *)

structure Types : TYPES =
struct

  (*% @formatter(TyConID.id) TyConID.format_id *)
  type tyConID =
      TyConID.id

  (*% @formatter(ExnTagID.id) ExnTagID.format_id *)
  type exnTagID =
      ExnTagID.id

  (*% *)
  type dummyTyID =
      (*% @format(id) "X" id *)
      int

  (* this is a temporal definition *)
  type lambdaDepth = int
  val infiniteDepth = valOf Int.maxInt (* the largest word in SML/NJ *)
  val toplevelDepth = 0
  fun youngerDepth {contextDepth, tyvarDepth} = contextDepth <= tyvarDepth
  fun strictlyYoungerDepth (tyvarDepth, contextDepth) =
      contextDepth < tyvarDepth

  (*% @params(tyvar) *)
  datatype eqKind =
      (*% @format "''" tyvar *)
      EQ
    | (*% @format "'" tyvar *)
      NONEQ

  (*% *)
  type freeTypeVarID =
       (*% @format (*dummy*) *)
       FreeTypeVarID.id

  fun format_freeTypeVarID ftvId =
      TermFormat.formatFreeTyvar (FreeTypeVarID.toInt ftvId)

  (*% *)
  type boundTypeVarID =
      (*% @format (*dummy*) *)
      int   (* globally unique *)

  fun format_boundTypeVarID btvEnv btvId =
      TermFormat.formatBtv
        (fn tyvar => fn {eqKind, recordKind} => format_eqKind tyvar eqKind)
        btvEnv btvId

  (*%
   * @formatter(Path.path) Path.format_pathWithDotend
   *)
  type tyCon =
      (*%
       * @format({name, strpath, abstract,  tyvars, id, eqKind,
       *          constructorHasArgFlagList})
       * strpath name
       *)
      {
        name : string,
        strpath : Path.path,
        tyvars : eqKind list,
        id : tyConID,
        abstract : bool,       (* for abstype *)
        eqKind : eqKind ref,
        (* list of data constructor status
         * nil - none (for int etc) or infinite (for exn)
         * (true|false)::t -  true => has argument , false => has no argment
         *)
        constructorHasArgFlagList : bool list
      }

  local
    (* hack for printing bound type variables in pretty order. *)
    exception BtvOrder
    datatype 'ty btvorder =
        LIST of boundTypeVarID list
      | FN of 'ty -> boundTypeVarID list

    fun getEnv [(btvEnv, order)] = {btvEnv=btvEnv, order=order}
      | getEnv _ = raise Control.Bug "Types: getEnv"

    fun format_btv_forBOUNDVARty env btvId =
        format_boundTypeVarID (#btvEnv (getEnv env)) btvId

    (* formatter for POLYty. general btvEnv formatter is defined later. *)
    fun format_btvEnv_forPOLYty (formatRecordKind, env) btvMap =
        let
          val {btvEnv, order} = getEnv env
          val order = case order of LIST l => l | FN _ => raise BtvOrder
          fun formatTyvar tyvar (btvKind as {eqKind, recordKind}) =
              format_eqKind (tyvar @ formatRecordKind btvKind) eqKind
        in
          TermFormat.formatBtvSetWithOrder formatTyvar btvEnv (btvMap,order)
        end

    fun extendBtvEnv env (polyTy as {boundtvars=btvMap, body}) =
        let
          val {btvEnv, order} = getEnv env
          val order = case order of LIST l => l | FN f => f polyTy
        in
          [(TermFormat.extendBtvEnvWithOrder btvEnv (btvMap,order), LIST order)]
        end
  in

  (*%
   * @params(btvEnv)
   * @formatter(enclosedList) TermFormat.formatEnclosedList
   * @formatter(seqList) TermFormat.formatSeqList
   * @formatter(appList) TermFormat.formatAppList
   * @formatter(optionalList) TermFormat.formatOptionalList
   * @formatter(ifCons) TermFormat.formatIfCons
   * @formatter(enclosedSEnv) TermFormat.formatEnclosedSEnv
   * @formatter(recordTy) TermFormat.formatRecordTy
   * @formatter(option) TermFormat.formatOptionalOption
   * @formatter(extendBtvEnv) extendBtvEnv
   * @formatter(format_btvEnv_forPOLYty) format_btvEnv_forPOLYty
   * @formatter(format_btv_forBOUNDVARty) format_btv_forBOUNDVARty
   * @formatter(OPrimID.id) OPrimID.format_id
   *)
  datatype recordKind =
      (*%
       * @format(ty tys)
       * "::" tys:enclosedList(ty()(btvEnv))("{",",","}")
       *)
      (* for overloaded constants *)
      OCONSTkind of ty list
    | (*%
       * @format({instances: ty tys,
       *          operators})
       * "::" tys:enclosedList(ty()(btvEnv))("{",",","}")
       *)
      OPRIMkind of {instances : ty list, operators : operator list}
    | (*%
       * @format
       *)
      UNIV
    | (*%
       * @format(ty tys)
       * "#" tys:enclosedSEnv(ty()(btvEnv))("{",",",":","}")
       *)
      REC of ty SEnv.map

  and tvState =
      (*%
       * @format(tvKind) tvKind()(btvEnv)
       *)
      TVAR of tvKind
    | (*%
       * @format(ty) ty()(btvEnv)
       *)
      SUBSTITUTED of ty

  and ty =
      (*%
       * @format(operator) "INSTCODE(" !N0{ operator()(btvEnv) ")" }
       *)
      (* a singletonset denoting the instance function for a type 'a *)
      INSTCODEty of operator
    | (*%
       * @format "ERRORty"
       *)
      ERRORty
    | (*%
       * @format(id) id
       *)
      DUMMYty of dummyTyID
    | (*%
       * @format(tv tvRef) tvRef(tv()(btvEnv))
       *)
      TYVARty of tvState ref
    | (*%
       * @format(id) id:format_btv_forBOUNDVARty()(btvEnv)
       *)
      BOUNDVARty of boundTypeVarID
    | (*%
       * @format(argTy argTys * retTy)
       * R4{ argTys:appList(argTy()(btvEnv))("{",",","}")
       *     +1 "->" +d retTy()(btvEnv) }
       *)
      FUNMty of ty list * ty
    | (*%
       * @format(ty tys)
       * tys:recordTy(ty()(btvEnv))
       *)
      RECORDty of ty SEnv.map
    | (*%
       * @format({tyCon, args: argTy argTys})
       * L8{ 2[ argTys:seqList(argTy()(btvEnv))("(",",",")")
       *        argTys:ifCons()(+1) tyCon ] }
       *)
      RAWty of
      {
        tyCon : tyCon,
        args : ty list
      }
    | (*%
       * @format(polyTy)
       * polyTy()(polyTy:extendBtvEnv()(btvEnv))
       *)
      POLYty of polyTy
    | (*%
       * @format(ty1 * ty2) ty1()(btvEnv)
       *)
      ALIASty of ty * ty
    | (*%
       * @format({spec, implTy}) spec
       * @format:spec({tyCon, args: argTy argTys})
       * L8{ 2[ argTys:seqList(argTy()(btvEnv))("(",",",")")
       *        argTys:ifCons()(+1) tyCon ] }
       *)
      (* id of tyCon is real id *)
      OPAQUEty of
      {
        spec : {tyCon : tyCon, args : ty list},
        implTy: ty
      }
    | (*%
       * @format({tyCon, args: argTy argTys})
       * L8{ 2[ argTys:seqList(argTy()(btvEnv))("(",",",")")
       *        argTys:ifCons()(+1) tyCon ] }
       *)
      (* type specification which only appears in either signature or
       * functor body *)
      (* id of tyspec is bound id *)
      SPECty of
      {
        tyCon : tyCon,
        args : ty list
      }

  withtype tvKind =
      (*
       Ohori: Dec 3, 2006.
       lambdaDepth is introduce to speed up type generalization.
       Initially, it is equal to the length of \Gamma at which a type
       variable is introduced. The top level is therefore 0.
       We then maintain the invariant:
         lambdaDepth(t) is the minimal |\Gamma|  such that
              \Gamma{x:\tau(t)}
       A type variable is created with lambdaDepth = INFINITE.
       When a type is entered in \Gamma{x:\tau}, the lambdaDepth of
       each type variable t' in tau is set to |\Gamma|
       Whenever (t,tau) is unified, the lambdaDepth of each type variable t'
       in tau must be set to min(lambdaDepth(t), lambdaDepth(t')).
      *)
      (*%
       * @format({lambdaDepth,
       *          id,
       *          recordKind,
       *          eqKind,
       *          tyvarName: name nameOpt})
       * eqKind()(id nameOpt(name)("(",")"))
       * recordKind()(btvEnv)
       *)
      {
        lambdaDepth : lambdaDepth,
        id : freeTypeVarID,
        recordKind : recordKind,
        eqKind : eqKind,
        tyvarName : string option  (* SOME: user-defined type variable *)
      }

  and btvEnv =
      (*%
       * (* only for POLYty. general btvEnv formatter is defined later. *)
       * @format(btvKind imap)
       * imap:format_btvEnv_forPOLYty(btvKind)(btvEnv)
       * @format:btvKind({eqKind, recordKind})
       * recordKind()(btvEnv)
       *)
      {eqKind: eqKind, recordKind: recordKind} IEnv.map

  and polyTy = (* for pretty printing *)
      (*%
       * @format({boundtvars, body})
       * "[" !N0{ boundtvars()(btvEnv) "." +1 body()(btvEnv) "]" }
       *)
      (**
       * boundtvars = {..., btvid -> btvKind as {recordKind, eqKind}, ...}
       * btvid is the id of boundTvars used as i in BOUNDVARty(i)
       *)
      {
        boundtvars : btvEnv,
        body : ty
      }

  and operator =
      (*%
       * @format({oprimId,
       *          oprimPolyTy,
       *          name,
       *          instTyList: instTy instTys,
       *          keyTyList: keyTy keyTys})
       * name "#" oprimId
       * instTys:optionalList(instTy()(btvEnv))(+1 "{",",","}")
       * +1 "::" +d keyTys:enclosedList(keyTy()(btvEnv))("[",",","]")
       *)
      {
        oprimId : OPrimID.id,
        oprimPolyTy : ty,
        name : string,
        keyTyList : ty list,
        instTyList : ty list
      }

  (* printing order of bound type variables. *)
  fun btvOrderTy ty =
      case ty of
        INSTCODEty {oprimId, oprimPolyTy, name, keyTyList, instTyList} =>
        List.concat (map btvOrderTy (instTyList @ keyTyList))
      | ERRORty => nil
      | DUMMYty _ => nil
      | TYVARty (ref (TVAR _)) => nil
      | TYVARty (ref (SUBSTITUTED ty)) => btvOrderTy ty
      | BOUNDVARty id => [id]
      | FUNMty (tys, ty) => List.concat (map btvOrderTy (tys @ [ty]))
      | RECORDty tys => List.concat (map btvOrderTy (SEnv.listItems tys))
      | RAWty {tyCon, args} => List.concat (map btvOrderTy args)
      | POLYty polyTy => btvOrder polyTy
      | ALIASty (ty, _) => btvOrderTy ty
      | OPAQUEty {spec={tyCon, args},...} => List.concat (map btvOrderTy args)
      | SPECty {tyCon, args} => List.concat (map btvOrderTy args)
  and btvOrderKind {eqKind, recordKind} =
      case recordKind of
        OCONSTkind tys => List.concat (map btvOrderTy tys)
      | OPRIMkind {instances,...} => List.concat (map btvOrderTy instances)
      | UNIV => nil
      | REC tys => List.concat (map btvOrderTy (SEnv.listItems tys))
  and btvOrder {boundtvars, body} =
      (* assume that every bound type variables is unique. *)
      foldr (fn (x,z) => case IEnv.find (boundtvars, x) of
                           NONE => x :: z | SOME k => x :: btvOrderKind k @ z)
            nil (btvOrderTy body)

  val format_recordKind =
      fn btvEnv => fn x => format_recordKind [(btvEnv, FN btvOrder)] x
  val format_tvState =
      fn btvEnv => fn x => format_tvState [(btvEnv, FN btvOrder)] x
  val format_ty =
      fn btvEnv => fn x => format_ty [(btvEnv, FN btvOrder)] x
  val format_tvKind =
      fn btvEnv => fn x => format_tvKind [(btvEnv, FN btvOrder)] x
  val format_operator =
      fn btvEnv => fn x => format_operator [(btvEnv, FN btvOrder)] x

  end (* local *)

  (*%
   * @params(btvEnv, tyvar)
   *)
  type btvKind =
      (*%
       * @format({eqKind, recordKind})
       * eqKind()(tyvar recordKind()(btvEnv))
       *)
      {
        recordKind : recordKind,
        eqKind : eqKind
      }

  (* general formatter for btvEnv *)
  fun format_btvEnv btvEnv btvMap =
      let
        val btvEnv = TermFormat.extendBtvEnv btvEnv btvMap
        fun formatTyvar tyvar kind = format_btvKind (btvEnv, tyvar) kind
      in
        TermFormat.formatBtvList formatTyvar btvEnv (IEnv.listKeys btvMap)
      end

  (* for pretty printing *)
  type formatBtvEnv =
      btvKind TermFormat.btvEnv

  (*%
   * @params(btvEnv)
   * @formatter(NameMap.namePath) NameMap.format_namePath
   * @formatter(BuiltinPrimitive.prim_or_special)
   *     BuiltinPrimitive.format_prim_or_special
   *)
  (*%
   * @prefix formatWithoutType_
   * @formatter(NameMap.namePath) NameMap.format_namePath
   * @formatter(BuiltinPrimitive.prim_or_special)
   *     BuiltinPrimitive.format_prim_or_special
   *)
  type varPathInfo =
      (*%
       * @format({namePath, ty})
       * L2{ namePath +1 ":" +d ty()(btvEnv) }
       *)
      (*% @prefix formatWithoutType_
       * @format({namePath, ty}) namePath
       *)
      {
        namePath : NameMap.namePath,
        ty : ty
      }

  and primInfo =
      (*%
       * @format({prim_or_special, ty})
       * L2{ prim_or_special +1 ":" +d ty()(btvEnv) }
       *)
      (*% @prefix formatWithoutType_
       * @format({prim_or_special, ty}) prim_or_special
       *)
      {
        prim_or_special : BuiltinPrimitive.prim_or_special,
        ty : ty
      }

  and oprimInfo =
      (*%
       * @format({name, oprimId, oprimPolyTy})
       * L2{ name +1 ":" +d oprimPolyTy()(btvEnv) }
       *)
      (*% @prefix formatWithoutType_
       * @format({name, oprimId, oprimPolyTy}) name
       *)
      {
        oprimPolyTy : ty,
        name : string,
        oprimId : OPrimID.id
      }

  and conPathInfo =
      (*%
       * @format({namePath, funtyCon, ty, tag, tyCon})
       * L2{ namePath +1 ":" +d ty()(btvEnv) }
       *)
      (*% @prefix formatWithoutType_
       * @format({namePath, funtyCon, ty, tag, tyCon}) namePath
       *)
      (* before unique id allocation; see also conInfo *)
      {
        namePath : NameMap.namePath,
        funtyCon : bool,
        ty : ty,
        tag: int,
        tyCon : tyCon
      }

  and exnPathInfo =
      (*%
       * @format({namePath, funtyCon, ty, tag, tyCon})
       * L2{ namePath +1 ":" +d ty()(btvEnv) }
       *)
      (*% @prefix formatWithoutType_
       * @format({namePath, funtyCon, ty, tag, tyCon}) namePath
       *)
      (* before unique id allocation; see also exnInfo *)
      {
        namePath : NameMap.namePath,
        funtyCon : bool,
        ty : ty,
        tag: exnTagID,
        tyCon : tyCon
      }

  (*%
   * @params(btvEnv)
   *)
  datatype idState =
      (*%
       * @format(var) var()(btvEnv)
       *)
      VARID of varPathInfo
    | (*%
       * @format(con) con()(btvEnv)
       *)
      CONID of conPathInfo
    | (*%
       * @format(exn) exn()(btvEnv)
       *)
      EXNID of exnPathInfo
    | (*%
       * @format(prim) prim()(btvEnv)
       *)
      PRIM of primInfo
    | (*%
       * @format(oprim) oprim()(btvEnv)
       *)
      OPRIM of oprimInfo
    | (*%
       * @format(var * arity) var()(btvEnv)
       *)
      RECFUNID of varPathInfo * int

  (*%
   * @params(btvEnv)
   * @formatter(SEnv.map) TermFormat.formatEnclosedSEnv
   *)
  type dataTyInfo =
      (*%
       * @format({tyCon, datacon: idstate smap})
       * 2[ tyCon +d "=" +1
       *    smap(idstate()(btvEnv))("{",",",d "=>","}") ]
       *)
      (* NOTE: strpath is absolute path. *)
      {
        tyCon: tyCon,
        datacon : idState SEnv.map
      }

  (***********************************************************************
   * for type environments
   ***********************************************************************)

  (*%
   * @params(btvEnv)
   * @formatter(extendBtvEnv) TermFormat.extendBtvEnv
   * @formatter(format_pathdot) Path.format_pathWithDotend
   *)
  type tyFun =
      (*%
       * @format({name, strpath, tyargs, body})
       * 2[ "(" !N0{ tyargs()(btvEnv) ")" }
       *    strpath:format_pathdot name +d "="
       *    +1 body()(tyargs:extendBtvEnv()(btvEnv)) ]
       *)
      {
        name : string,
        strpath : Path.path,
        tyargs : btvEnv,
        body : ty
      }

  (*%
   * @params(btvEnv)
   *)
  datatype tyBindInfo =
      (*%
       * @format(dataTyInfo)
       * { "TYCON" +d "{" 2[ +1 dataTyInfo()(btvEnv) ] +1 "}" }
       *)
      TYCON of dataTyInfo
    | (*%
       * @format(tyFun)
       * { "TYFUN" +d "{" 2[ +1 tyFun()(btvEnv) ] +1 "}" }
       *)
      TYFUN of tyFun
    | (*%
       * @format(tyCon) tyCon
       * "TYSPEC" +d tyCon
       *)
      (* abstract type declaration in signature *)
      TYSPEC of tyCon
    | (*%
       * @format({spec, impl})
       * "TYOPAQUE" +d spec
       *)
      (* opaque type specification after signature matching *)
      TYOPAQUE of {spec: tyCon, impl: tyBindInfo}

  (*%
   * @params(btvEnv)
   * @formatter(NameMap.NPEnv.map) NameMap.formatNPmap
   *)
  type tyConEnv =
       (*%
        * @format(tyBindInfo npmap)
        * npmap(tyBindInfo()(btvEnv))("=",+1)
        *)
       tyBindInfo NameMap.NPEnv.map

  (*%
   * @params(btvEnv)
   * @formatter(SEnv.map) TermFormat.formatEnclosedSEnv
   *)
  type topTyConEnv =
       (*%
        * @format(tyBindInfo smap)
        * smap(tyBindInfo()(btvEnv))("{",",",+d "=","}")
        *)
       tyBindInfo SEnv.map

  (*%
   * @params(btvEnv)
   * @formatter(SEnv.map) TermFormat.formatEnclosedSEnv
   *)
  type utvEnv =
      (*%
       * @format(tvStateRef smap)
       * smap(tvStateRef)("{",",",":","}")
       * @format:tvStateRef(tvState r)
       * r(tvState()(btvEnv))
       *)
      (tvState ref) SEnv.map

  (************************************************************************
   * for value environments
   ************************************************************************)

  (*%
   * @params(btvEnv)
   * @formatter(NameMap.NPEnv.map) NameMap.formatNPmap
   *)
  type varEnv =
      (*%
       * @format(idState npmap) npmap(idState()(btvEnv))(":",+2)
       *)
      idState NameMap.NPEnv.map

  (*%
   * @params(btvEnv)
   * @formatter(SEnv.map) TermFormat.formatEnclosedSEnv
   *)
  type topVarEnv =
      (*%
       * @format(idState smap) smap(idState()(btvEnv))("{",",",":","}")
       *)
      idState SEnv.map

  (*%
   * @params(btvEnv)
   *)
  type Env =
      (*%
       * @format(tyConEnv * varEnv)
       * { "tyConEnv" +d "=" 2[ +2 tyConEnv()(btvEnv) ]
       *   +1 "varEnv" +d "=" 2[ +2 varEnv()(btvEnv) ] }
       *)
       tyConEnv * varEnv

  (*%
   * @params(btvEnv)
   *)
  type topEnv =
      (*%
       * @format(tyConEnv * varEnv)
       * { "tyConEnv" +d "=" 2[ +2 tyConEnv()(btvEnv) ]
       *   +1 "varEnv" +d "=" 2[ +2 varEnv()(btvEnv) ] }
       *)
       topTyConEnv * topVarEnv

  val emptyTopEnv =
      (SEnv.empty, SEnv.empty) : topEnv

  (*%
   * @formatter(VarID.id) VarID.format_id
   * @formatter(ExternalVarID.id) ExternalVarID.format_id
   *)
  datatype varId =
      (*%
       * @format(id) "#G" id
       *)
      EXTERNAL of ExternalVarID.id
    | (*%
       * @format(id) "#" id
       *)
      INTERNAL of VarID.id

  (*%
   * @params(btvEnv)
   *)
  (*%
   * @prefix formatWithoutType_
   * @formatter(varId) format_varId
   *)
  type varIdInfo =
      (*%
       * @format({displayName, ty, varId})
       * L2{ displayName varId +1 ":" +d ty()(btvEnv) }
       *)
      (*% @prefix formatWithoutType_
       * @format({displayName, ty, varId}) displayName
       *)
      {
        displayName : string,
        ty : ty,
        varId : varId
      }

  (*%
   * @params(btvEnv)
   * @formatter(NameMap.namePath) NameMap.format_namePath
   *)
  (*%
   * @prefix formatWithoutType_
   * @formatter(NameMap.namePath) NameMap.format_namePath
   *)
  datatype valId =
      (*%
       * @format({namePath, ty})
       * L2{ namePath +1 ":" +d ty()(btvEnv) }
       *)
      (*% @prefix formatWithoutType_
       * @format({namePath, ty}) namePath
       *)
      VALIDVAR of {namePath : NameMap.namePath, ty : ty}
    | (*%
       * @format(ty)
       * L2{ "_" +1 ":" +d ty()(btvEnv) }
       *)
       (*% @prefix formatWithoutType_
       * @format(ty) "_"
       *)
      VALIDWILD of ty

  (** used after UniqueIdAllocation **)
  (*%
   * @params(btvEnv)
   *)
  (*%
   * @prefix formatWithoutType_
   *)
  datatype valIdent =
      (*%
       * @format(varIdInfo) varIdInfo()(btvEnv)
       *)
      (*% @prefix formatWithoutType_
       * @format(varIdInfo) varIdInfo
       *)
      VALIDENT of varIdInfo
    | (*%
       * @format(ty)
       * L2{ "_" +1 ":" +d ty()(btvEnv) }
       *)
      (*% @prefix formatWithoutType_
       * @format(ty) "_"
       *)
      VALIDENTWILD of ty

  (*%
   * @params(btvEnv)
   *)
  (*%
   * @prefix formatWithoutType_
   *)
  (* after unique id allocation; see also conPathInfo *)
  type conInfo =
      (*%
       * @format({displayName, funtyCon, ty, tag, tyCon})
       * L2{ displayName +1 ":" +d ty()(btvEnv) }
       *)
      (*% @prefix formatWithoutType_
       * @format({displayName, funtyCon, ty, tag, tyCon}) displayName
       *)
      {
        displayName : string,
        funtyCon : bool,
        ty : ty,
        tag : int,
        tyCon : tyCon
      }

  (*%
   * @params(btvEnv)
   *)
  (*%
   * @prefix formatWithoutType_
   * @formatter(exnTagID) format_exnTagID
   *)
  type exnInfo =
      (*%
       * @format({displayName, funtyCon, ty, tag, tyCon})
       * L2{ displayName "!" tag +1 ":" +d ty()(btvEnv) }
       *)
      (*% @prefix formatWithoutType_
       * @format({displayName, funtyCon, ty, tag, tyCon})
       * displayName "!" tag
       *)
      {
        displayName : string,
        funtyCon : bool,
        ty : ty,
        tag : exnTagID,
        tyCon : tyCon
      }

  val univKind =
      {recordKind = UNIV, eqKind = NONEQ, tyvarName = NONE}

  (* liu : structure environment is only for printCodeGeneration *)
  datatype strEntry =
      STRUCTURE of
      {
        name : string,
        strpath : Path.path,
        wrapperSysStructure : string option,
        env : (tyConEnv * varEnv * strEntry SEnv.map)
      }

  type strEnv =
      strEntry SEnv.map

  fun format_TyConIDSet (rparen, comma, lparen) set =
      TermFormat.formatEnclosedList
        (TyConID.format_id, rparen, comma, lparen)
        (TyConID.Set.listItems set)

  fun format_ExnTagIDSet (rparen, comma, lparen) set =
      TermFormat.formatEnclosedList
        (ExnTagID.format_id, rparen, comma, lparen)
        (ExnTagID.Set.listItems set)

  (*%
   * @params(btvEnv)
   *)
  datatype sigBindInfo =
      (*%
       * @format (tyConIdSet * {name, env})
       * { name +d "=" 2[ +1 env()(btvEnv) ] }
       *)
      SIGNATURE of TyConID.Set.set * {name : string, env : Env}

  (*%
   * @params(btvEnv)
   * @formatter(SEnv.map) TermFormat.formatEnclosedSEnv
   *)
  type sigEnv =
      (*%
       * @format(sigma smap)
       * smap(sigma()(btvEnv))("{",",",":","}")
       *)
      sigBindInfo SEnv.map

  (*%
   *)
  type funBindInfo =
      (*%
       * @format({funName, argName, functorSig}) funName
       *)
      {
        funName : string,
        argName : string,
        functorSig: {generativeExnTagSet : ExnTagID.Set.set,
                     argTyConIdSet : TyConID.Set.set,
                     argSigEnv : Env,
                     argStrPrefixedEnv : Env,
                     body : TyConID.Set.set * Env}
      }

  (*%
   * @formatter(funBindInfo) format_funBindInfo
   * @formatter(SEnv.map) TermFormat.formatEnclosedSEnv
   *)
  type funEnv =
       (*%
        * @format(funBindInfo smap)
        * smap(funBindInfo)("{",",",":","}")
        *)
       funBindInfo SEnv.map

  (*%
   * @params(btvEnv)
   *)
  type interfaceEnv =
       (*%
        * @format(topEnv * funEnv)
        * { "topEnv" +d "=" 2[ +2 topEnv()(btvEnv) ]
        *   +1 "funEnv" +d "=" 2[ +2 funEnv ] }
        *)
       topEnv * funEnv

  (*%
   * @params(btvEnv)
   * @formatter(TyConID.Set.set) format_TyConIDSet
   *)
  type basicInterfaceSig =
       (*%
        * @format({boundTyConIdSet, env})
        * { "bound tyConID:" 2[ +2 boundTyConIdSet()("(",",",")") ]
        *   +1 "env:" 2[ +2 env()(btvEnv) ] }
        *)
       {boundTyConIdSet : TyConID.Set.set, env : interfaceEnv}

  val emptyVarEnv = NameMap.NPEnv.empty : varEnv
  val emptyTyfield = SEnv.empty : ty SEnv.map
  val emptyTyConEnv = NameMap.NPEnv.empty : tyConEnv
  val emptySigEnv = SEnv.empty :sigEnv
  val emptyFunEnv = SEnv.empty :funEnv
  val emptyInterfaceEnv = ((SEnv.empty, SEnv.empty), SEnv.empty) : interfaceEnv
  val emptyE = (emptyTyConEnv, emptyVarEnv) : Env

  fun conPathInfoToConInfo (conpath : conPathInfo) =
      let
        val {namePath, funtyCon, ty, tag, tyCon} = conpath
      in
        {
          displayName = NameMap.namePathToString namePath,
          funtyCon = funtyCon,
          ty = ty,
          tag = tag,
          tyCon = tyCon
        } : conInfo
      end

  fun exnPathInfoToExnInfo (exnpath : exnPathInfo) =
      let
        val {namePath, funtyCon, ty, tag, tyCon} = exnpath
      in
        {
          displayName = NameMap.namePathToString namePath,
          funtyCon = funtyCon,
          ty = ty,
          tag = tag,
          tyCon = tyCon
        } : exnInfo
      end

  val kindedTyvarList =
      ref nil : tvState ref list ref

  fun newTvStateRef {lambdaDepth, recordKind, eqKind, tyvarName} =
      let
        val newTyvarID = FreeTypeVarID.generate ()
        val newTv =
            ref (TVAR {lambdaDepth = lambdaDepth,
                       id = newTyvarID,
                       recordKind = recordKind,
                       eqKind = eqKind,
                       tyvarName = tyvarName})
        val _ = kindedTyvarList := newTv::(!kindedTyvarList)
      in
        newTv
      end

  fun newty {recordKind, eqKind, tyvarName} =
      TYVARty (newTvStateRef {lambdaDepth = infiniteDepth,
                              recordKind = recordKind,
                              eqKind = eqKind,
                              tyvarName = tyvarName})

  fun newUtvar (lambdaDepth, eqKind, tvarName) =
      newTvStateRef {lambdaDepth = lambdaDepth,
                     recordKind = UNIV,
                     eqKind = eqKind,
                     tyvarName = SOME tvarName}

  fun newtyRaw {lambdaDepth, recordKind, eqKind, tyvarName} =
      TYVARty(newTvStateRef {lambdaDepth = lambdaDepth,
                             recordKind = recordKind,
                             eqKind = eqKind,
                             tyvarName = tyvarName})

  fun newtyWithLambdaDepth (lambdaDepth, {recordKind, eqKind, tyvarName}) =
      TYVARty(newTvStateRef {lambdaDepth=lambdaDepth,
                             recordKind=recordKind,
                             eqKind=eqKind,
                             tyvarName=tyvarName})

end
