(**
 * external id and internal id context
 *
 * @copyright (c) 2006, Tohoku University.
 * @author Liu Bochao
 * @version $Id: VarIDContext.ppg,v 1.13 2008/08/06 17:23:41 ohori Exp $
 *)
structure  VarIDContext = 
struct
  local
    open Types
    structure P = Path
    structure NM = NameMap
    structure NPEnv = NM.NPEnv
  in

    (*%               
     * @formatter(smap) SmlppgUtil.formatSmap
     * @formatter(ty) Types.format_ty
     * @formatter(VarID.id) VarID.format_id
     * @formatter(ExternalVarID.id) ExternalVarID.format_id
     *)
    datatype varIDItem = 
             (*%
              * @format(index) 
              *  index 
              *)
             External of ExternalVarID.id
           | (*%
              * @format(id * ty)
              *  id 
              *)
             Internal of VarID.id * ty
           | (*%
              *)
             (* dummy variable for bootstrap *)
             Dummy

    (*%
     * @formatter(smap) SmlppgUtil.formatSmap
     *)
    type topVarIDEnv =
       (*%
        * @format(varItem smap:smap)
        * "{" 2[ +1 smap(varItem)(":", "," +1) ] +1 "}"
        *)
        varIDItem SEnv.map

    (*%
     * @formatter(varIDItem) format_varIDItem
     * @formatter(npmap) NM.formatNPmap
     *)
    type varIDEnv =
         (*%
          * @format(varIDItem npmap:npmap) npmap(varIDItem)(":",+1) 
          *)
         varIDItem NPEnv.map

    (*%
     * @formatter(smap) SmlppgUtil.formatSmap
     * @formatter(formatEnv) format_varIDEnv
     *)
    type functorEnv = 
        (*%
         * @format(funEnv smap:smap) 
         * "{" 2[ +1 smap(funEnv)(":", "," +1) ] +1 "}"
         * @format:funEnv({name, 
                           argName, 
                           argExternalVarIDEnv, 
                           bodyExternalVarIDEnv,
                           generativeExternalVarIDSet}) 
         * name ":" 2[argExternalVarIDEnv:formatEnv] +d "->" +d 2[bodyExternalVarIDEnv:formatEnv]
         *)
        (
         {name : string, 
          argName : string,  
          argExternalVarIDEnv : varIDEnv,
          bodyExternalVarIDEnv : varIDEnv,
          generativeExternalVarIDSet : ExternalVarID.Set.set }
        ) SEnv.map 

    (*%
     * @formatter(functorEnv) format_functorEnv
     * @formatter(varID) format_varIDEnv
     *)
    type varIDBasis =  
        (*%
         * @format(funEnv * varEnv)
         * "funVarIDEnv:" +1 2[funEnv] 
         *  +1 "varIDEnv:" +1 2[varEnv]
         *)
         functorEnv * varIDEnv

    (*% 
     * @formatter(funVarIDEnv) format_funVarIDEnv
     *)
    type topExternalVarIDBasis = 
         (*%
          * @format(funEnv * varEnv)  
          * "{" 2[ +1 "functorEnv = " funEnv ","
          *        +1 "varIDEnv = " varEnv
          *      ] +1 "}"
          *)
         functorEnv * topVarIDEnv

    val emptyTopVarIDEnv = SEnv.empty : topVarIDEnv
    val emptyVarIDEnv = NPEnv.empty : varIDEnv
    val emptyFunctorEnv = SEnv.empty : functorEnv
    val emptyVarIDBasis = (emptyFunctorEnv, emptyVarIDEnv) : varIDBasis
    val emptyTopVarExternalVarIDBasis = 
        (emptyFunctorEnv, emptyTopVarIDEnv) : topExternalVarIDBasis

    (****  For functor template instantiation *****)
    type holeIdEnv = varIDItem VarID.Map.map
    (* refresh bounded id inside functor 
     *   functor F(A : S) =
     *    struct
     *       val x[id = 1] = true  
     *       ....
     *    end
     * Each functor application refresh id of x to reflect
     * the functor generativity.
     **)
    type templateVarRenamingBasis = 
         (string *      (* displayName for debugging *)
          VarID.id (* unique id *)) VarID.Map.map
    val emptyTemplateRenamingVarBasis = 
      VarID.Map.empty : templateVarRenamingBasis
                                                         
    fun mergeTemplateVarRenamingBasis 
            {new:templateVarRenamingBasis, old:templateVarRenamingBasis} =
        VarID.Map.unionWith #1 (new, old)

    fun lookupLocalIdInTemplateVarRenamingBasis
            (id, (templateVarRenamingBasis:templateVarRenamingBasis)) =
            VarID.Map.find(templateVarRenamingBasis, id)

    (************ prefix manipulation*********)
    fun getIdFromInternal item =
        case item of
          External _ => 
          raise Control.Bug ("topItem contains no ident")
        | Internal (id, _) => id
        | Dummy => raise Control.Bug "Dummy"

(*
    fun getNameFromItem item =
        case item of
          External (name, _) => name
        | Internal (_, _) => name
*)

(*
    fun getFromExternal item =
        case item of
          External index => index
        | Internal _ => raise Control.Bug "getFrom Current Item"
*)

    fun lookupPathIdEnv (idEnv, id) = VarID.Map.find(idEnv, id)
                                      
    fun lookupPathHoleIdEnv (idEnv, id) = VarID.Map.find(idEnv, id)
                                          
    fun mergePathHoleIdEnv (newPathHoleIdEnv, oldPathHoleIdEnv) =
        VarID.Map.unionWith #1 (newPathHoleIdEnv, oldPathHoleIdEnv)
        
    fun mergePathIdEnv (newPathIdEnv, oldPathIdEnv) =
        VarID.Map.unionWith #1 (newPathIdEnv, oldPathIdEnv)
        
    fun lookupVarInVarIDBasis (varIDBasis, namePath) =
        let
          val (funEnv, varIDEnv) = varIDBasis
        in
            NPEnv.find(varIDEnv, namePath) 
        end
          
    fun lookupVarInVarIDEnv (varIDEnv,var) =
        let
          val pathinfo = 
              case SEnv.find(varIDEnv,var) of
                NONE => raise Control.Bug (var^" undefined in varIDEnv")
              | SOME pathinfo => pathinfo
        in
          pathinfo
        end
          
    fun lookupVarInTopVarExternalVarIDBasis (topExternalVarIDBasis, varName) =
        let
            val (funEnv,topVarIDEnv) = topExternalVarIDBasis
        in  
            SEnv.find(topVarIDEnv, varName)
        end 
          
    fun lookupFunctorInVarIDBasis ((funEnv, _):varIDBasis, funid) =
        SEnv.find(funEnv,funid)
        
    fun lookupFunctorInTopVarExternalVarIDBasis ((funEnv, _):topExternalVarIDBasis, funid) =
        SEnv.find(funEnv,funid)
        
    fun lookupVar (topExternalVarIDBasis, VarIDBasis, namePath) =
        if P.isExternPath (#2 namePath) then
            lookupVarInTopVarExternalVarIDBasis
                (topExternalVarIDBasis,
                 NameMap.namePathToString(NM.getTailNamePath namePath))
        else 
            lookupVarInVarIDBasis (VarIDBasis, namePath)

    fun lookupFunctor (topExternalVarIDBasis,varIDBasis,funid) =
        case lookupFunctorInVarIDBasis (varIDBasis,funid) of
          SOME funenv => SOME funenv
        | NONE =>
          (
           case lookupFunctorInTopVarExternalVarIDBasis (topExternalVarIDBasis,funid) of
             SOME funenv => SOME funenv
           | NONE => NONE
          )
          
    fun mergeVarIDEnv {newVarIDEnv = varIDEnv1, oldVarIDEnv = varIDEnv2} =
        NPEnv.unionWith #1 (varIDEnv1, varIDEnv2)

    fun unionVarIDEnv (varIDEnv1, varIDEnv2) =
        NPEnv.unionWith (fn _ => raise Control.Bug ("duplicate entry in VarIDEnv"))
                       (varIDEnv1, varIDEnv2)

    fun mergeVarIDBasis 
            {newVarIDBasis = varIDBasis1 : varIDBasis,
             oldVarIDBasis = varIDBasis2 : varIDBasis } =
        ( 
         SEnv.unionWith #1 (#1 varIDBasis1, #1 varIDBasis2),
         NPEnv.unionWith #1 (#2 varIDBasis1, #2 varIDBasis2)
         )

    fun varIDBasisToTopVarIDBasis varNamePathEnv ((funVarIDEnv, varIDEnv) : varIDBasis)  =
        let
            val topVarIDEnv = 
                NPEnv.foldli (fn (srcVarNamePath, NM.VARID injectedVarNamePath, newVarIDEnv) =>
                                 (case NPEnv.find(varIDEnv, injectedVarNamePath) of
                                      NONE => 
                                      raise Control.Bug ("unbound variable"^ (NM.namePathToString injectedVarNamePath))
                                    | SOME item => 
                                      SEnv.insert(newVarIDEnv, NM.namePathToString srcVarNamePath, item)
                                 )
                               | (_, _, newTempVarIDEnv) => newTempVarIDEnv
                             )
                             SEnv.empty
                             varNamePathEnv
            val topFunVarIDEnv = 
                SEnv.map (fn {name,
                              argName,
                              argExternalVarIDEnv,
                              bodyExternalVarIDEnv,
                              generativeExternalVarIDSet} =>
                             let
                                 val newBodyExternalVarIDEnv =
                                     NPEnv.foldli (fn (namePath, varIDItem, newEnv) =>
                                                      NPEnv.insert(newEnv,
                                                                   NM.namePathToUsrNamePath namePath,
                                                                   varIDItem)
                                                  )
                                                  NPEnv.empty
                                                  bodyExternalVarIDEnv
                             in
                                 {name = name,
                                  argName = argName,
                                  argExternalVarIDEnv = argExternalVarIDEnv,
                                  bodyExternalVarIDEnv = newBodyExternalVarIDEnv,
                                  generativeExternalVarIDSet = generativeExternalVarIDSet}
                             end)
                         funVarIDEnv

        in
            (topFunVarIDEnv, topVarIDEnv) : topExternalVarIDBasis
        end
        
    fun extendTopVarExternalVarIDBasisWithTopVarExternalVarIDBasis
            {old = (oldTopFunEnv, oldTopVarExternalVarIDEnv), 
             new = (newTopFunEnv, newTopVarExternalVarIDEnv)}=
        let
            val newTopFunEnv = SEnv.unionWith #1 (newTopFunEnv, oldTopFunEnv)
            val newTopVarIDEnv = 
                SEnv.unionWith #1 (newTopVarExternalVarIDEnv, oldTopVarExternalVarIDEnv)
        in
            (newTopFunEnv, newTopVarIDEnv)
        end

    fun liftUpVarIDEnv varIDEnv indexMap =
        NPEnv.map (fn (Internal (id, _)) =>
                     let
                       val index = 
                           case VarID.Map.find(indexMap, id) of
                               SOME (string, index) => index
                             | NONE => raise Control.Bug ("non allocated")
                     in
                         (External index)
                     end
                   | Dummy => Dummy
                   | (External item) => External item
                 )
                 varIDEnv

    fun liftUpVarIDBasis varIDBasis indexMap =
        let
            val (funVarIDEnv, varIDEnv) = varIDBasis 
        in
            (funVarIDEnv, liftUpVarIDEnv varIDEnv indexMap)
        end

    fun extendVarIDBasisWithVarIDBasis
          {new = (newPathFunEnv, newVarIDEnv),
           old = (oldPathFunEnv, oldVarIDEnv)}
          =
          (SEnv.unionWith #1 (newPathFunEnv, oldPathFunEnv),
           NPEnv.unionWith #1 (newVarIDEnv, oldVarIDEnv))

    fun extendTopVarIDBasisWithTopVarIDBasis
            {new = (newPathFunEnv, newVarIDEnv),
             old = (oldPathFunEnv, oldVarIDEnv)}
          =
          (SEnv.unionWith #1 (newPathFunEnv, oldPathFunEnv),
           SEnv.unionWith #1 (newVarIDEnv, oldVarIDEnv))

    fun extendVarIDBasisWithVarIDEnv {varIDBasis = (funVarIDEnv, varIDEnv), newVarIDEnv}
        = (funVarIDEnv, NPEnv.unionWith #1 (newVarIDEnv, varIDEnv))

    fun recursiveExtendVarIDBasisWithVarIDBasis 
            {newVarIDBasis:varIDBasis,oldVarIDBasis:varIDBasis} 
      =
      let
          val (newPathFunEnv, newVarIDEnv) = newVarIDBasis
          val (oldPathFunEnv, oldVarIDEnv) = oldVarIDBasis
      in
          (SEnv.unionWith #1 (newPathFunEnv, oldPathFunEnv),
           NPEnv.unionWith #1 (newVarIDEnv,oldVarIDEnv))
      end

    fun recursiveExtendVarIDBasisList pathbases =
        let
            fun impl nil varIDBasis = varIDBasis
              | impl (hd :: tail) varIDBasis =
                let
                    val newVarIDBasis = 
                        recursiveExtendVarIDBasisWithVarIDBasis
                            {oldVarIDBasis = varIDBasis, newVarIDBasis = hd}
                in
                    impl tail newVarIDBasis
                end
        in
            impl pathbases emptyVarIDBasis
        end

  end
end
