(* -*- sml -*- *)
(**
 * syntax for the interface.
 *
 * @copyright (c) 2011, Tohoku University.
 * @author UENO Katsuhiro
 * @author Atsushi Ohori
 * @author Liu Bochao
 *)
structure AbsynInterface =
struct

  (*% *)
  datatype opacity =
      TRANSPARENT
    | OPAQUE_NONEQ
    | OPAQUE_EQ

  (*% *)
  datatype constraint =
      (*% @format ":" *)
      SIG_TRANSPARENT
    | (*% @format ":>" *)
      SIG_OPAQUE

  (*% @formatter(Absyn.ty) Absyn.format_ty *)
  type ty = Absyn.ty

  (*% @formatter(Loc.loc) Loc.format_loc *)
  type loc = Loc.loc

  (*%
   * @formatter(Absyn.tvar) Absyn.format_tvar
   *)
  datatype overloadInstance =
      (*% @format(exp) exp *)
      INST_OVERLOAD of overloadCase
    | (*% @format({vid: v vs}) vs(v)(".") *)
      INST_LONGVID of {vid: string list}

  withtype overloadMatch =
      (*%
       * @format({instTy, instance})
       * instTy +d "=>" 2[ +1 instance ]
       *)
      {instTy: ty, instance: overloadInstance}

  and overloadCase =
      (*%
       * @format({tyvar, expTy, matches: m ms, loc})
       * "case" +d tyvar +d "in" +d expTy +d "of" +1 ms(m)(+1 "|" +d)
       * @format:m({instTy, instance})
       * instTy +d "=>" 2[ +1 instance ]
       *)
      {tyvar: Absyn.tvar,
       expTy: ty,
       matches: {instTy: ty, instance: overloadInstance} list,
       loc: loc}

  (*% @params(vid) *)
  datatype valbindBody =
      (*%
       * @format({ty})
       * L2{ vid +1 ":" +d ty }
       *)
      VAL_EXTERN of {ty: ty}
    | (*%
       * @format({builtinName, ty})
       * R0{ vid +1 "=" +1 L2{ "_builtin" +d builtinName +1 ":" +d ty }}
       *)
      VAL_BUILTIN of {builtinName: string, ty: ty}
    | (*%
       * @format(cases)
       * R0{ vid +d "=" +1 cases }
       *)
      VAL_OVERLOAD of overloadCase

  (*% *)
  type valbind =
      (*%
       * @format({vid, body, loc}) body()(vid)
       *)
      {vid: string, body: valbindBody, loc: loc}

  (*%
   * @formatter(list) TermFormat.formatSeqList
   * @formatter(Absyn.tvar) Absyn.format_tvar
   *)
  type typbind =
      (*%
       * @format({tyvars: tv tvs, tycon, ty, opacity, loc})
       * tvs(tv)("(","," 1,")" +d) tycon +d "="
       * 2[ +1 ty +1 "as" +d opacity ]
       *)
      {tyvars: Absyn.tvar list, tycon: string, ty: ty, opacity: opacity,
       loc: loc}

  (*%
   * @formatter(option) TermFormat.formatOptionalOption
   *)
  type conbind =
      (*%
       * @format({vid, ty: ty tyopt})
       * R1{ vid +d 2[ tyopt(ty)("of" +1,) ] }
       *)
      {vid: string, ty: ty option}

  (*%
   * @formatter(seq) TermFormat.formatSeqList
   * @formatter(Absyn.tvar) Absyn.format_tvar
   *)
  type datbind =
      (*%
       * @format({tyvars: tv tvs, tycon, conbind: bind binds, opacity})
       * tvs:seq(tv)("(","," 1,")" +d) tycon +d "="
       * 2[ +1 ] binds(bind)(+1 "|" +d)
       * +1 "as" +d opacity
       *)
      {tyvars: Absyn.tvar list, tycon: string, conbind: conbind list,
       opacity: opacity}

  (*%
   * @formatter(option) TermFormat.formatOptionalOption
   *)
  datatype exbind =
      (*%
       * @format({vid, ty: ty tyopt, loc})
       * R1{ vid +d 2[ tyopt(ty)("of" +1,) ] }
       *)
      EXNDEF of {vid: string, ty: ty option, loc: loc}
    | (*%
       * @format({vid, longvid: v vs, loc})
       * R1{ vid +d 2[ "=" +d vs(v)(".") ] }
       *)
      EXNREP of {vid: string, longvid: string list, loc: loc}

  (*%
   * @formatter(declist) TermFormat.formatDeclList
   * @formatter(Absyn.sigexp) Absyn.format_sigexp
   *)
  datatype idec =
      (*%
       * @format(bind binds)
       * "val" +d binds(bind)(+1 "and" +d)
       *)
      IVAL of valbind list
    | (*%
       * @format(bind binds)
       * "type" +d binds(bind)(+1 "and" +d)
       *)
      ITYPE of typbind list
    | (*%
       * @format({datbind: bind binds, loc})
       * "datatype" +d binds(bind)(+1 "and" +d)
       *)
      IDATATYPE of {datbind: datbind list, loc: loc}
    | (*%
       * @format({tycon, origTycon: id ids, opacity, loc})
       * "datatype" +d tycon +d "="
       * 2[ +1 "datatype" +d ids(id)(".")
       *    +1 "as" +d opacity ]
       *)
      ITYPEREP of {tycon: string, origTycon: string list, opacity: opacity,
                   loc: loc}
    | (*%
       * @format({tycon, builtinName, opacity, loc})
       * "datatype" +d tycon +d "="
       * 2[ +1 "_builtin" +d "datatype" +d builtinName +1 "as" +d opacity ]
       *)
      ITYPEBUILTIN of {tycon: string, builtinName: string,
                       opacity: opacity, loc: loc}
    | (*%
       * @format(bind binds)
       * "exception" +d binds(bind)(+1 "and" +d)
       *)
      IEXCEPTION of exbind list
    | (*%
       * @format(bind binds)
       * "structure" +d binds(bind)(+1 "and" +d)
       *)
      ISTRUCTURE of strbind list

  and istrexp =
      (*%
       * @format({decs: dec decs, loc})
       * R1{ "struct" 2[ decs:declist(dec)(+1,+1) ] +1 "end" }
       *)
      ISTRUCT of {decs: idec list, loc: loc}

  withtype strbind =
      (*%
       * @format({strid, strexp, loc})
       * strid +d "=" 2[ +1 strexp ]
       *)
      {
        strid: string,
        strexp: istrexp,
        loc: loc
      }

  (*%
   * @formatter(Absyn.sigexp) Absyn.format_sigexp
   *)
  type sigbind =
      (*%
       * @format({sigid, sigexp, loc})
       * sigid +d "=" 2[ +1 sigexp ]
       *)
      {sigid: string, sigexp: Absyn.sigexp, loc: loc}

  (*%
   * @formatter(Absyn.sigexp) Absyn.format_sigexp
   * @formatter(Absyn.spec) Absyn.format_spec
   *)
  datatype funParam =
      (*%
       * @format({strid, sigexp})
       * L2{ strid +d ":" sigexp }
       *)
      FUNPARAM_FULL of {strid: string, sigexp: Absyn.sigexp}
    | (*%
       * @format(spec) spec
       *)
      FUNPARAM_SPEC of Absyn.spec

  (*%
   * @formatter(Absyn.sigexp) Absyn.format_sigexp
   *)
  type funbind =
      (*%
       * @format({funid, param, strexp, loc})
       * funid "(" !N0{ param } ")" +d "=" 2[ +1 strexp ]
       *)
      {
        funid: string,
        param: funParam,
        strexp: istrexp,
        loc: loc
      }

  (*%
   * @formatter(BigInt.int) TermFormat.format_BigInt_dec_ML
   * @formatter(option) TermFormat.formatOptionalOption
   *)
  datatype fixity =
      (*% @format(x xo) "infix" xo(x)(+d,) *)
      INFIXL of BigInt.int option
    | (*% @format(x xo) "infixr" xo(x)(+d,) *)
      INFIXR of BigInt.int option
    | (*% @format "nonfix" *)
      NONFIX

  (*% *)
  datatype itopdec =
      (*% @format(x) x *)
      IDEC of idec
    | (*%
       * @format(bind binds)
       * "functor" +d binds(bind)(+1 "and" +d)
       *)
      IFUNDEC of funbind list
    | (*%
       * @format({fixity, vids: vid vids, loc})
       * fixity 2[ +1 vids(vid)(+1) ]
       *)
      IINFIX of {fixity: fixity, vids: string list, loc: loc}

  (*%
   * @formatter(Absyn.topdec) Absyn.format_topdec
   * @formatter(dec) TermFormat.formatDeclList
   *)
  datatype itop =
      (*%
       * @format({requires: req reqs, topdecs: x xs})
       * reqs:dec(req)(+1,+1) xs(x)(+1)
       * @format:req({name, loc})
       * "_require" +d name
       *)
      INTERFACE of
      {
        requires: {name: string, loc: loc} list,
        topdecs: itopdec list
      }
    | (*%
       * @format({includes: n ns, topdecs: x xs})
       * ns:dec(n)(+1 "include" +d,+1 "include" +d)
       * xs(x)(+1)
       * @format:n({name, loc}) name
       *)
      INCLUDES of
      {
        includes: {name: string, loc: loc} list,
        topdecs: Absyn.topdec list
      }

  (*% *)
  type interfaceName =
      (*%
       * @format({hash, sourceName})
       * "\"" sourceName "\"" +d "(" hash ")"
       *)
      {
        hash: string,
        sourceName: string
      }

  (*%
   * @formatter(InterfaceID.id) InterfaceID.format_id
   * @formatter(optlist) TermFormat.formatOptionalList
   *)
  type interfaceDec =
      (*%
       * @format({interfaceId, interfaceName, requires: req reqs,
       *          topdecs: dec decs})
       * "_interface" interfaceId +d interfaceName +d "="
       * 2[ +1 {"local" 2[ reqs:optlist(req)(+1 "_require" +d,,) ]}
       *    +1 "in" 2[ +1 decs(dec)(+1) ]
       *    +1 "end" ]
       * @format:req({id,loc}) id
       *)
      {
        interfaceId: InterfaceID.id,
        interfaceName: interfaceName,
        requires: {id: InterfaceID.id, loc: loc} list,
        topdecs: itopdec list
      }
     
  (*% 
   * @formatter(declist) TermFormat.formatDeclList
   * @formatter(optlist) TermFormat.formatOptionalList
   * @formatter(InterfaceID.id) InterfaceID.format_id
   *)
  type interface =
      (*%
       * @format({decls: i is, requires: r rs, interfaceName: name nameopt,
       *          topdecs: dec decs})
       * "_interface" +d nameopt(name)
       * 2[ +1 "local" 2[ is:declist(i)(+1,+1) ]
       *    +1 "in"
       *    2[ rs:optlist(r)(+1 "_require" +d, +1,)
       *       decs:declist(dec)(+1,+1) ]
       *    +1 "end" ]
       * +1 "end"
       * @format:r({id, loc}) id
       *)
      {
        decls: interfaceDec list,
        interfaceName: interfaceName option,
        requires: {id: InterfaceID.id, loc: loc} list,
        topdecs: itopdec list
      }
 
  (*%
   * @formatter(declist) TermFormat.formatDeclList
   * @formatter(Absyn.topdec) Absyn.format_topdec
   *)
  type compileUnit =
      (*%
       * @format({interface, topdecs: dec decs})
       * interface
       * decs:declist(dec)(+1,+1)
       *)
      {
        interface : interface,
        topdecs : Absyn.topdec list
      }

end
