(**
 * A calculus with explicitly scoped user type variables.
 *
 * @copyright (c) 2006, Tohoku University.
 * @author Atsushi Ohori 
 * @author Liu Bochao
 * @version $Id: PatternCalcWithTvars.ppg,v 1.28 2008/08/24 03:54:41 ohori Exp $
 *)
structure PatternCalcWithTvars = 
struct
local
  structure FE = SMLFormat.FormatExpression
  type ty = Absyn.ty
  type path = Path.path
  type namePath = NameMap.namePath
  type caseKind = PatternCalc.caseKind
  type plsigexp = PatternCalc.plsigexp
  type constant = Absyn.constant
  type ty = Absyn.ty
  type tvar = Absyn.tvar
  type tvarKind = Absyn.tvarKind
  type kindedTvar = Absyn.kindedTvar
  type ffiAttributes = Absyn.ffiAttributes

  (*%
   * @formatter(tvarKind) Absyn.format_tvarKind
   * @formatter(Absyn.eq) Absyn.format_eq
   *)
  type nameTvarKind = 
    (*%
     * @format(name * {eqKind:eq,recordKind})
     eq name  + recordKind 
     *)
    string * {eqKind:Absyn.eq, recordKind:tvarKind}
     
  fun format_tvar (name, eq) =
    case eq of
      Absyn.EQ => [FE.Term(2, "''"), FE.Term(size name, name)]
    | Absyn.NONEQ => [FE.Term(1, "'"), FE.Term(size name, name)]

  fun format_smap parm smap =
    SmlppgUtil.formatListWithEnclosure parm (SEnv.listItemsi smap)
in
  (*%
   * @formatter(tvarKind) Absyn.format_tvarKind
   * @formatter(nameTvarKind) format_nameTvarKind
   * @formatter(smap) format_smap
   *)
  type kindedTvarSet = 
    (*%
     * @format(tvarKind:nameTvarKind map:smap) map(tvarKind)(",","(",") ") 
     *)
    {eqKind:Absyn.eq, recordKind:tvarKind} SEnv.map 

  (*%
   * @formatter(tvar) format_tvar
   * @formatter(nameTvarKind) format_nameTvarKind
   * @formatter(smap) format_smap
   *)
  type tvarNameSet = 
    (*%
     * @format(b:tvar map:smap) map(b)(",","(",") ") 
     *)
    Absyn.eq SEnv.map 

 (*%
   * @formatter(path) Path.format_pathWithoutDotend
   * @formatter(namePath) NameMap.format_namePath
   * @formatter(caseKind) PatternCalc.format_caseKind
   * @formatter(plsigexp) PatternCalc.format_plsigexp
   * @formatter(constant) Absyn.format_constant
   * @formatter(ty) Absyn.format_ty
   * @formatter(tvar) Absyn.format_tvar
   * @formatter(tvarKind) Absyn.format_tvarKind
   * @formatter(kindedTvar) Absyn.format_kindedTvar
   * @formatter(specKind) Absyn.format_specKind
   * @formatter(ffiAttributes) Absyn.format_ffiAttributes

  * @formatter(enclosedList) SmlppgUtil.formatListWithEnclosure
  * @formatter(bool) SmlppgUtil.formatBinaryChoice
  * @formatter(option) SmlppgUtil.formatPrependedOpt
  * @formatter(enclosedOpt) SmlppgUtil.formatEnclosedOpt
  * @formatter(enclosedListIfMoreThanOne) SmlppgUtil.formatListWithEnclosureIfMoreThanOne
  *)
 datatype ptexp = 
     (*%
      * @format(const * loc) const
      *)
     PTCONSTANT of constant * Loc.loc
   | (*%
      * @format(name * gk * loc) {name}
      *)
     PTGLOBALSYMBOL of string * Absyn.globalSymbolKind * Loc.loc
   | (*%
      * @format(longid * loc) {longid}
      *)
     PTVAR of namePath * Loc.loc
   | (*%
      * @format(exp * ty * loc) exp + 2[+1 ":" + ty]
      *)
     PTTYPED of ptexp * ty * Loc.loc
   | (*%
      * @format(exp1 * arg args:enclosedListIfMoreThanOne * loc)
      * L10{
      *      exp1 + args(arg)(","+1, "{", "}")
      *    }
      *)
     PTAPPM of ptexp * ptexp list * Loc.loc
   | (*%
      * @format(dec decs * exp exps * loc)
      *          !N0{ {"let" 2[ +1 decs(dec)( +1) ]}  +1
      *               {"in" 2[ +2 exps(exp)( +3 ) ] +2
      *                 "end"} }
      *)
     PTLET of ptdecl list * ptexp list * Loc.loc
   | (*%
      * @format(field fields:enclosedList * loc) fields(field)(",","{","}")
      * @format:field(lab * exp)  lab + "=" + exp
      *)
     PTRECORD of (string * ptexp) list * Loc.loc
   | (*%
      * @format(exp * field fields:enclosedList * loc)
      *   N0{ {exp} + "#" + fields(field)(",","{","}") }
      * @format:field(lab * exp)  lab + "=" + exp
      *)
     PTRECORD_UPDATE of ptexp * (string * ptexp) list * Loc.loc
   | (*%
      * @format(value values:enclosedList * loc) values(value)("," +, + "(", ")")
      *)
     PTTUPLE of ptexp list * Loc.loc
   | (*%
      * @format(value values * loc) 
      *           {"[" 2[ 1 values(value)("," +1) ] 1 "]"}
      *)
     PTLIST of ptexp list * Loc.loc
   | (*%
      * @format(exp * loc) N0{ "raise" +d {exp} }
      *)
     PTRAISE of ptexp * Loc.loc
   | (*%
      * @format(exp * rule rules * loc)
      *          N0{exp 
                    +1 "handle" 
                          +d rules(rule)( ~2[ +1 "|"] +)}
      * @format:rule(pat * exp) {pat} + "=>" +1 {exp}
      *)
     PTHANDLE of ptexp * (ptpat * ptexp) list * Loc.loc
   | (*%
      * @format(tvars * rule rules * loc) !N0{ "fn" + tvars + {rules(rule)(~2[ +1 "|"] +)} }
      * @format:rule(pat pats:enclosedListIfMoreThanOne * exp)
      * {pats(pat)(","+1, "{", "}")} + "=>" +1 {exp}
      *)
     PTFNM of tvarNameSet * (ptpat list * ptexp) list * Loc.loc 
   | (*%
      * @format(tvars * varTyOpt ids:enclosedListIfMoreThanOne * exp * loc) 
          !N0{ "fn" + tvars ids(varTyOpt)(",","{","}") 2[ +d "=>" {exp}] }
      * @format:varTyOpt(id * ty list opt) id
      *)
     PTFNM1 of tvarNameSet * (string * ty list option) list * ptexp * Loc.loc 
   | (*%
      * @format(exp exps * rule rules * caseKind * loc)
      * N0{ caseKind 2[ +d "{" {exps(exp)(",")} "}" ] 2[ +1 "of" ]+ {rules(rule)(~2[ +1 "|" ]+)}}
      * @format:rule(pat pats * exp) {"{" {pats(pat)(",") "}"} + "=>" +1 {exp}}
      *)
     PTCASEM of ptexp list *  (ptpat list * ptexp) list * caseKind * Loc.loc  
     (* primitive; caseKind added *)
   | (*%
      * @format(selector * loc)  {"#"{selector}}
      *)
     PTRECORD_SELECTOR of string * Loc.loc  
   | (*%
      * @format(selector * exp * loc) L10{"#"{selector} + {exp}}
      *)
     PTSELECT of string * ptexp * Loc.loc  
  | (*%
     * @format(exp exps * loc)
     *                    !N0{ "(" 2[ 1 exps(exp)(";" +1) ] 1 ")" }
     *)
     PTSEQ of ptexp list * Loc.loc
  | (*%
     * @format(exp * loc) "_cast" "(" exp ")"
     *)
     PTCAST of ptexp * Loc.loc
   | (*%
      * @format(exp * ty * loc)
      *     N0{ {exp} + ":" +1 "_import" +2 {ty} }
      *)
     PTFFIIMPORT of ptexp * ty * Loc.loc
   | (*%
      * @format(exp * ty * loc)
      *     N0{ {exp} + ":" +1 "_export" +2 {ty} }
      *)
     PTFFIEXPORT of ptexp * ty * Loc.loc
   | (*%
      * @format(cconv * exp * arg args * ty * loc)
      *     N0{ "_ffiapply" + cconv + exp + "(" args(arg)("," +) ")" + ":" + ty}
      *)
     PTFFIAPPLY of ffiAttributes * ptexp * ffiArg list * ty * Loc.loc

 and ffiArg =
    (*%
     * @format(exp * ty * loc)  exp + ":" + ty	
     *)    
     PTFFIARG of ptexp * ty * Loc.loc
   | (*%
      * @format(ty * exp opt * loc)
      *   "_sizeof(" ty ")" {opt(exp)(+d "*" +)}
      *)
     PTFFIARGSIZEOF of ty * ptexp option * Loc.loc
  
 and ptdecl = 
     (*%
      * @format(tvars1 * tvars2 * bind binds * loc)
      *       "val" + tvars1 + tvars2 + {binds(bind)(~4[ +1 "and"] +)}
      * @format:bind(pat * exp) {pat} +d "=" +2 {exp}
      *)
      (*
       * kindedTvarSet : explicitly scoped
       * tvarNameSet : ungarded
       *)
     PTVAL of kindedTvarSet * tvarNameSet * (ptpat * ptexp ) list * Loc.loc 
   | (*%
         * @format(tvars1 * tvars2 * dec binds * loc)
         *  "fun" + tvars1 d {binds(dec)(~4[ +1 "and"] +)}
         * @format:dec(pat * rules) {pat + rules}
         * @format:rules(rule rules) {rules(rule)(~2[ +1"|"] +)}
         * @format:rule(pat pats *  exp)
         *    {pats(pat)(+d)} +d "=" +1 {exp}
         *)
      PTDECFUN of kindedTvarSet * tvarNameSet * (ptpat * (ptpat list * ptexp) list) list * Loc.loc 
   | (*%
         * @format(tvars1 * tvars2 * dec * loc)
         *  "nonrecfun" + tvars1 + "[" tvars2 "]" +d {dec}
         * @format:dec(fpat * rules) {fpat + rules}
         * @format:rules(rule rules) {rules(rule)(~2[ +1"|"] +)}
         * @format:rule(pat pats *  exp)
         *    {pats(pat)(+d)} +d "=" +1 {exp}
         *)
      PTNONRECFUN of kindedTvarSet * tvarNameSet * (ptpat * (ptpat list * ptexp) list) * Loc.loc 
   | (*%
      * @format(tvars1 * tvars2 * bind binds * loc)
      *  "val" + tvars1 d
      *          "rec" +d {binds(bind)(~4[ +1 "and"] +)}
      * @format:bind(pat * exp) {pat} +d "=" +2 {exp}
      *)
      (*
       * kindedTvarSet : explicitly scoped
       * tvarNameSet2 : ungarded
       *)
     PTVALREC of kindedTvarSet * tvarNameSet * (ptpat * ptexp ) list * Loc.loc
   | (*%
      * @format(id ids * dec decs * loc) decs(dec)(+ 1)
      *)
     PTVALRECGROUP of string list * ptdecl list * Loc.loc
   | (*%
      * @format(bind binds * loc) "type" + {binds(bind)(~4[ +1 "and"] +)}
      * @format:bind(tyvar tyvars:enclosedList * name * ty)
      *            {tyvars(tyvar)("," +, "(", ")" +)} {name} +d "=" +2 ty
      *)
     PTTYPE of (tvar list * namePath * ty) list * Loc.loc
   | (*%
      * @format(prefix * bind binds * loc)
      *                 "datatype" + {binds(bind)(~4[ +1 "and" ] +)}
      * @format:bind(tyvar tyvars:enclosedList * tyCon * valcon valcons)
      * {tyvars(tyvar)("," +, "(", ")" +) {tyCon} + "=" +1
      *                                {valcons(valcon)(~2[ +1 "|" ] +)}}
      * @format:valcon(b * name * ty option)
      *          {b()("op" +, "")} {name} {option(ty)(~2[ +d "of" ] +)}
      *)
     PTDATATYPE of path * (tvar list * namePath * (bool * string * ty option) list) list * Loc.loc
   | (*%
      * @format(tyCon * longid * loc)
      *     "datatype" + tyCon + "=" + "datatype" + longid
      *)
     PTREPLICATEDAT of namePath * namePath * Loc.loc
   | (*%
      * @format(constructorPrefix * bind binds * decl decls * loc) "abstype"
      *)
     PTABSTYPE of path * (tvar list * namePath * (bool * string * ty option) list) list * ptdecl list * Loc.loc
   | (*%
      * @format(exc excs * loc) "exception" + {excs(exc)(~4[ +1 "and" ]+)}
      *)
     PTEXD of ptexbind list * Loc.loc
   | (*%
      * @format(localdec localdecs * dec decs * loc)
      *            "local" 2[ +2 localdecs(localdec)(+d) ] +1
      *            "in" 2[ +2 decs(dec)(+3) ] +2
      *            "end"
      *)
     PTLOCALDEC of ptdecl list * ptdecl list * Loc.loc
   | (*%
      * @format(introNames * {original, current} * loc)
      *   "structure " current + "="  2["struct" + "open" +  original + "end"]
      *)
     PTINTRO of NameMap.basicNameNPEnv * {original : path, current : path} * Loc.loc
   | (*%
      * @format(int * name names * loc)
      *                   "infix" +d {int} +d names(name)(+d)
      *)
     PTINFIXDEC of int * string list * Loc.loc
   | (*%
      * @format(int * name names * loc)
      *                   "infixr" +d {int} +d names(name)(+d)
      *)
     PTINFIXRDEC of int * string list * Loc.loc
   | (*%
      * @format(name names * loc) "nonfix" +d names(name)(+d)
      *)
     PTNONFIXDEC of string list * Loc.loc
   | (*%
      * @format ""
      *)
     PTEMPTY 

 and ptstrdecl =
     (*%
      * @format(dec decs * loc) 
      * decs(dec)(+1)
      *)
     PTCOREDEC of ptdecl list * Loc.loc
   | (*%
      * @format(dec decs * nameMap * spec * specNameMap * loc) 
      * "{" decs(dec)(+1) "}" + ":" 
      * + spec
      *)
     PTTRANCONSTRAINT of ptstrdecl list * NameMap.basicNameNPEnv * ptspec * NameMap.basicNameNPEnv * Loc.loc
   | (*%
      * @format(dec decs * nameMap * spec * specNameMap * loc) 
      * "{" decs(dec)( +1) "}" + ":>" 
      * + spec
      *)
     PTOPAQCONSTRAINT of ptstrdecl list * NameMap.basicNameNPEnv * ptspec * NameMap.basicNameNPEnv * Loc.loc
   | (*%
      * @format(prefix * functorName * (actualArg * argNameMap) * loc) 
      * prefix " = " functorName "(" actualArg ")"
      *)
     PTFUNCTORAPP of path * string * (path * NameMap.basicNameNPEnv) * Loc.loc
   | (*%  
      * @format(unit units * loc)
      * {units(unit)(0[ +1 "and"] +)}
      * @format:unit(printSigInfo * dec decs) "[" decs(dec)(+1) "]" +d
      *)
     PTANDFLATTENED of (PatternCalcFlattened.printSigInfo * ptstrdecl list) list * Loc.loc 
   | (*%
      * @format(localdec localdecs * dec decs * loc)
      *            "local" 2[ +2 localdecs(localdec)(+d) ] +1
      *            "in" 2[ +2 decs(dec)(+3) ] +2
      *            "end"
      *)
     PTSTRLOCAL of ptstrdecl list * ptstrdecl list * Loc.loc
     

 and ptpat 
  = (*%
     * @format(loc) "_"
     *)
     PTPATWILD of Loc.loc
   | (*%
      * @format(longid * loc) longid
      *)
     PTPATID of namePath * Loc.loc
   | (*%
      * @format(const * loc) const
      *)
     PTPATCONSTANT of constant * Loc.loc
   | (*%
      * @format(pat1 * pat2 * loc) R1{d {pat1} + "(" + N0{pat2} ")"}
      *)
     PTPATCONSTRUCT of ptpat * ptpat * Loc.loc
   | (*%
      * @format(ifflex * patfield patfields:enclosedList * loc) 
             patfields(patfield)(",","{","") + ifflex()("...","}")
      * @format:patfield(lab * pat) lab + "=" + pat
      *)
     PTPATRECORD of bool * (string * ptpat) list * Loc.loc
   | (*%
      * @format(id * ty opt * pat2 * loc) {id} +d "as" +d {pat2}
      *)
     PTPATLAYERED of string * ty option * ptpat * Loc.loc
   | (*%
      * @format(pat * ty * loc) {pat} + ":" +d {ty}
      *)
     PTPATTYPED of ptpat * ty * Loc.loc
   | (*%
      * @format(pat1 * pat2 * loc) "(" pat1 "|" pat2 ")"
      *)
     PTPATORPAT of ptpat * ptpat * Loc.loc

 and ptexbind =
          (*%
           * @format(b * name * ty option * loc)
           *          {name} {option(ty)(+d "of" +)}
           *)               
          PTEXBINDDEF of bool * namePath * ty option * Loc.loc
        | (*%
           * @format(b1 * left * b2 * right * loc)
           *          "exception" + {left} +d "=" +2 {right}
           *)
          PTEXBINDREP of bool * namePath * bool * namePath * Loc.loc


 and ptspec =
     (*%
      * @format(specval specvals * loc) "val" + {specvals(specval)(~4[ +1 "and"] +)} 
      * @format:specval(vid * ty) {{vid} + ":" +1 {ty}}
      *)
     PTSPECVAL of (namePath * ty) list * Loc.loc (* value *)
   |
   (*%
    * @format(typdesc typdescs * loc)  "type" + {typdescs(typdesc)(~4[ +1 "and"] +)}
    * @format:typdesc(tyvar tyvars:enclosedList * tyCon) 
    * {tyvars(tyvar) ("," +, "(", ")" +) {tyCon}}
    *)
     PTSPECTYPE of (tvar list * namePath) list  * Loc.loc (* type *)
   |
    (*%
    * @format(derivedtyp  * loc)  derivedtyp
    * @format:derivedtyp(tyvar tyvars:enclosedList * tyCon * ty)  "type" + {tyvars(tyvar) ("," +, "(", ")" +) {tyCon} } + "=" + ty
    *)
     PTSPECTYPEEQUATION of (tvar list * namePath * ty)   * Loc.loc
   |
   (*%
    * @format(typdesc typdescs * loc)  "eqtype" + {typdescs(typdesc)(~4[ +1 "and"] +)}
    * @format:typdesc(tyvar tyvars:enclosedList * tyCon) 
    * {tyvars(tyvar) ("," +, "(", ")" +) {tyCon} }
    *)
     PTSPECEQTYPE of (tvar list * namePath) list * Loc.loc (* eqtype *)
   |
   (*%
    * @format(prefix * datdesc datdescs * loc)  "datatype" + {datdescs(datdesc)(~4[ +1 "and"] +)}
    * @format:datdesc(tyvar tyvars:enclosedList * tyCon * condesc condescs) 
    * {tyvars(tyvar) ("," +, "(", ")" +) {tyCon} + "=" +1
    *                                 {condescs(condesc)(~2[ +1 "|" ] +)}}
    * @format:condesc(vid * ty option) {vid} {option(ty)(~2[ +d "of" ] +)}
    *)
     PTSPECDATATYPE of path * (tvar list * namePath * (string * ty option) list) list * Loc.loc (* datatype*)
   |
   (*%
    * @format(tyCon * patlongid * loc) 
    * "datatype" + tyCon + "=" + "datatype" + patlongid
    *)
     PTSPECREPLIC of namePath * namePath * Loc.loc (* replication *)
   |
   (*%
    * @format(exdesc exdescs * loc) "exception" + {exdescs(exdesc)(~4[ +1 "and" ]+)}
    * @format:exdesc(vid * ty option)
    *          {vid} {option(ty)(+d "of" +)}
    *)     
     PTSPECEXCEPTION of (namePath * ty option) list * Loc.loc
   | 
   (*%
    * @format(spec1 * spec2 * loc) spec1 +  ";" +1 spec2
    *)
     PTSPECSEQ of ptspec * ptspec * Loc.loc 
   |
   (*%
    * @format(spec * patlongid patlongids * loc) spec +1 !N0{ "sharing type" + {patlongids(patlongid)(~2[ +1 "="] +)} }
    *)
     PTSPECSHARE of ptspec * namePath list * Loc.loc 
   |
   (*%
    * @format
    *)
     PTSPECEMPTY

   | (*%
      * @format(namePath * loc) namePath
      *)
     PTSPECPREFIXEDSIGID of namePath * Loc.loc 
   | (*%
      * @format(spec * rlstn rlstns * loc)
      * spec +1
      * "where" + "type" + rlstns(rlstn)(+1 "where" + "type")
      * @format:rlstn(tyvarseq * longid * ty) tyvarseq + longid +  "=" + ty
      * @format:tyvarseq(tyvar tyvars:enclosedList)
      * tyvars(tyvar) ("," +, "(", ")" +)
      *)
     PTSPECSIGWHERE of ptspec * (tvar list * namePath * ty) list * Loc.loc 
(*
   | (*%
      * @format(fundesc fundescs * loc)
      * !N0{ "functor" + {fundescs(fundesc)(~2[ +1 "and" ] +)}}
      * @format:fundesc(funid * (sigexp1 * argNamePathEnv) * (sigexp2 * bodyNamePathEnv)) 
      * funid ":" +d sigexp1 +d "=>" sigexp2
      *)
     PTSPECFUNCTOR of (string * 
                       (ptspec * NameMap.basicNameNPEnv) * 
                       (ptspec * NameMap.basicNameNPEnv)) list * 
                      Loc.loc 
*)

and pttopdec = 
    (*%
     * @format (dec decs * loc) decs(dec)(+1)
     *)
    PTDECSTR of ptstrdecl list * Loc.loc
  | (*%
     * @format(sigdec sigdecs * loc)
     * "signature" + {sigdecs(sigdec)(~4[ +1 "and"] +)}
     * @format:sigdec(signame * (spec * printSigExp))
     * signame +d "=" +1 spec
     *)
    PTDECSIG of (string * (ptspec * plsigexp)) list * Loc.loc 
  | (*%
     * @format(funbind funbinds * loc)
     * !N0{ "functor" + {funbinds(funbind)(~2[ +1 "and"] +)} }
     * @format:funbind(funid * (spec * argName * argNameMap * printSigExp) * 
                       (dec decs * bodyNameMap * bodySigExpOpt) * loc)
     * funid + "(" spec +")"
     *       +  "=" +1 4[decs(dec)(+1)]
     *)
    PTDECFUNCTOR of  (string *  
                      (ptspec * string *  NameMap.basicNameNPEnv * plsigexp)  * 
                      (ptstrdecl list  * NameMap.basicNameMap * plsigexp option) * 
                      Loc.loc) list * 
                     Loc.loc 


 fun getLocExp ptexp =
     case ptexp of
     PTCONSTANT(_, loc) => loc
   | PTGLOBALSYMBOL (_,_,loc) => loc
   | PTVAR(_, loc) => loc
   | PTTYPED(_, _, loc) => loc
   | PTAPPM(_, _, loc) => loc
   | PTLET(_, _, loc) => loc
   | PTRECORD(_, loc) => loc
   | PTRECORD_UPDATE(_, _, loc) => loc
   | PTTUPLE(_, loc) => loc
   | PTLIST(_, loc) => loc
   | PTRAISE(_, loc) => loc
   | PTHANDLE(_, _, loc) => loc
   | PTFNM(_, _, loc) => loc
   | PTFNM1(_, _, _, loc) => loc
   | PTCASEM(_, _, _, loc) => loc
   | PTRECORD_SELECTOR(_, loc) => loc
   | PTSELECT(_, _, loc) => loc
   | PTSEQ(_, loc) => loc
   | PTCAST(_, loc) => loc
   | PTFFIIMPORT(_, _, loc) => loc
   | PTFFIEXPORT(_, _, loc) => loc
   | PTFFIAPPLY(_, _, _, _, loc) => loc

 fun getLocDec ptdecl =
     case ptdecl of
     PTVAL(_, _, _, loc) => loc
   | PTDECFUN (_,_, _,loc) => loc
   | PTNONRECFUN (_,_, _,loc) => loc
   | PTVALREC(_, _, _, loc) => loc
   | PTVALRECGROUP (_, _, loc) => loc
   | PTTYPE(_, loc) => loc
   | PTDATATYPE(_, _, loc) => loc
   | PTREPLICATEDAT(_, _, loc) => loc
   | PTABSTYPE(_, _, _, loc) => loc
   | PTEXD(_, loc) => loc
   | PTLOCALDEC(_, _, loc) => loc
   | PTINTRO(_, _, loc) => loc
   | PTINFIXDEC (_, _, loc) => loc
   | PTINFIXRDEC (_, _, loc) => loc
   | PTNONFIXDEC (_, loc) => loc
   | PTEMPTY => Loc.noloc


 fun getLocPat ptpat =
     case ptpat of
       PTPATWILD loc => loc
     | PTPATID (_, loc) => loc
     | PTPATCONSTANT (_, loc) => loc
     | PTPATCONSTRUCT (_, _, loc) => loc
     | PTPATRECORD (_, _, loc) => loc
     | PTPATLAYERED (_, _, _, loc) => loc
     | PTPATTYPED (_, _, loc) => loc
     | PTPATORPAT (_, _, loc) => loc

 fun getLocTopDec dec =
     case dec of
         PTDECSTR (_, loc) => loc
       | PTDECSIG (_, loc) => loc
       | PTDECFUNCTOR (_, loc) => loc

 fun getLocTopDecs decs =
     case decs of
         nil => Loc.noloc
       | h :: t => 
         getLocTopDec h

  val emptyTvarNameSet = SEnv.empty : tvarNameSet

end
end
