#
# ln -s GNUmakefile Makefile.dev
#

#HEAPSIZE = SMLSHARP_HEAPSIZE=160712592
#HEAPSIZE = :
BENCH = logic
IMPL = bitmap
REPEAT = 1
OPT = -O2 -W -Wall

BENCHMARKS := $(patsubst Benchmarks/%.o,%,$(wildcard Benchmarks/*.o))
BENCHMARKS := $(filter-out ratio_regions,$(BENCHMARKS))
IMPLS = $(patsubst heap_%.h,%,$(HEAPIMPL_HEADERS))

top: _$(IMPL)-$(BENCH)

include Makefile

force:

help: force
	@echo "Put object files of benchmarks in Benchmarks/ directory,"
	@echo "and the following commands are available:"
	@echo "  make bench"
	@echo "  make bench BENCH=<bench>"
	@echo "        do a benchmark for each heap implementation."
	@echo "  make benchone"
	@echo "  make benchone BENCH=<bench>"
	@echo "        do a benchmark for a heap implementation."
	@echo "  make benchall"
	@echo "  make benchall IMPL=<impl>"
	@echo "        do all benchmarks for a heap implementation."
	@echo "  make gcstat"
	@echo "  make gcstat BENCH=<bench>"
	@echo "        execute a benchmark for each heap with printing"
	@echo "        GC statistics."
	@echo "  make coverage"
	@echo "  make coverage BENCH=<bench>"
	@echo "        obtain coverage information by using gcov."
	@echo
	@echo "available BENCHes:"
	@echo "        $(BENCHMARKS)"
	@echo "available IMPLs:"
	@echo "        $(IMPLS)"
	@echo "default BENCH: $(BENCH)"
	@echo "default IMPL: $(IMPL)"

tablehead: force
	@echo "||!impl   ||!benchmark           ||!real  ||!user  ||!sys"

exec!%: force
	@printf "||!%-7s||!%-20s" \
	$(patsubst _%,%,$(subst -, ,$(patsubst exec!%,%,$@)))
	@$(SETENV_DEFAULT) \
	$(patsubst _%,%,$(subst -, ,$(patsubst exec!%,%,$@))); \
	tmp=`mktemp -t`; \
	trap "rm -f $$tmp" EXIT; \
	i=0; \
	while [ "$$i" -lt $(REPEAT) ]; do \
	  (time ./$(patsubst exec!%,%,$@) > /dev/null) 2>> $$tmp; \
	  st=$$?; \
	  [ "$$st" = "0" ] || break; \
	  i=`expr $$i + 1`; \
	done; \
	if [ "$$st" = "0" ]; then \
	  awk '/^ *$$/{next} \
	       {split($$2,a,"[ms]");s[$$1]+=a[1]*60+a[2];c[$$1]+=1} \
	       END{printf"||%7.3f||%7.3f||%7.3f\n", \
	       s["real"]/c["real"],s["user"]/c["user"],s["sys"]/c["sys"]}' \
	      $$tmp; \
	else echo "||>>ERROR $$st"; cat $$tmp 1>&2; fi

exec_stat!%: force
	@echo "!!" $(patsubst _%,%,$(subst -, ,$(patsubst exec_stat!%,%,$@)))
	@$(SETENV_DEFAULT) \
	$(patsubst _%,%,$(subst -, ,$(patsubst exec!%,%,$@))); \
	SMLSHARP_GCSTAT_FILE=$(patsubst exec_stat!%,%,$@).log; \
	export SMLSHARP_GCSTAT_FILE; \
	time ./$(patsubst exec_stat!%,%,$@) 2>&1 > /dev/null; \
	st=$$?; \
	[ "$$st" = "0" ] || echo ">>ERROR $$st"

implall: force
	for i in $(IMPLS); do $(MAKE) IMPL=$$i _$${i}-$(BENCH); done

implallall: force
	for i in $(IMPLS); \
	  do $(MAKE) IMPL=$$i $(patsubst %,_$${i}-%,$(BENCHMARKS)); \
	done

benchall: force
	$(MAKE) CFLAGS='$(OPT)' clean2 \
	  $(patsubst %,_$(IMPL)-%,$(BENCHMARKS)) \
	  tablehead $(patsubst %,exec!_$(IMPL)-%,$(BENCHMARKS))

benchallall: force
	$(MAKE) CFLAGS='$(OPT)' clean2 implallall \
	  tablehead \
	  $(foreach i,$(BENCHMARKS),$(foreach j,$(IMPLS),exec!_$(j)-$(i)))

bench: force
	$(MAKE) CFLAGS='$(OPT)' clean2 implall \
	  tablehead $(patsubst %,exec!_%-$(BENCH),$(IMPLS))

gcstat: force
	$(MAKE) CFLAGS='$(OPT) -DGCSTAT' \
	        clean2 top exec_stat!_$(IMPL)-$(BENCH)

gcstatall: force
	$(MAKE) CFLAGS='$(OPT) -DGCSTAT' \
	        clean2 \
	        $(patsubst %,_$(IMPL)-%,$(BENCHMARKS)) \
	        $(patsubst %,exec_stat!_$(IMPL)-%,$(BENCHMARKS))

gctime: force
	SMLSHARP_VERBOSE=3 \
	$(MAKE) CFLAGS='$(OPT) -DGCTIME' \
	        clean2 implall \
	        $(patsubst %,exec_stat!_%-$(BENCH),$(IMPLS))

gctimeall: force
	SMLSHARP_VERBOSE=3 \
	$(MAKE) CFLAGS='$(OPT) -DGCTIME' \
	        clean2 \
	        $(patsubst %,_$(IMPL)-%,$(BENCHMARKS)) \
	        $(patsubst %,exec_stat!_$(IMPL)-%,$(BENCHMARKS))

gctimeallall: force
	SMLSHARP_VERBOSE=3 \
	$(MAKE) CFLAGS='$(OPT) -DGCTIME' \
	        clean2 implallall \
		$(foreach i,$(BENCHMARKS),$(foreach j,$(IMPLS),exec_stat!_$(j)-$(i)))

coverage:
	$(MAKE) CFLAGS='-fprofile-arcs -ftest-coverage' \
	        LOCAL_LDFLAGS='-fprofile-arcs -ftest-coverage' top
	./_$(IMPL)-$(BENCH) > /dev/null
	gcov -b -l $(SOURCES:.c=.gcda)
	-rm -f $(SOURCES:.c=.gcno) $(SOURCES:.c=.gcda)

clean-coverage:
	-rm -f $(wildcard $(patsubst %.c,%.gcda##*.gcov,$(SOURCES)))

heap_impl.h: force
	echo '#include "heap_$(HEAPIMPL).h"' > $@

libsmlsharp_heap_$(IMPL).a: force
	-rm -f heap_impl.h libsmlsharp.a $(SOURCES:.c=.o)
	$(MAKE) HEAPIMPL=$(patsubst libsmlsharp_heap_%.a,%,$@) HEAPHEADER=heap_impl.h libsmlsharp.a
	mv libsmlsharp.a $@

_$(IMPL)-%:: Benchmarks/%.o libsmlsharp_entry.a libsmlsharp_heap_$(IMPL).a
	$(CC) $(LDFLAGS) $(LOCAL_LDFLAGS) -L. $< -lsmlsharp_entry -lsmlsharp_heap_$(IMPL) $(LIBS) -o $@

clean2: clean
	-rm -f heap_impl.h
	-rm -f $(patsubst %,libsmlsharp_heap_%.a,$(IMPLS))
	-rm -f $(foreach i,$(IMPLS),$(patsubst %,_$(i)-%,$(BENCHMARKS)))

Benchmarks: force
	-mkdir Benchmarks
	-rm -f Benchmarks/*
	set -e; \
	cd Benchmarks; \
	for i in `ls ../../../benchmark/benchmarks`; do \
	  ../../compiler/smlsharp_build \
	  --xtarget=$(NATIVE_TARGET) --xkeepAsm=yes \
	  --compiled-prelude=../../lib/ntprelude.smc \
	  --xskipPrinter=yes \
	  --xswitchTrace=yes --xtraceFileLoad=yes \
	  --xCFLAGS=-g -c ../../../benchmark/benchmarks/$$i/load.sml \
	  --output=$$i.o; \
	done
	set -e; \
	cd Benchmarks; \
	for i in `ls ../../../benchmark/benchmarks2`; do \
	  [ -f "../../../benchmark/benchmarks2/$$i/load.sml" ] || continue; \
	  ../../compiler/smlsharp_build \
	  --xtarget=$(NATIVE_TARGET) --xkeepAsm=yes \
	  --compiled-prelude=../../lib/ntprelude.smc \
	  --xskipPrinter=yes \
	  --xswitchTrace=yes --xtraceFileLoad=yes \
	  --xCFLAGS=-g -c ../../../benchmark/benchmarks2/$$i/load.sml \
	  --output=lc_$$i.o; \
	done
	set -e; \
	cd Benchmarks; \
	for i in `ls ../../../benchmark/benchmarks_light`; do \
	  ../../compiler/smlsharp_build \
	  --xtarget=$(NATIVE_TARGET) --xkeepAsm=yes \
	  --noprelude --xskipPrinter=yes \
	  --xswitchTrace=yes --xtraceFileLoad=yes \
	  --xCFLAGS=-g -c ../../../benchmark/benchmarks_light/$$i/load.sml \
	  --output=$$i.o; \
	done


SETENV_DEFAULT = \
setenv_default () { \
if [ -z "$$OTOMO_HEAP_LAYOUT" ]; then \
export OTOMO_HEAP_LAYOUT; \
case "$$2" in \
barnes_hut) OTOMO_HEAP_LAYOUT=53,537,380,24,1,1,1,1,1,1;; \
boyer) OTOMO_HEAP_LAYOUT=102,215,316,361,1,1,1,1,1,1;; \
count_graphs) OTOMO_HEAP_LAYOUT=128,520,258,68,21,1,1,1,1,1;; \
fft) OTOMO_HEAP_LAYOUT=1,393,566,34,1,1,1,1,1,1;; \
knuth_bendix) OTOMO_HEAP_LAYOUT=70,449,374,93,8,1,1,1,1,1;; \
lc_cpstak) OTOMO_HEAP_LAYOUT=1,320,141,532,1,1,1,1,1,1;; \
lc_diviter) OTOMO_HEAP_LAYOUT=8,31,932,22,1,1,1,1,1,1;; \
lc_divrec) OTOMO_HEAP_LAYOUT=8,22,944,19,1,1,1,1,1,1;; \
lc_gcbench) OTOMO_HEAP_LAYOUT=265,436,292,1,1,1,1,1,1,1;; \
lexgen) OTOMO_HEAP_LAYOUT=21,637,120,116,1,1,1,100,1,1;; \
life) OTOMO_HEAP_LAYOUT=572,128,186,108,1,1,1,1,1,1;; \
logic) OTOMO_HEAP_LAYOUT=54,547,350,35,9,1,1,1,1,1;; \
mandelbrot) OTOMO_HEAP_LAYOUT=1,524,466,2,1,1,1,1,1,1;; \
mlyacc) OTOMO_HEAP_LAYOUT=76,476,270,93,73,1,1,1,3,5;; \
lc_ntakl) OTOMO_HEAP_LAYOUT=1,986,4,2,1,1,1,1,1,1;; \
nucleic) OTOMO_HEAP_LAYOUT=24,108,148,65,277,374,1,1,1,1;; \
lc_perm9) OTOMO_HEAP_LAYOUT=23,268,701,1,1,1,1,1,1,1;; \
lc_puzzle) OTOMO_HEAP_LAYOUT=2,533,437,11,1,1,1,1,1,10;; \
ratio_regions) OTOMO_HEAP_LAYOUT=55,296,265,18,104,1,1,32,220,1;; \
ray) OTOMO_HEAP_LAYOUT=60,360,231,343,1,1,1,1,1,1;; \
simple) OTOMO_HEAP_LAYOUT=34,566,254,100,31,1,1,1,1,1;; \
lc_smlboyer) OTOMO_HEAP_LAYOUT=108,243,327,316,1,1,1,1,1,1;; \
lc_tak) OTOMO_HEAP_LAYOUT=1,965,26,2,1,1,1,1,1,1;; \
lc_takl) OTOMO_HEAP_LAYOUT=93,357,26,518,1,1,1,1,1,1;; \
tsp) OTOMO_HEAP_LAYOUT=118,394,160,322,1,1,1,1,1,1;; \
esac; fi; \
if [ -z "$$SMLSHARP_HEAPSIZE" ]; then \
export SMLSHARP_HEAPSIZE; \
case "$$2" in \
lc_gcbench) SMLSHARP_HEAPSIZE=76021760;; \
lc_perm9) SMLSHARP_HEAPSIZE=173015040;; \
esac; fi; \
}; setenv_default
