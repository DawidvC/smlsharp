(* -*- sml -*- *)

structure I = InsnDef

fun tv count =
    I.UN (!count) before count := !count + 1

fun toDNF (h1::t1, t2) = map (fn t => h1 @ t) t2 @ toDNF (t1, t2)
  | toDNF (nil, t2) = nil

fun expand f (nil, x, y) = y
  | expand f (h::t, x, y) = f (h, x, expand f (t, x, y))

fun makeMETAIF x = expand I.METAIF x
fun expandMETAVARIATION (l, x) = expand makeMETAIF (l, x, x)

fun defaultSyntax pos nil = nil
  | defaultSyntax pos (arg1::args) =
    let
      fun syntax (arg::args) =
          I.FMTSTR (",", pos) :: I.FMTARG (arg, pos) :: syntax args
        | syntax nil = nil
    in
      I.FMTARG (arg1, pos) :: syntax args
    end

%%

%name Insn
%verbose
%pos int
%arg (c) : int ref

%term
    STRING of string
  | EOF
  | EQ
  | NUM of int
  | SYM of string
  | B
  | H
  | W
  | L
  | N
  | NL
  | FS
  | F
  | FL
  | P
  | SZ
  | SH
  | LSZ
  | VARA
  | VARB
  | VARC
  | VARD
  | SIZE
  | SCALE
  | SHIFT
  | TY
  | DISPLACEMENT
  | IMM
  | LABEL
  | EXTERNA
  | EXTERNB
  | LSIZEA
  | LSIZEB
  | IP
  | SP
  | HR
  | SUFFIX
  | SYNTAX
  | PREPROCESS
  | SEMANTICS
  | ALTERNATE
  | TMPVAR
  | METAIF
  | METAELIF
  | METAELSE
  | METAVARIATIONS
  | IF
  | ELSE
  | LPAREN
  | RPAREN
  | LBRACE
  | RBRACE
  | LBRACKET
  | RBRACKET
  | COMMA
  | SEMICOLON
  | COLON
  | PLUS
  | MINUS
  | STAR
  | DIV
  | MOD
  | DVMD
  | QUOT
  | REM
  | QTRM
  | ADDO
  | SUBO
  | MULO
  | DIVO
  | QUOTO
  | DVMDO
  | QTRMO
  | LSHIFT
  | RSHIFT
  | RASHIFT
  | ANDAND
  | OROR
  | ANDB
  | ORB
  | NOTB
  | XORB
  | EQEQ
  | GE
  | LE
  | GT
  | LT
  | ABS
  | ABSO
  | ALLOC
  | SIZEOF
  | VAR
  | REG
  | LOCAL
  | LABELREF
  | MEM
  | NULL
  | COPY
  | BARRIER
  | ENTER
  | LEAVE
  | UNWIND
  | FFCALL
  | FUNCALL
  | SYSCALL
  | FFEXPORT
  | PUSHTRAP
  | POPTRAP
  | RAISE
  | NEXT
  | CONTINUE
  | INVAL of string

%nonterm
    top of I.def list
  | defs of I.def list
  | ty of I.ty
  | cty of I.ty
  | sym of string
  | arg of I.arg
  | args' of I.arg list
  | args of I.arg list
  | num of int
  | format of I.format list
  | mcond of I.metacond
  | mconds of I.metacond list list
  | synelse of I.format list I.metaif
  | syntax of I.format list I.metaif
  | ptr of I.ptr
  | acc of I.acc
  | accs of I.acc list
  | exps' of I.exp list
  | exps of I.exp list
  | exp of I.exp
  | cond of I.cond
  | stmt of I.statement list
  | stmts of I.statement list
  | tmpvar of (string * I.ty * I.pos) list
  | tmpvars of (string * I.ty * I.pos) list
  | semelse of I.semantics I.metaif
  | sem of I.semantics I.metaif
  | insnTys of I.ty list
  | insnTy of I.ty list
  | suffixes of string option list
  | suffix of string option list
  | syntaxOpt of I.format list I.metaif option
  | prepOpt of I.preprocess option
  | altOpt of I.semantics option
  | insnDef of I.def

%eop EOF
%noshift EOF

%left OROR
%left ANDAND
%left ORB
%left XORB
%left ANDB
%left EQEQ
%left LT GT LE GE
%left LSHIFT RSHIFT RASHIFT
%left PLUS MINUS ADDO SUBO
%left STAR MULO DIV DIVO MOD QUOT QUOTO REM DVMD DVMDO QTRM QTRMO
%nonassoc NOTB

%%

top     : defs (defs)

defs    : (* none *)  ([])
        | insnDef defs (insnDef :: defs)

ty      : W  (I.W)
        | L  (I.L)
        | N  (I.N)
        | NL (I.NL)
        | F  (I.F)
        | FS (I.FS)
        | FL (I.FL)
        | P  (I.P)     (* pointer *)

cty     : ty (ty)
        | B  (I.B)
        | H  (I.H)
        | SZ (I.SZ)    (* size of a value *)
        | SH (I.SH)    (* shift count *)
        | LSZ (I.LSZ)  (* size_t *)
        | TY (I.TY)    (* type specified by instruction suffix *)

sym     : SYM  (SYM)
        | W    ("W")
        | L    ("L")
        | N    ("N")
        | NL   ("NL")
        | F    ("F")
        | FS   ("FS")
        | FL   ("FL")
        | P    ("P")
        | SZ   ("SZ")
        | LSZ  ("LSZ")
        | B    ("B")
        | H    ("H")
        | TY   ("TY")
        | IF   ("IF")

arg     : VARA (I.VARX 0w0)
        | VARB (I.VARX 0w1)
        | VARC (I.VARX 0w2)
        | VARD (I.VARX 0w3)
        | SIZE (I.SIZE)
        | SCALE (I.SCALE)
        | SHIFT (I.SHIFT)
        | DISPLACEMENT (I.DISPLACEMENT)
        | IMM (I.IMM)
        | LABEL (I.LABEL)
        | EXTERNA (I.EXTERN 0w0)
        | EXTERNB (I.EXTERN 0w1)
        | LSIZEA (I.LSIZE 0w0)
        | LSIZEB (I.LSIZE 0w1)

args'   : arg COMMA arg    ([arg1, arg2])
        | arg COMMA args'  (arg :: args')

args    : (* none *)  ([])
        | arg         ([arg])
        | args'       (args')

num     : NUM         (NUM)
        | MINUS NUM   (~NUM)

format  : (* none *)     ([])
        | STRING format  (I.FMTSTR (STRING, (STRINGleft, STRINGright))::format)
        | arg format     (I.FMTARG (arg, (argleft, argright))::format)

mcond   : arg EQEQ num    (I.METAEQ (arg, num, (argleft, numright)))
        | TY EQEQ ty      (I.METAEQTY (ty, (TYleft, tyright)))
        | SUFFIX EQEQ sym
            (I.METAEQSUFFIX (Utils.toLower sym, (SUFFIXleft, symright)))

mconds  : mcond                 ([[mcond]])
        | LPAREN mconds RPAREN  (mconds)
        | mconds ANDAND mconds  (toDNF (mconds1, mconds2))
        | mconds OROR mconds    (mconds1 @ mconds2)

synelse : METAELSE syntax                (syntax)
        | METAELIF mconds syntax synelse (makeMETAIF (mconds, syntax, synelse))

syntax  : format  (I.META (format, (formatleft, formatright)))
        | METAIF mconds syntax synelse   (makeMETAIF (mconds, syntax, synelse))

ptr     : VAR LPAREN exp RPAREN (I.VAR exp)
        | REG LPAREN exp RPAREN (I.REG exp)
        | LOCAL LPAREN exp RPAREN (I.LOCAL exp)
        | acc LBRACKET exp RBRACKET
            (I.MEM {base = I.ACC (acc, (accleft, accright)),
                    offset = exp,
                    scale = I.NUM (1, tv c, (~1, ~1))})
        | acc LBRACKET exp COMMA exp RBRACKET
            (I.MEM {base = I.ACC (acc, (accleft, accright)),
                    offset = exp1,
                    scale = exp2})

(*
acc     : STAR LPAREN cty STAR RPAREN ptr  (I.REF (cty, ptr))
*)
acc     : ptr COLON cty   (I.REF (cty, ptr))
        | ptr             (I.REF (tv c, ptr))
        | IP              (I.IPREG)
        | SP              (I.SPREG)
        | HR              (I.HRREG)
        | SYM             (I.TMPVAR (SYM, tv c, (SYMleft, SYMright)))

accs    : acc             ([acc])
        | acc COMMA accs  (acc::accs)

exps'   : exp             ([exp])
        | exp COMMA exps' (exp::exps')

exps    : (* none *)      (nil)
        | exps'           (exps')

exp     : LPAREN exp RPAREN (exp)
        | NULL            (I.NULL (NULLleft, NULLright))
        | num             (I.NUM (num, tv c, (numleft, numright)))
        | num COLON cty   (I.NUM (num, cty, (numleft, ctyright)))
        | arg             (I.ARG (arg, tv c, (argleft, argright)))
        | ANDB ptr        (I.PTR (ptr, (ptrleft, ptrright)))
        | acc             (I.ACC (acc, (accleft, accright)))
        | cond            (I.COND cond)
        | exp PLUS exp    (I.ADD (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp MINUS exp   (I.SUB (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp STAR exp    (I.MUL (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp DIV exp     (I.DIV (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp MOD exp     (I.MOD (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp DVMD exp    (I.DVMD (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp QUOT exp    (I.QUOT (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp REM exp     (I.REM (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp QTRM exp    (I.QTRM (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp ADDO exp    (I.ADDO (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp SUBO exp    (I.SUBO (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp MULO exp    (I.MULO (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp DIVO exp    (I.DIVO (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp QUOTO exp   (I.QUOTO (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp DVMDO exp   (I.DVMDO (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp QTRMO exp   (I.QTRMO (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp LSHIFT exp  (I.LSHIFT (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp RSHIFT exp  (I.RSHIFT (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp RASHIFT exp (I.RASHIFT (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp ANDB exp    (I.ANDB (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp ORB exp     (I.ORB (exp1, exp2, tv c, (exp1left, exp2right)))
        | NOTB exp        (I.NOTB (exp1, tv c, (NOTBleft, expright)))
        | exp XORB exp    (I.XORB (exp1, exp2, tv c, (exp1left, exp2right)))
        | ABS LPAREN exp RPAREN  (I.ABS (exp, tv c, (ABSleft, RPARENright)))
        | ABSO LPAREN exp RPAREN  (I.ABSO (exp, tv c, (ABSOleft, RPARENright)))
        | LPAREN cty RPAREN LPAREN exp RPAREN
            (I.CAST {fromTy = tv c, toTy = tv c, exp = exp,
                     pos = (LPARENleft, RPARENright)})
        | LABELREF LPAREN exp RPAREN
            (I.LABELREF (exp, (LABELREFleft, RPARENright)))
        | SIZEOF cty
            (I.SIZEOF (cty, tv c, (SIZEOFleft, ctyright)))
        | SIZEOF LPAREN cty RPAREN
            (I.SIZEOF (cty, tv c, (SIZEOFleft, ctyright)))
        | FFEXPORT LPAREN exp COMMA exp COMMA exp RPAREN
            (I.FFEXPORT {ffty = exp1,
                         entry = exp2,
                         env = exp3,
                         pos = (FFEXPORTleft, RPARENright)})

cond    : exp GE exp      (I.GE (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp LE exp      (I.LE (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp GT exp      (I.GT (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp LT exp      (I.LT (exp1, exp2, tv c, (exp1left, exp2right)))
        | exp EQEQ exp    (I.EQ (exp1, exp2, tv c, (exp1left, exp2right)))

stmt    : LBRACE stmts RBRACE
            (stmts)
        | IF LPAREN cond RPAREN stmt ELSE stmt
            ([I.IF (cond, stmt1, stmt2, (IFleft, stmtright))])
        | IF LPAREN cond RPAREN stmt
            ([I.IF (cond, stmt, nil, (IFleft, stmtright))])
        | accs EQ exp SEMICOLON
            ([I.ASSIGN (accs, exp, map (fn _ => tv c) accs,
                       (accsleft, SEMICOLONright))])
        | ALLOC LPAREN acc COMMA exp RPAREN SEMICOLON
            ([I.ALLOC {dst = acc, size = exp, pos = (accleft, RPARENright)}])
        | COPY LPAREN exp COMMA exp COMMA exp RPAREN SEMICOLON
            ([I.COPY {dst = exp1,
                      src = exp2,
                      size = exp3,
                      pos = (COPYleft, RPARENright)}])
        | BARRIER LPAREN exp COMMA exp RPAREN SEMICOLON
            ([I.BARRIER {objbase = exp1,
                         ptr = exp2,
                         pos = (BARRIERleft, RPARENright)}])
        | ENTER LPAREN exp RPAREN SEMICOLON
            ([I.ENTER (exp, (ENTERleft, RPARENright))])
        | LEAVE LPAREN exp RPAREN SEMICOLON
            ([I.LEAVE (exp, (LEAVEleft, RPARENright))])
        | UNWIND LPAREN exp RPAREN SEMICOLON
            ([I.UNWIND (exp, (UNWINDleft, RPARENright))])
        | FUNCALL LPAREN exp RPAREN LPAREN exps RPAREN SEMICOLON
            ([I.FUNCALL {func = exp1,
                         args = exps,
                         pos = (FUNCALLleft, RPAREN2right)}])
        | FFCALL LPAREN exp COMMA exp COMMA exp RPAREN LPAREN exps RPAREN
                 SEMICOLON
            ([I.FFCALL {ffty = exp1,
                        entry = exp2,
                        dst = exp3,
                        args = exps,
                        pos = (FFCALLleft, RPAREN2right)}])
        | SYSCALL LPAREN exp RPAREN SEMICOLON
            ([I.SYSCALL {prim = exp, pos = (SYSCALLleft, RPARENright)}])
        | PUSHTRAP LPAREN exp RPAREN SEMICOLON
            ([I.PUSHTRAP (exp, (PUSHTRAPleft, RPARENright))])
        | POPTRAP LPAREN RPAREN SEMICOLON
            ([I.POPTRAP (POPTRAPleft, RPARENright)])
        | RAISE LPAREN RPAREN SEMICOLON
            ([I.RAISE (RAISEleft, RPARENright)])
        | NEXT SEMICOLON
            ([I.NEXT (NEXTleft, NEXTright)])
        | CONTINUE SEMICOLON
            ([I.CONTINUE (CONTINUEleft, CONTINUEright)])

stmts   : (* none *)  ([])
        | stmt stmts  (stmt @ stmts)

tmpvars : SYM COLON cty               ([(SYM, cty, (SYMleft, ctyright))])
        | SYM COLON cty COMMA tmpvars ((SYM, cty, (SYMleft, ctyright))::tmpvars)

tmpvar  : (* none *)                  ([])
        | TMPVAR tmpvars SEMICOLON    (tmpvars)

semelse : METAELSE sem                (sem)
        | METAELIF mconds sem semelse (makeMETAIF (mconds, sem, semelse))

sem     : tmpvar stmts
            (I.META ({tmpvars=tmpvar, statements=stmts},
                     (tmpvarleft, stmtsright)))
        | METAIF mconds sem semelse   (makeMETAIF (mconds, sem, semelse))
        | METAVARIATIONS mconds sem   (makeMETAIF (mconds, sem, sem))

insnTys : ty               ([ty])
        | ty COMMA insnTys (ty::insnTys)

insnTy  : (* none *)            ([])
        | LBRACE insnTys RBRACE (insnTys)

suffixes: sym                   ([SOME (Utils.toLower sym)])
        | sym COMMA suffixes    (SOME (Utils.toLower sym) :: suffixes)

suffix  : (* none *)            ([NONE])
        | LT GT                 ([NONE])
        | LT suffixes GT        (suffixes)
        | LT COMMA suffixes GT  (NONE :: suffixes)

syntaxOpt: (* none *)           (NONE)
         | SYNTAX COLON syntax  (SOME syntax)

prepOpt : (* none *)            (NONE)
        | PREPROCESS COLON SYM LPAREN args RPAREN
            (SOME {name=SYM, args=args, pos=(PREPROCESSleft, RPARENright)})

altOpt  : (* none *)            (NONE)
        | ALTERNATE COLON tmpvar stmts
            (SOME {tmpvars=tmpvar, statements=stmts})

insnDef : SYM suffix insnTy LPAREN args RPAREN LBRACE
          syntaxOpt
          prepOpt
          SEMANTICS COLON sem
          altOpt
          RBRACE
            ({name = Utils.toLower SYM,
              suffixList = suffix,
              tyList = insnTy,
              args = args,
              syntax = case syntaxOpt of
                         SOME syntax => syntax
                       | NONE =>
                         I.META (defaultSyntax (argsleft, argsright) args,
                                 (argsleft, argsright)),
              preprocess = prepOpt,
              semantics = sem,
              alternate = altOpt,
              pos = (SYMleft, RBRACEright)})
