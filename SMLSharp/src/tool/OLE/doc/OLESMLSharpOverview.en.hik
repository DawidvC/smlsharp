// Oveview of OLE/SML#

''OLE/SML#'' is a support tool to enable SML code to access Microsoft COM/OLE objects.

''OLE/SML#'' depends on SML# features including FFI, LMLML, Finalizer and FLOB.

!Components.

:OLE2SML.exe: Given a type library, this command generates SML# source code to access COM objects which are described in the type library.
:OLE.sml: Base library to access Microsoft COM infrastructure.

!Usage.

OLE2SML.exe generates SML code from user specified type library.

 $ OLE.exe [options] TYPELIB_FILENAME
 $ OLE.exe [options] ProgID

Type library can be specified by
* file path of the type library, or
* ProgID of a Coclass of which type information is described in the type library.

Options:

:-c CLASSNAME: generates wrapper codes for specified coclasses or dispatch interfaces only. You can use this option more than once. If no ''-c'' option is specified, wrappers for all coclasses and dispatch interfaces are generated. 
:-o FILENAME: writes wrapper code into the specified file name. If no ''-o'' option is specified, file name is ''TYPELIBNAME.sml'' .
:-h: shows usage.

!Example.

For example, let's write a SML# code to operate Internet Explorer (=IE).

First, use OLE2SML.exe to generate a wrapper code for IE.

OLE2SML takes a ProgID as its command line parameter.
ProgID of IE is "InternetExplorer.Application".

 $ OLE2SML.exe InternetExplorer.Application

Instead of ProgID, you can specify the file path of the type library.

 $ OLE2SML.exe "C:\\WINDOWS\\System32\\shdocvw.dll"

The type library ''C:\WINDOWS\System32\shdocvw.dll'' defines COM objects 
implemented in Internet Explorer.

By default, ''OLE2SML.exe'' generates code for every coclass and interfaces
described in the specified type library.
If you use only some of them, you can specify them with ''-c'' option to reduce the size of generated code.

 $ OLE2SML.exe -c InternetExplorer InternetExplorer.Application
 $ OLE2SML.exe -c InternetExplorer "C:\\WINDOWS\\System32\\shdocvw.dll"

The generated code contains code for InternetExplorer coclass only.

The following session creates an IE instance, navigates to Home page.

 # use "OLE.sml";
     :
 # OLE.initialize [OLE.COINIT_MULTITHREADED];
 val it = () : unit

Loads and initializes the OLE library.

 # use "./SHDocVw.sml";
 signature SHDocVw =
     :
 end
 structure SHDocVw : SHDocVw

Loads the generated wrapper code for IE.
The wrapper code defines a structure with the name of the type library.

 # val IE = SHDocVw.newInternetExplorer ();
 val IE =
    {
      :
    }
    : SHDocVw.InternetExplorer

Creates an instance of IE.
'''new'''''coclass'' is the constructor function of ''coclass''.

 # #getVisible IE ();
 val it = false : bool
 # #setVisible IE true;
 val it = () : unit

Accesses the '''visible''' property of IE.

 # #GoHome IE ();
 val it = () : unit

Invokes the '''GoHome''' method of IE.

 # #release IE ();
 val it = 0wx0 : Word32.word

COM manages the life cycle of objects by reference count.
OLE/SML# manages reference count of each COM object internally, depending on
GC of SML#, so you does not have to call '''addRef''' and '''release'''
explicitly.
In this example, however, the reference to an IE object is bound at global.
Because a global binding will not become garbage in GC of SML#, 
you have to call '''release''' after use, so that global binding is released.

 # OLE.uninitialize ();
 val it = () : unit

Clean-up OLE library.

!!Other examples.
*[[Internet Explorer|http://www.pllab.riec.tohoku.ac.jp/smlsharp/tools/OLE/sample/SHDocVwSample.sml]]
*[[Excel|http://www.pllab.riec.tohoku.ac.jp/smlsharp/tools/OLE/sample/ExcelSample.sml]]
*[[Windows Scripting|http://www.pllab.riec.tohoku.ac.jp/smlsharp/tools/OLE/sample/ScriptingSample.sml]]
*[[Late binding|http://www.pllab.riec.tohoku.ac.jp/smlsharp/tools/OLE/sample/DotNetSample.sml]]

!Topics in OLE/SML#.

*[[OLESMLSharpOverview]]
*[[OLESMLSharpMapping]]
*[[API|http://www.pllab.riec.tohoku.ac.jp/smlsharp/tools/OLE/doc/api/]]
*[[OLESMLSharpMiniGuideOfCOM]]
*[[OLESMLSharpImplementationOverview]]
